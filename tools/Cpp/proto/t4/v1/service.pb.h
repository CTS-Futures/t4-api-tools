// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: t4/v1/service.proto
// Protobuf C++ Version: 6.31.1

#ifndef t4_2fv1_2fservice_2eproto_2epb_2eh
#define t4_2fv1_2fservice_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6031001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "t4/v1/auth/auth.pb.h"
#include "t4/v1/market/market.pb.h"
#include "t4/v1/account/account.pb.h"
#include "t4/v1/orderrouting/orderrouting.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_t4_2fv1_2fservice_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_t4_2fv1_2fservice_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_t4_2fv1_2fservice_2eproto;
}  // extern "C"
namespace t4proto {
namespace v1 {
namespace service {
class ClientMessage;
struct ClientMessageDefaultTypeInternal;
extern ClientMessageDefaultTypeInternal _ClientMessage_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ClientMessage_class_data_;
class Heartbeat;
struct HeartbeatDefaultTypeInternal;
extern HeartbeatDefaultTypeInternal _Heartbeat_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Heartbeat_class_data_;
class ServerMessage;
struct ServerMessageDefaultTypeInternal;
extern ServerMessageDefaultTypeInternal _ServerMessage_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ServerMessage_class_data_;
}  // namespace service
}  // namespace v1
}  // namespace t4proto
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace t4proto {
namespace v1 {
namespace service {

// ===================================================================


// -------------------------------------------------------------------

class Heartbeat final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:t4proto.v1.service.Heartbeat) */ {
 public:
  inline Heartbeat() : Heartbeat(nullptr) {}
  ~Heartbeat() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Heartbeat* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Heartbeat));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Heartbeat(::google::protobuf::internal::ConstantInitialized);

  inline Heartbeat(const Heartbeat& from) : Heartbeat(nullptr, from) {}
  inline Heartbeat(Heartbeat&& from) noexcept
      : Heartbeat(nullptr, ::std::move(from)) {}
  inline Heartbeat& operator=(const Heartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Heartbeat& operator=(Heartbeat&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Heartbeat& default_instance() {
    return *reinterpret_cast<const Heartbeat*>(
        &_Heartbeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Heartbeat& a, Heartbeat& b) { a.Swap(&b); }
  inline void Swap(Heartbeat* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Heartbeat* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Heartbeat* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Heartbeat>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Heartbeat& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Heartbeat& from) { Heartbeat::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Heartbeat* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "t4proto.v1.service.Heartbeat"; }

 protected:
  explicit Heartbeat(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Heartbeat(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Heartbeat& from);
  Heartbeat(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Heartbeat&& from) noexcept
      : Heartbeat(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTimestampFieldNumber = 1,
  };
  // int64 timestamp = 1;
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:t4proto.v1.service.Heartbeat)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Heartbeat& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t4_2fv1_2fservice_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Heartbeat_class_data_;
// -------------------------------------------------------------------

class ClientMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:t4proto.v1.service.ClientMessage) */ {
 public:
  inline ClientMessage() : ClientMessage(nullptr) {}
  ~ClientMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ClientMessage* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ClientMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ClientMessage(::google::protobuf::internal::ConstantInitialized);

  inline ClientMessage(const ClientMessage& from) : ClientMessage(nullptr, from) {}
  inline ClientMessage(ClientMessage&& from) noexcept
      : ClientMessage(nullptr, ::std::move(from)) {}
  inline ClientMessage& operator=(const ClientMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientMessage& operator=(ClientMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientMessage& default_instance() {
    return *reinterpret_cast<const ClientMessage*>(
        &_ClientMessage_default_instance_);
  }
  enum PayloadCase {
    kHeartbeat = 1,
    kLoginRequest = 2,
    kAuthenticationTokenRequest = 3,
    kMarketDepthSubscribe = 100,
    kMarketByOrderSubscribe = 101,
    kAccountSubscribe = 200,
    kOrderSubmit = 300,
    kOrderRevise = 301,
    kOrderPull = 302,
    kCreateUds = 340,
    PAYLOAD_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(ClientMessage& a, ClientMessage& b) { a.Swap(&b); }
  inline void Swap(ClientMessage* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientMessage* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientMessage* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ClientMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ClientMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ClientMessage& from) { ClientMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ClientMessage* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "t4proto.v1.service.ClientMessage"; }

 protected:
  explicit ClientMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ClientMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ClientMessage& from);
  ClientMessage(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ClientMessage&& from) noexcept
      : ClientMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHeartbeatFieldNumber = 1,
    kLoginRequestFieldNumber = 2,
    kAuthenticationTokenRequestFieldNumber = 3,
    kMarketDepthSubscribeFieldNumber = 100,
    kMarketByOrderSubscribeFieldNumber = 101,
    kAccountSubscribeFieldNumber = 200,
    kOrderSubmitFieldNumber = 300,
    kOrderReviseFieldNumber = 301,
    kOrderPullFieldNumber = 302,
    kCreateUdsFieldNumber = 340,
  };
  // .t4proto.v1.service.Heartbeat heartbeat = 1;
  bool has_heartbeat() const;
  private:
  bool _internal_has_heartbeat() const;

  public:
  void clear_heartbeat() ;
  const ::t4proto::v1::service::Heartbeat& heartbeat() const;
  [[nodiscard]] ::t4proto::v1::service::Heartbeat* PROTOBUF_NULLABLE release_heartbeat();
  ::t4proto::v1::service::Heartbeat* PROTOBUF_NONNULL mutable_heartbeat();
  void set_allocated_heartbeat(::t4proto::v1::service::Heartbeat* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_heartbeat(::t4proto::v1::service::Heartbeat* PROTOBUF_NULLABLE value);
  ::t4proto::v1::service::Heartbeat* PROTOBUF_NULLABLE unsafe_arena_release_heartbeat();

  private:
  const ::t4proto::v1::service::Heartbeat& _internal_heartbeat() const;
  ::t4proto::v1::service::Heartbeat* PROTOBUF_NONNULL _internal_mutable_heartbeat();

  public:
  // .t4proto.v1.auth.LoginRequest login_request = 2;
  bool has_login_request() const;
  private:
  bool _internal_has_login_request() const;

  public:
  void clear_login_request() ;
  const ::t4proto::v1::auth::LoginRequest& login_request() const;
  [[nodiscard]] ::t4proto::v1::auth::LoginRequest* PROTOBUF_NULLABLE release_login_request();
  ::t4proto::v1::auth::LoginRequest* PROTOBUF_NONNULL mutable_login_request();
  void set_allocated_login_request(::t4proto::v1::auth::LoginRequest* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_login_request(::t4proto::v1::auth::LoginRequest* PROTOBUF_NULLABLE value);
  ::t4proto::v1::auth::LoginRequest* PROTOBUF_NULLABLE unsafe_arena_release_login_request();

  private:
  const ::t4proto::v1::auth::LoginRequest& _internal_login_request() const;
  ::t4proto::v1::auth::LoginRequest* PROTOBUF_NONNULL _internal_mutable_login_request();

  public:
  // .t4proto.v1.auth.AuthenticationTokenRequest authentication_token_request = 3;
  bool has_authentication_token_request() const;
  private:
  bool _internal_has_authentication_token_request() const;

  public:
  void clear_authentication_token_request() ;
  const ::t4proto::v1::auth::AuthenticationTokenRequest& authentication_token_request() const;
  [[nodiscard]] ::t4proto::v1::auth::AuthenticationTokenRequest* PROTOBUF_NULLABLE release_authentication_token_request();
  ::t4proto::v1::auth::AuthenticationTokenRequest* PROTOBUF_NONNULL mutable_authentication_token_request();
  void set_allocated_authentication_token_request(::t4proto::v1::auth::AuthenticationTokenRequest* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_authentication_token_request(::t4proto::v1::auth::AuthenticationTokenRequest* PROTOBUF_NULLABLE value);
  ::t4proto::v1::auth::AuthenticationTokenRequest* PROTOBUF_NULLABLE unsafe_arena_release_authentication_token_request();

  private:
  const ::t4proto::v1::auth::AuthenticationTokenRequest& _internal_authentication_token_request() const;
  ::t4proto::v1::auth::AuthenticationTokenRequest* PROTOBUF_NONNULL _internal_mutable_authentication_token_request();

  public:
  // .t4proto.v1.market.MarketDepthSubscribe market_depth_subscribe = 100;
  bool has_market_depth_subscribe() const;
  private:
  bool _internal_has_market_depth_subscribe() const;

  public:
  void clear_market_depth_subscribe() ;
  const ::t4proto::v1::market::MarketDepthSubscribe& market_depth_subscribe() const;
  [[nodiscard]] ::t4proto::v1::market::MarketDepthSubscribe* PROTOBUF_NULLABLE release_market_depth_subscribe();
  ::t4proto::v1::market::MarketDepthSubscribe* PROTOBUF_NONNULL mutable_market_depth_subscribe();
  void set_allocated_market_depth_subscribe(::t4proto::v1::market::MarketDepthSubscribe* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_market_depth_subscribe(::t4proto::v1::market::MarketDepthSubscribe* PROTOBUF_NULLABLE value);
  ::t4proto::v1::market::MarketDepthSubscribe* PROTOBUF_NULLABLE unsafe_arena_release_market_depth_subscribe();

  private:
  const ::t4proto::v1::market::MarketDepthSubscribe& _internal_market_depth_subscribe() const;
  ::t4proto::v1::market::MarketDepthSubscribe* PROTOBUF_NONNULL _internal_mutable_market_depth_subscribe();

  public:
  // .t4proto.v1.market.MarketByOrderSubscribe market_by_order_subscribe = 101;
  bool has_market_by_order_subscribe() const;
  private:
  bool _internal_has_market_by_order_subscribe() const;

  public:
  void clear_market_by_order_subscribe() ;
  const ::t4proto::v1::market::MarketByOrderSubscribe& market_by_order_subscribe() const;
  [[nodiscard]] ::t4proto::v1::market::MarketByOrderSubscribe* PROTOBUF_NULLABLE release_market_by_order_subscribe();
  ::t4proto::v1::market::MarketByOrderSubscribe* PROTOBUF_NONNULL mutable_market_by_order_subscribe();
  void set_allocated_market_by_order_subscribe(::t4proto::v1::market::MarketByOrderSubscribe* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_market_by_order_subscribe(::t4proto::v1::market::MarketByOrderSubscribe* PROTOBUF_NULLABLE value);
  ::t4proto::v1::market::MarketByOrderSubscribe* PROTOBUF_NULLABLE unsafe_arena_release_market_by_order_subscribe();

  private:
  const ::t4proto::v1::market::MarketByOrderSubscribe& _internal_market_by_order_subscribe() const;
  ::t4proto::v1::market::MarketByOrderSubscribe* PROTOBUF_NONNULL _internal_mutable_market_by_order_subscribe();

  public:
  // .t4proto.v1.account.AccountSubscribe account_subscribe = 200;
  bool has_account_subscribe() const;
  private:
  bool _internal_has_account_subscribe() const;

  public:
  void clear_account_subscribe() ;
  const ::t4proto::v1::account::AccountSubscribe& account_subscribe() const;
  [[nodiscard]] ::t4proto::v1::account::AccountSubscribe* PROTOBUF_NULLABLE release_account_subscribe();
  ::t4proto::v1::account::AccountSubscribe* PROTOBUF_NONNULL mutable_account_subscribe();
  void set_allocated_account_subscribe(::t4proto::v1::account::AccountSubscribe* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_account_subscribe(::t4proto::v1::account::AccountSubscribe* PROTOBUF_NULLABLE value);
  ::t4proto::v1::account::AccountSubscribe* PROTOBUF_NULLABLE unsafe_arena_release_account_subscribe();

  private:
  const ::t4proto::v1::account::AccountSubscribe& _internal_account_subscribe() const;
  ::t4proto::v1::account::AccountSubscribe* PROTOBUF_NONNULL _internal_mutable_account_subscribe();

  public:
  // .t4proto.v1.orderrouting.OrderSubmit order_submit = 300;
  bool has_order_submit() const;
  private:
  bool _internal_has_order_submit() const;

  public:
  void clear_order_submit() ;
  const ::t4proto::v1::orderrouting::OrderSubmit& order_submit() const;
  [[nodiscard]] ::t4proto::v1::orderrouting::OrderSubmit* PROTOBUF_NULLABLE release_order_submit();
  ::t4proto::v1::orderrouting::OrderSubmit* PROTOBUF_NONNULL mutable_order_submit();
  void set_allocated_order_submit(::t4proto::v1::orderrouting::OrderSubmit* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_order_submit(::t4proto::v1::orderrouting::OrderSubmit* PROTOBUF_NULLABLE value);
  ::t4proto::v1::orderrouting::OrderSubmit* PROTOBUF_NULLABLE unsafe_arena_release_order_submit();

  private:
  const ::t4proto::v1::orderrouting::OrderSubmit& _internal_order_submit() const;
  ::t4proto::v1::orderrouting::OrderSubmit* PROTOBUF_NONNULL _internal_mutable_order_submit();

  public:
  // .t4proto.v1.orderrouting.OrderRevise order_revise = 301;
  bool has_order_revise() const;
  private:
  bool _internal_has_order_revise() const;

  public:
  void clear_order_revise() ;
  const ::t4proto::v1::orderrouting::OrderRevise& order_revise() const;
  [[nodiscard]] ::t4proto::v1::orderrouting::OrderRevise* PROTOBUF_NULLABLE release_order_revise();
  ::t4proto::v1::orderrouting::OrderRevise* PROTOBUF_NONNULL mutable_order_revise();
  void set_allocated_order_revise(::t4proto::v1::orderrouting::OrderRevise* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_order_revise(::t4proto::v1::orderrouting::OrderRevise* PROTOBUF_NULLABLE value);
  ::t4proto::v1::orderrouting::OrderRevise* PROTOBUF_NULLABLE unsafe_arena_release_order_revise();

  private:
  const ::t4proto::v1::orderrouting::OrderRevise& _internal_order_revise() const;
  ::t4proto::v1::orderrouting::OrderRevise* PROTOBUF_NONNULL _internal_mutable_order_revise();

  public:
  // .t4proto.v1.orderrouting.OrderPull order_pull = 302;
  bool has_order_pull() const;
  private:
  bool _internal_has_order_pull() const;

  public:
  void clear_order_pull() ;
  const ::t4proto::v1::orderrouting::OrderPull& order_pull() const;
  [[nodiscard]] ::t4proto::v1::orderrouting::OrderPull* PROTOBUF_NULLABLE release_order_pull();
  ::t4proto::v1::orderrouting::OrderPull* PROTOBUF_NONNULL mutable_order_pull();
  void set_allocated_order_pull(::t4proto::v1::orderrouting::OrderPull* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_order_pull(::t4proto::v1::orderrouting::OrderPull* PROTOBUF_NULLABLE value);
  ::t4proto::v1::orderrouting::OrderPull* PROTOBUF_NULLABLE unsafe_arena_release_order_pull();

  private:
  const ::t4proto::v1::orderrouting::OrderPull& _internal_order_pull() const;
  ::t4proto::v1::orderrouting::OrderPull* PROTOBUF_NONNULL _internal_mutable_order_pull();

  public:
  // .t4proto.v1.orderrouting.CreateUDS create_uds = 340;
  bool has_create_uds() const;
  private:
  bool _internal_has_create_uds() const;

  public:
  void clear_create_uds() ;
  const ::t4proto::v1::orderrouting::CreateUDS& create_uds() const;
  [[nodiscard]] ::t4proto::v1::orderrouting::CreateUDS* PROTOBUF_NULLABLE release_create_uds();
  ::t4proto::v1::orderrouting::CreateUDS* PROTOBUF_NONNULL mutable_create_uds();
  void set_allocated_create_uds(::t4proto::v1::orderrouting::CreateUDS* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_create_uds(::t4proto::v1::orderrouting::CreateUDS* PROTOBUF_NULLABLE value);
  ::t4proto::v1::orderrouting::CreateUDS* PROTOBUF_NULLABLE unsafe_arena_release_create_uds();

  private:
  const ::t4proto::v1::orderrouting::CreateUDS& _internal_create_uds() const;
  ::t4proto::v1::orderrouting::CreateUDS* PROTOBUF_NONNULL _internal_mutable_create_uds();

  public:
  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:t4proto.v1.service.ClientMessage)
 private:
  class _Internal;
  void set_has_heartbeat();
  void set_has_login_request();
  void set_has_authentication_token_request();
  void set_has_market_depth_subscribe();
  void set_has_market_by_order_subscribe();
  void set_has_account_subscribe();
  void set_has_order_submit();
  void set_has_order_revise();
  void set_has_order_pull();
  void set_has_create_uds();
  inline bool has_payload() const;
  inline void clear_has_payload();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 10,
                                   10, 0,
                                   21>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ClientMessage& from_msg);
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE heartbeat_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE login_request_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE authentication_token_request_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE market_depth_subscribe_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE market_by_order_subscribe_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE account_subscribe_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE order_submit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE order_revise_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE order_pull_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE create_uds_;
    } payload_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t4_2fv1_2fservice_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ClientMessage_class_data_;
// -------------------------------------------------------------------

class ServerMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:t4proto.v1.service.ServerMessage) */ {
 public:
  inline ServerMessage() : ServerMessage(nullptr) {}
  ~ServerMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ServerMessage* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ServerMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ServerMessage(::google::protobuf::internal::ConstantInitialized);

  inline ServerMessage(const ServerMessage& from) : ServerMessage(nullptr, from) {}
  inline ServerMessage(ServerMessage&& from) noexcept
      : ServerMessage(nullptr, ::std::move(from)) {}
  inline ServerMessage& operator=(const ServerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerMessage& operator=(ServerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerMessage& default_instance() {
    return *reinterpret_cast<const ServerMessage*>(
        &_ServerMessage_default_instance_);
  }
  enum PayloadCase {
    kHeartbeat = 1,
    kLoginResponse = 2,
    kAuthenticationToken = 3,
    kMarketDepthSubscribeReject = 100,
    kMarketByOrderSubscribeReject = 101,
    kMarketDetails = 102,
    kMarketDepth = 103,
    kMarketDepthTrade = 104,
    kMarketHighLow = 105,
    kMarketPriceLimits = 106,
    kMarketSettlement = 107,
    kMarketSnapshot = 108,
    kMarketByOrderSnapshot = 109,
    kMarketByOrderUpdate = 110,
    kAccountSubscribeResponse = 200,
    kAccountCurrency = 201,
    kAccountPosition = 202,
    kAccountUpdate = 203,
    kAccountDetails = 204,
    kAccountSnapshot = 205,
    kOrderUpdate = 300,
    kOrderUpdateMulti = 301,
    kOrderUpdateFailed = 302,
    kOrderUpdateStatus = 303,
    kOrderUpdateTrade = 304,
    kOrderUpdateTradeLeg = 305,
    kCreateUdsResponse = 340,
    PAYLOAD_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(ServerMessage& a, ServerMessage& b) { a.Swap(&b); }
  inline void Swap(ServerMessage* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerMessage* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerMessage* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ServerMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ServerMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ServerMessage& from) { ServerMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ServerMessage* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "t4proto.v1.service.ServerMessage"; }

 protected:
  explicit ServerMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ServerMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ServerMessage& from);
  ServerMessage(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ServerMessage&& from) noexcept
      : ServerMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHeartbeatFieldNumber = 1,
    kLoginResponseFieldNumber = 2,
    kAuthenticationTokenFieldNumber = 3,
    kMarketDepthSubscribeRejectFieldNumber = 100,
    kMarketByOrderSubscribeRejectFieldNumber = 101,
    kMarketDetailsFieldNumber = 102,
    kMarketDepthFieldNumber = 103,
    kMarketDepthTradeFieldNumber = 104,
    kMarketHighLowFieldNumber = 105,
    kMarketPriceLimitsFieldNumber = 106,
    kMarketSettlementFieldNumber = 107,
    kMarketSnapshotFieldNumber = 108,
    kMarketByOrderSnapshotFieldNumber = 109,
    kMarketByOrderUpdateFieldNumber = 110,
    kAccountSubscribeResponseFieldNumber = 200,
    kAccountCurrencyFieldNumber = 201,
    kAccountPositionFieldNumber = 202,
    kAccountUpdateFieldNumber = 203,
    kAccountDetailsFieldNumber = 204,
    kAccountSnapshotFieldNumber = 205,
    kOrderUpdateFieldNumber = 300,
    kOrderUpdateMultiFieldNumber = 301,
    kOrderUpdateFailedFieldNumber = 302,
    kOrderUpdateStatusFieldNumber = 303,
    kOrderUpdateTradeFieldNumber = 304,
    kOrderUpdateTradeLegFieldNumber = 305,
    kCreateUdsResponseFieldNumber = 340,
  };
  // .t4proto.v1.service.Heartbeat heartbeat = 1;
  bool has_heartbeat() const;
  private:
  bool _internal_has_heartbeat() const;

  public:
  void clear_heartbeat() ;
  const ::t4proto::v1::service::Heartbeat& heartbeat() const;
  [[nodiscard]] ::t4proto::v1::service::Heartbeat* PROTOBUF_NULLABLE release_heartbeat();
  ::t4proto::v1::service::Heartbeat* PROTOBUF_NONNULL mutable_heartbeat();
  void set_allocated_heartbeat(::t4proto::v1::service::Heartbeat* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_heartbeat(::t4proto::v1::service::Heartbeat* PROTOBUF_NULLABLE value);
  ::t4proto::v1::service::Heartbeat* PROTOBUF_NULLABLE unsafe_arena_release_heartbeat();

  private:
  const ::t4proto::v1::service::Heartbeat& _internal_heartbeat() const;
  ::t4proto::v1::service::Heartbeat* PROTOBUF_NONNULL _internal_mutable_heartbeat();

  public:
  // .t4proto.v1.auth.LoginResponse login_response = 2;
  bool has_login_response() const;
  private:
  bool _internal_has_login_response() const;

  public:
  void clear_login_response() ;
  const ::t4proto::v1::auth::LoginResponse& login_response() const;
  [[nodiscard]] ::t4proto::v1::auth::LoginResponse* PROTOBUF_NULLABLE release_login_response();
  ::t4proto::v1::auth::LoginResponse* PROTOBUF_NONNULL mutable_login_response();
  void set_allocated_login_response(::t4proto::v1::auth::LoginResponse* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_login_response(::t4proto::v1::auth::LoginResponse* PROTOBUF_NULLABLE value);
  ::t4proto::v1::auth::LoginResponse* PROTOBUF_NULLABLE unsafe_arena_release_login_response();

  private:
  const ::t4proto::v1::auth::LoginResponse& _internal_login_response() const;
  ::t4proto::v1::auth::LoginResponse* PROTOBUF_NONNULL _internal_mutable_login_response();

  public:
  // .t4proto.v1.auth.AuthenticationToken authentication_token = 3;
  bool has_authentication_token() const;
  private:
  bool _internal_has_authentication_token() const;

  public:
  void clear_authentication_token() ;
  const ::t4proto::v1::auth::AuthenticationToken& authentication_token() const;
  [[nodiscard]] ::t4proto::v1::auth::AuthenticationToken* PROTOBUF_NULLABLE release_authentication_token();
  ::t4proto::v1::auth::AuthenticationToken* PROTOBUF_NONNULL mutable_authentication_token();
  void set_allocated_authentication_token(::t4proto::v1::auth::AuthenticationToken* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_authentication_token(::t4proto::v1::auth::AuthenticationToken* PROTOBUF_NULLABLE value);
  ::t4proto::v1::auth::AuthenticationToken* PROTOBUF_NULLABLE unsafe_arena_release_authentication_token();

  private:
  const ::t4proto::v1::auth::AuthenticationToken& _internal_authentication_token() const;
  ::t4proto::v1::auth::AuthenticationToken* PROTOBUF_NONNULL _internal_mutable_authentication_token();

  public:
  // .t4proto.v1.market.MarketDepthSubscribeReject market_depth_subscribe_reject = 100;
  bool has_market_depth_subscribe_reject() const;
  private:
  bool _internal_has_market_depth_subscribe_reject() const;

  public:
  void clear_market_depth_subscribe_reject() ;
  const ::t4proto::v1::market::MarketDepthSubscribeReject& market_depth_subscribe_reject() const;
  [[nodiscard]] ::t4proto::v1::market::MarketDepthSubscribeReject* PROTOBUF_NULLABLE release_market_depth_subscribe_reject();
  ::t4proto::v1::market::MarketDepthSubscribeReject* PROTOBUF_NONNULL mutable_market_depth_subscribe_reject();
  void set_allocated_market_depth_subscribe_reject(::t4proto::v1::market::MarketDepthSubscribeReject* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_market_depth_subscribe_reject(::t4proto::v1::market::MarketDepthSubscribeReject* PROTOBUF_NULLABLE value);
  ::t4proto::v1::market::MarketDepthSubscribeReject* PROTOBUF_NULLABLE unsafe_arena_release_market_depth_subscribe_reject();

  private:
  const ::t4proto::v1::market::MarketDepthSubscribeReject& _internal_market_depth_subscribe_reject() const;
  ::t4proto::v1::market::MarketDepthSubscribeReject* PROTOBUF_NONNULL _internal_mutable_market_depth_subscribe_reject();

  public:
  // .t4proto.v1.market.MarketByOrderSubscribeReject market_by_order_subscribe_reject = 101;
  bool has_market_by_order_subscribe_reject() const;
  private:
  bool _internal_has_market_by_order_subscribe_reject() const;

  public:
  void clear_market_by_order_subscribe_reject() ;
  const ::t4proto::v1::market::MarketByOrderSubscribeReject& market_by_order_subscribe_reject() const;
  [[nodiscard]] ::t4proto::v1::market::MarketByOrderSubscribeReject* PROTOBUF_NULLABLE release_market_by_order_subscribe_reject();
  ::t4proto::v1::market::MarketByOrderSubscribeReject* PROTOBUF_NONNULL mutable_market_by_order_subscribe_reject();
  void set_allocated_market_by_order_subscribe_reject(::t4proto::v1::market::MarketByOrderSubscribeReject* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_market_by_order_subscribe_reject(::t4proto::v1::market::MarketByOrderSubscribeReject* PROTOBUF_NULLABLE value);
  ::t4proto::v1::market::MarketByOrderSubscribeReject* PROTOBUF_NULLABLE unsafe_arena_release_market_by_order_subscribe_reject();

  private:
  const ::t4proto::v1::market::MarketByOrderSubscribeReject& _internal_market_by_order_subscribe_reject() const;
  ::t4proto::v1::market::MarketByOrderSubscribeReject* PROTOBUF_NONNULL _internal_mutable_market_by_order_subscribe_reject();

  public:
  // .t4proto.v1.market.MarketDetails market_details = 102;
  bool has_market_details() const;
  private:
  bool _internal_has_market_details() const;

  public:
  void clear_market_details() ;
  const ::t4proto::v1::market::MarketDetails& market_details() const;
  [[nodiscard]] ::t4proto::v1::market::MarketDetails* PROTOBUF_NULLABLE release_market_details();
  ::t4proto::v1::market::MarketDetails* PROTOBUF_NONNULL mutable_market_details();
  void set_allocated_market_details(::t4proto::v1::market::MarketDetails* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_market_details(::t4proto::v1::market::MarketDetails* PROTOBUF_NULLABLE value);
  ::t4proto::v1::market::MarketDetails* PROTOBUF_NULLABLE unsafe_arena_release_market_details();

  private:
  const ::t4proto::v1::market::MarketDetails& _internal_market_details() const;
  ::t4proto::v1::market::MarketDetails* PROTOBUF_NONNULL _internal_mutable_market_details();

  public:
  // .t4proto.v1.market.MarketDepth market_depth = 103;
  bool has_market_depth() const;
  private:
  bool _internal_has_market_depth() const;

  public:
  void clear_market_depth() ;
  const ::t4proto::v1::market::MarketDepth& market_depth() const;
  [[nodiscard]] ::t4proto::v1::market::MarketDepth* PROTOBUF_NULLABLE release_market_depth();
  ::t4proto::v1::market::MarketDepth* PROTOBUF_NONNULL mutable_market_depth();
  void set_allocated_market_depth(::t4proto::v1::market::MarketDepth* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_market_depth(::t4proto::v1::market::MarketDepth* PROTOBUF_NULLABLE value);
  ::t4proto::v1::market::MarketDepth* PROTOBUF_NULLABLE unsafe_arena_release_market_depth();

  private:
  const ::t4proto::v1::market::MarketDepth& _internal_market_depth() const;
  ::t4proto::v1::market::MarketDepth* PROTOBUF_NONNULL _internal_mutable_market_depth();

  public:
  // .t4proto.v1.market.MarketDepthTrade market_depth_trade = 104;
  bool has_market_depth_trade() const;
  private:
  bool _internal_has_market_depth_trade() const;

  public:
  void clear_market_depth_trade() ;
  const ::t4proto::v1::market::MarketDepthTrade& market_depth_trade() const;
  [[nodiscard]] ::t4proto::v1::market::MarketDepthTrade* PROTOBUF_NULLABLE release_market_depth_trade();
  ::t4proto::v1::market::MarketDepthTrade* PROTOBUF_NONNULL mutable_market_depth_trade();
  void set_allocated_market_depth_trade(::t4proto::v1::market::MarketDepthTrade* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_market_depth_trade(::t4proto::v1::market::MarketDepthTrade* PROTOBUF_NULLABLE value);
  ::t4proto::v1::market::MarketDepthTrade* PROTOBUF_NULLABLE unsafe_arena_release_market_depth_trade();

  private:
  const ::t4proto::v1::market::MarketDepthTrade& _internal_market_depth_trade() const;
  ::t4proto::v1::market::MarketDepthTrade* PROTOBUF_NONNULL _internal_mutable_market_depth_trade();

  public:
  // .t4proto.v1.market.MarketHighLow market_high_low = 105;
  bool has_market_high_low() const;
  private:
  bool _internal_has_market_high_low() const;

  public:
  void clear_market_high_low() ;
  const ::t4proto::v1::market::MarketHighLow& market_high_low() const;
  [[nodiscard]] ::t4proto::v1::market::MarketHighLow* PROTOBUF_NULLABLE release_market_high_low();
  ::t4proto::v1::market::MarketHighLow* PROTOBUF_NONNULL mutable_market_high_low();
  void set_allocated_market_high_low(::t4proto::v1::market::MarketHighLow* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_market_high_low(::t4proto::v1::market::MarketHighLow* PROTOBUF_NULLABLE value);
  ::t4proto::v1::market::MarketHighLow* PROTOBUF_NULLABLE unsafe_arena_release_market_high_low();

  private:
  const ::t4proto::v1::market::MarketHighLow& _internal_market_high_low() const;
  ::t4proto::v1::market::MarketHighLow* PROTOBUF_NONNULL _internal_mutable_market_high_low();

  public:
  // .t4proto.v1.market.MarketPriceLimits market_price_limits = 106;
  bool has_market_price_limits() const;
  private:
  bool _internal_has_market_price_limits() const;

  public:
  void clear_market_price_limits() ;
  const ::t4proto::v1::market::MarketPriceLimits& market_price_limits() const;
  [[nodiscard]] ::t4proto::v1::market::MarketPriceLimits* PROTOBUF_NULLABLE release_market_price_limits();
  ::t4proto::v1::market::MarketPriceLimits* PROTOBUF_NONNULL mutable_market_price_limits();
  void set_allocated_market_price_limits(::t4proto::v1::market::MarketPriceLimits* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_market_price_limits(::t4proto::v1::market::MarketPriceLimits* PROTOBUF_NULLABLE value);
  ::t4proto::v1::market::MarketPriceLimits* PROTOBUF_NULLABLE unsafe_arena_release_market_price_limits();

  private:
  const ::t4proto::v1::market::MarketPriceLimits& _internal_market_price_limits() const;
  ::t4proto::v1::market::MarketPriceLimits* PROTOBUF_NONNULL _internal_mutable_market_price_limits();

  public:
  // .t4proto.v1.market.MarketSettlement market_settlement = 107;
  bool has_market_settlement() const;
  private:
  bool _internal_has_market_settlement() const;

  public:
  void clear_market_settlement() ;
  const ::t4proto::v1::market::MarketSettlement& market_settlement() const;
  [[nodiscard]] ::t4proto::v1::market::MarketSettlement* PROTOBUF_NULLABLE release_market_settlement();
  ::t4proto::v1::market::MarketSettlement* PROTOBUF_NONNULL mutable_market_settlement();
  void set_allocated_market_settlement(::t4proto::v1::market::MarketSettlement* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_market_settlement(::t4proto::v1::market::MarketSettlement* PROTOBUF_NULLABLE value);
  ::t4proto::v1::market::MarketSettlement* PROTOBUF_NULLABLE unsafe_arena_release_market_settlement();

  private:
  const ::t4proto::v1::market::MarketSettlement& _internal_market_settlement() const;
  ::t4proto::v1::market::MarketSettlement* PROTOBUF_NONNULL _internal_mutable_market_settlement();

  public:
  // .t4proto.v1.market.MarketSnapshot market_snapshot = 108;
  bool has_market_snapshot() const;
  private:
  bool _internal_has_market_snapshot() const;

  public:
  void clear_market_snapshot() ;
  const ::t4proto::v1::market::MarketSnapshot& market_snapshot() const;
  [[nodiscard]] ::t4proto::v1::market::MarketSnapshot* PROTOBUF_NULLABLE release_market_snapshot();
  ::t4proto::v1::market::MarketSnapshot* PROTOBUF_NONNULL mutable_market_snapshot();
  void set_allocated_market_snapshot(::t4proto::v1::market::MarketSnapshot* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_market_snapshot(::t4proto::v1::market::MarketSnapshot* PROTOBUF_NULLABLE value);
  ::t4proto::v1::market::MarketSnapshot* PROTOBUF_NULLABLE unsafe_arena_release_market_snapshot();

  private:
  const ::t4proto::v1::market::MarketSnapshot& _internal_market_snapshot() const;
  ::t4proto::v1::market::MarketSnapshot* PROTOBUF_NONNULL _internal_mutable_market_snapshot();

  public:
  // .t4proto.v1.market.MarketByOrderSnapshot market_by_order_snapshot = 109;
  bool has_market_by_order_snapshot() const;
  private:
  bool _internal_has_market_by_order_snapshot() const;

  public:
  void clear_market_by_order_snapshot() ;
  const ::t4proto::v1::market::MarketByOrderSnapshot& market_by_order_snapshot() const;
  [[nodiscard]] ::t4proto::v1::market::MarketByOrderSnapshot* PROTOBUF_NULLABLE release_market_by_order_snapshot();
  ::t4proto::v1::market::MarketByOrderSnapshot* PROTOBUF_NONNULL mutable_market_by_order_snapshot();
  void set_allocated_market_by_order_snapshot(::t4proto::v1::market::MarketByOrderSnapshot* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_market_by_order_snapshot(::t4proto::v1::market::MarketByOrderSnapshot* PROTOBUF_NULLABLE value);
  ::t4proto::v1::market::MarketByOrderSnapshot* PROTOBUF_NULLABLE unsafe_arena_release_market_by_order_snapshot();

  private:
  const ::t4proto::v1::market::MarketByOrderSnapshot& _internal_market_by_order_snapshot() const;
  ::t4proto::v1::market::MarketByOrderSnapshot* PROTOBUF_NONNULL _internal_mutable_market_by_order_snapshot();

  public:
  // .t4proto.v1.market.MarketByOrderUpdate market_by_order_update = 110;
  bool has_market_by_order_update() const;
  private:
  bool _internal_has_market_by_order_update() const;

  public:
  void clear_market_by_order_update() ;
  const ::t4proto::v1::market::MarketByOrderUpdate& market_by_order_update() const;
  [[nodiscard]] ::t4proto::v1::market::MarketByOrderUpdate* PROTOBUF_NULLABLE release_market_by_order_update();
  ::t4proto::v1::market::MarketByOrderUpdate* PROTOBUF_NONNULL mutable_market_by_order_update();
  void set_allocated_market_by_order_update(::t4proto::v1::market::MarketByOrderUpdate* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_market_by_order_update(::t4proto::v1::market::MarketByOrderUpdate* PROTOBUF_NULLABLE value);
  ::t4proto::v1::market::MarketByOrderUpdate* PROTOBUF_NULLABLE unsafe_arena_release_market_by_order_update();

  private:
  const ::t4proto::v1::market::MarketByOrderUpdate& _internal_market_by_order_update() const;
  ::t4proto::v1::market::MarketByOrderUpdate* PROTOBUF_NONNULL _internal_mutable_market_by_order_update();

  public:
  // .t4proto.v1.account.AccountSubscribeResponse account_subscribe_response = 200;
  bool has_account_subscribe_response() const;
  private:
  bool _internal_has_account_subscribe_response() const;

  public:
  void clear_account_subscribe_response() ;
  const ::t4proto::v1::account::AccountSubscribeResponse& account_subscribe_response() const;
  [[nodiscard]] ::t4proto::v1::account::AccountSubscribeResponse* PROTOBUF_NULLABLE release_account_subscribe_response();
  ::t4proto::v1::account::AccountSubscribeResponse* PROTOBUF_NONNULL mutable_account_subscribe_response();
  void set_allocated_account_subscribe_response(::t4proto::v1::account::AccountSubscribeResponse* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_account_subscribe_response(::t4proto::v1::account::AccountSubscribeResponse* PROTOBUF_NULLABLE value);
  ::t4proto::v1::account::AccountSubscribeResponse* PROTOBUF_NULLABLE unsafe_arena_release_account_subscribe_response();

  private:
  const ::t4proto::v1::account::AccountSubscribeResponse& _internal_account_subscribe_response() const;
  ::t4proto::v1::account::AccountSubscribeResponse* PROTOBUF_NONNULL _internal_mutable_account_subscribe_response();

  public:
  // .t4proto.v1.account.AccountCurrency account_currency = 201;
  bool has_account_currency() const;
  private:
  bool _internal_has_account_currency() const;

  public:
  void clear_account_currency() ;
  const ::t4proto::v1::account::AccountCurrency& account_currency() const;
  [[nodiscard]] ::t4proto::v1::account::AccountCurrency* PROTOBUF_NULLABLE release_account_currency();
  ::t4proto::v1::account::AccountCurrency* PROTOBUF_NONNULL mutable_account_currency();
  void set_allocated_account_currency(::t4proto::v1::account::AccountCurrency* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_account_currency(::t4proto::v1::account::AccountCurrency* PROTOBUF_NULLABLE value);
  ::t4proto::v1::account::AccountCurrency* PROTOBUF_NULLABLE unsafe_arena_release_account_currency();

  private:
  const ::t4proto::v1::account::AccountCurrency& _internal_account_currency() const;
  ::t4proto::v1::account::AccountCurrency* PROTOBUF_NONNULL _internal_mutable_account_currency();

  public:
  // .t4proto.v1.account.AccountPosition account_position = 202;
  bool has_account_position() const;
  private:
  bool _internal_has_account_position() const;

  public:
  void clear_account_position() ;
  const ::t4proto::v1::account::AccountPosition& account_position() const;
  [[nodiscard]] ::t4proto::v1::account::AccountPosition* PROTOBUF_NULLABLE release_account_position();
  ::t4proto::v1::account::AccountPosition* PROTOBUF_NONNULL mutable_account_position();
  void set_allocated_account_position(::t4proto::v1::account::AccountPosition* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_account_position(::t4proto::v1::account::AccountPosition* PROTOBUF_NULLABLE value);
  ::t4proto::v1::account::AccountPosition* PROTOBUF_NULLABLE unsafe_arena_release_account_position();

  private:
  const ::t4proto::v1::account::AccountPosition& _internal_account_position() const;
  ::t4proto::v1::account::AccountPosition* PROTOBUF_NONNULL _internal_mutable_account_position();

  public:
  // .t4proto.v1.account.AccountUpdate account_update = 203;
  bool has_account_update() const;
  private:
  bool _internal_has_account_update() const;

  public:
  void clear_account_update() ;
  const ::t4proto::v1::account::AccountUpdate& account_update() const;
  [[nodiscard]] ::t4proto::v1::account::AccountUpdate* PROTOBUF_NULLABLE release_account_update();
  ::t4proto::v1::account::AccountUpdate* PROTOBUF_NONNULL mutable_account_update();
  void set_allocated_account_update(::t4proto::v1::account::AccountUpdate* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_account_update(::t4proto::v1::account::AccountUpdate* PROTOBUF_NULLABLE value);
  ::t4proto::v1::account::AccountUpdate* PROTOBUF_NULLABLE unsafe_arena_release_account_update();

  private:
  const ::t4proto::v1::account::AccountUpdate& _internal_account_update() const;
  ::t4proto::v1::account::AccountUpdate* PROTOBUF_NONNULL _internal_mutable_account_update();

  public:
  // .t4proto.v1.account.AccountDetails account_details = 204;
  bool has_account_details() const;
  private:
  bool _internal_has_account_details() const;

  public:
  void clear_account_details() ;
  const ::t4proto::v1::account::AccountDetails& account_details() const;
  [[nodiscard]] ::t4proto::v1::account::AccountDetails* PROTOBUF_NULLABLE release_account_details();
  ::t4proto::v1::account::AccountDetails* PROTOBUF_NONNULL mutable_account_details();
  void set_allocated_account_details(::t4proto::v1::account::AccountDetails* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_account_details(::t4proto::v1::account::AccountDetails* PROTOBUF_NULLABLE value);
  ::t4proto::v1::account::AccountDetails* PROTOBUF_NULLABLE unsafe_arena_release_account_details();

  private:
  const ::t4proto::v1::account::AccountDetails& _internal_account_details() const;
  ::t4proto::v1::account::AccountDetails* PROTOBUF_NONNULL _internal_mutable_account_details();

  public:
  // .t4proto.v1.account.AccountSnapshot account_snapshot = 205;
  bool has_account_snapshot() const;
  private:
  bool _internal_has_account_snapshot() const;

  public:
  void clear_account_snapshot() ;
  const ::t4proto::v1::account::AccountSnapshot& account_snapshot() const;
  [[nodiscard]] ::t4proto::v1::account::AccountSnapshot* PROTOBUF_NULLABLE release_account_snapshot();
  ::t4proto::v1::account::AccountSnapshot* PROTOBUF_NONNULL mutable_account_snapshot();
  void set_allocated_account_snapshot(::t4proto::v1::account::AccountSnapshot* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_account_snapshot(::t4proto::v1::account::AccountSnapshot* PROTOBUF_NULLABLE value);
  ::t4proto::v1::account::AccountSnapshot* PROTOBUF_NULLABLE unsafe_arena_release_account_snapshot();

  private:
  const ::t4proto::v1::account::AccountSnapshot& _internal_account_snapshot() const;
  ::t4proto::v1::account::AccountSnapshot* PROTOBUF_NONNULL _internal_mutable_account_snapshot();

  public:
  // .t4proto.v1.orderrouting.OrderUpdate order_update = 300;
  bool has_order_update() const;
  private:
  bool _internal_has_order_update() const;

  public:
  void clear_order_update() ;
  const ::t4proto::v1::orderrouting::OrderUpdate& order_update() const;
  [[nodiscard]] ::t4proto::v1::orderrouting::OrderUpdate* PROTOBUF_NULLABLE release_order_update();
  ::t4proto::v1::orderrouting::OrderUpdate* PROTOBUF_NONNULL mutable_order_update();
  void set_allocated_order_update(::t4proto::v1::orderrouting::OrderUpdate* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_order_update(::t4proto::v1::orderrouting::OrderUpdate* PROTOBUF_NULLABLE value);
  ::t4proto::v1::orderrouting::OrderUpdate* PROTOBUF_NULLABLE unsafe_arena_release_order_update();

  private:
  const ::t4proto::v1::orderrouting::OrderUpdate& _internal_order_update() const;
  ::t4proto::v1::orderrouting::OrderUpdate* PROTOBUF_NONNULL _internal_mutable_order_update();

  public:
  // .t4proto.v1.orderrouting.OrderUpdateMulti order_update_multi = 301;
  bool has_order_update_multi() const;
  private:
  bool _internal_has_order_update_multi() const;

  public:
  void clear_order_update_multi() ;
  const ::t4proto::v1::orderrouting::OrderUpdateMulti& order_update_multi() const;
  [[nodiscard]] ::t4proto::v1::orderrouting::OrderUpdateMulti* PROTOBUF_NULLABLE release_order_update_multi();
  ::t4proto::v1::orderrouting::OrderUpdateMulti* PROTOBUF_NONNULL mutable_order_update_multi();
  void set_allocated_order_update_multi(::t4proto::v1::orderrouting::OrderUpdateMulti* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_order_update_multi(::t4proto::v1::orderrouting::OrderUpdateMulti* PROTOBUF_NULLABLE value);
  ::t4proto::v1::orderrouting::OrderUpdateMulti* PROTOBUF_NULLABLE unsafe_arena_release_order_update_multi();

  private:
  const ::t4proto::v1::orderrouting::OrderUpdateMulti& _internal_order_update_multi() const;
  ::t4proto::v1::orderrouting::OrderUpdateMulti* PROTOBUF_NONNULL _internal_mutable_order_update_multi();

  public:
  // .t4proto.v1.orderrouting.OrderUpdateFailed order_update_failed = 302;
  bool has_order_update_failed() const;
  private:
  bool _internal_has_order_update_failed() const;

  public:
  void clear_order_update_failed() ;
  const ::t4proto::v1::orderrouting::OrderUpdateFailed& order_update_failed() const;
  [[nodiscard]] ::t4proto::v1::orderrouting::OrderUpdateFailed* PROTOBUF_NULLABLE release_order_update_failed();
  ::t4proto::v1::orderrouting::OrderUpdateFailed* PROTOBUF_NONNULL mutable_order_update_failed();
  void set_allocated_order_update_failed(::t4proto::v1::orderrouting::OrderUpdateFailed* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_order_update_failed(::t4proto::v1::orderrouting::OrderUpdateFailed* PROTOBUF_NULLABLE value);
  ::t4proto::v1::orderrouting::OrderUpdateFailed* PROTOBUF_NULLABLE unsafe_arena_release_order_update_failed();

  private:
  const ::t4proto::v1::orderrouting::OrderUpdateFailed& _internal_order_update_failed() const;
  ::t4proto::v1::orderrouting::OrderUpdateFailed* PROTOBUF_NONNULL _internal_mutable_order_update_failed();

  public:
  // .t4proto.v1.orderrouting.OrderUpdateStatus order_update_status = 303;
  bool has_order_update_status() const;
  private:
  bool _internal_has_order_update_status() const;

  public:
  void clear_order_update_status() ;
  const ::t4proto::v1::orderrouting::OrderUpdateStatus& order_update_status() const;
  [[nodiscard]] ::t4proto::v1::orderrouting::OrderUpdateStatus* PROTOBUF_NULLABLE release_order_update_status();
  ::t4proto::v1::orderrouting::OrderUpdateStatus* PROTOBUF_NONNULL mutable_order_update_status();
  void set_allocated_order_update_status(::t4proto::v1::orderrouting::OrderUpdateStatus* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_order_update_status(::t4proto::v1::orderrouting::OrderUpdateStatus* PROTOBUF_NULLABLE value);
  ::t4proto::v1::orderrouting::OrderUpdateStatus* PROTOBUF_NULLABLE unsafe_arena_release_order_update_status();

  private:
  const ::t4proto::v1::orderrouting::OrderUpdateStatus& _internal_order_update_status() const;
  ::t4proto::v1::orderrouting::OrderUpdateStatus* PROTOBUF_NONNULL _internal_mutable_order_update_status();

  public:
  // .t4proto.v1.orderrouting.OrderUpdateTrade order_update_trade = 304;
  bool has_order_update_trade() const;
  private:
  bool _internal_has_order_update_trade() const;

  public:
  void clear_order_update_trade() ;
  const ::t4proto::v1::orderrouting::OrderUpdateTrade& order_update_trade() const;
  [[nodiscard]] ::t4proto::v1::orderrouting::OrderUpdateTrade* PROTOBUF_NULLABLE release_order_update_trade();
  ::t4proto::v1::orderrouting::OrderUpdateTrade* PROTOBUF_NONNULL mutable_order_update_trade();
  void set_allocated_order_update_trade(::t4proto::v1::orderrouting::OrderUpdateTrade* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_order_update_trade(::t4proto::v1::orderrouting::OrderUpdateTrade* PROTOBUF_NULLABLE value);
  ::t4proto::v1::orderrouting::OrderUpdateTrade* PROTOBUF_NULLABLE unsafe_arena_release_order_update_trade();

  private:
  const ::t4proto::v1::orderrouting::OrderUpdateTrade& _internal_order_update_trade() const;
  ::t4proto::v1::orderrouting::OrderUpdateTrade* PROTOBUF_NONNULL _internal_mutable_order_update_trade();

  public:
  // .t4proto.v1.orderrouting.OrderUpdateTradeLeg order_update_trade_leg = 305;
  bool has_order_update_trade_leg() const;
  private:
  bool _internal_has_order_update_trade_leg() const;

  public:
  void clear_order_update_trade_leg() ;
  const ::t4proto::v1::orderrouting::OrderUpdateTradeLeg& order_update_trade_leg() const;
  [[nodiscard]] ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* PROTOBUF_NULLABLE release_order_update_trade_leg();
  ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* PROTOBUF_NONNULL mutable_order_update_trade_leg();
  void set_allocated_order_update_trade_leg(::t4proto::v1::orderrouting::OrderUpdateTradeLeg* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_order_update_trade_leg(::t4proto::v1::orderrouting::OrderUpdateTradeLeg* PROTOBUF_NULLABLE value);
  ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* PROTOBUF_NULLABLE unsafe_arena_release_order_update_trade_leg();

  private:
  const ::t4proto::v1::orderrouting::OrderUpdateTradeLeg& _internal_order_update_trade_leg() const;
  ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* PROTOBUF_NONNULL _internal_mutable_order_update_trade_leg();

  public:
  // .t4proto.v1.orderrouting.CreateUDSResponse create_uds_response = 340;
  bool has_create_uds_response() const;
  private:
  bool _internal_has_create_uds_response() const;

  public:
  void clear_create_uds_response() ;
  const ::t4proto::v1::orderrouting::CreateUDSResponse& create_uds_response() const;
  [[nodiscard]] ::t4proto::v1::orderrouting::CreateUDSResponse* PROTOBUF_NULLABLE release_create_uds_response();
  ::t4proto::v1::orderrouting::CreateUDSResponse* PROTOBUF_NONNULL mutable_create_uds_response();
  void set_allocated_create_uds_response(::t4proto::v1::orderrouting::CreateUDSResponse* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_create_uds_response(::t4proto::v1::orderrouting::CreateUDSResponse* PROTOBUF_NULLABLE value);
  ::t4proto::v1::orderrouting::CreateUDSResponse* PROTOBUF_NULLABLE unsafe_arena_release_create_uds_response();

  private:
  const ::t4proto::v1::orderrouting::CreateUDSResponse& _internal_create_uds_response() const;
  ::t4proto::v1::orderrouting::CreateUDSResponse* PROTOBUF_NONNULL _internal_mutable_create_uds_response();

  public:
  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:t4proto.v1.service.ServerMessage)
 private:
  class _Internal;
  void set_has_heartbeat();
  void set_has_login_response();
  void set_has_authentication_token();
  void set_has_market_depth_subscribe_reject();
  void set_has_market_by_order_subscribe_reject();
  void set_has_market_details();
  void set_has_market_depth();
  void set_has_market_depth_trade();
  void set_has_market_high_low();
  void set_has_market_price_limits();
  void set_has_market_settlement();
  void set_has_market_snapshot();
  void set_has_market_by_order_snapshot();
  void set_has_market_by_order_update();
  void set_has_account_subscribe_response();
  void set_has_account_currency();
  void set_has_account_position();
  void set_has_account_update();
  void set_has_account_details();
  void set_has_account_snapshot();
  void set_has_order_update();
  void set_has_order_update_multi();
  void set_has_order_update_failed();
  void set_has_order_update_status();
  void set_has_order_update_trade();
  void set_has_order_update_trade_leg();
  void set_has_create_uds_response();
  inline bool has_payload() const;
  inline void clear_has_payload();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 27,
                                   27, 0,
                                   21>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ServerMessage& from_msg);
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE heartbeat_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE login_response_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE authentication_token_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE market_depth_subscribe_reject_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE market_by_order_subscribe_reject_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE market_details_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE market_depth_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE market_depth_trade_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE market_high_low_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE market_price_limits_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE market_settlement_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE market_snapshot_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE market_by_order_snapshot_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE market_by_order_update_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE account_subscribe_response_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE account_currency_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE account_position_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE account_update_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE account_details_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE account_snapshot_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE order_update_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE order_update_multi_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE order_update_failed_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE order_update_status_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE order_update_trade_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE order_update_trade_leg_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE create_uds_response_;
    } payload_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t4_2fv1_2fservice_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ServerMessage_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ClientMessage

// .t4proto.v1.service.Heartbeat heartbeat = 1;
inline bool ClientMessage::has_heartbeat() const {
  return payload_case() == kHeartbeat;
}
inline bool ClientMessage::_internal_has_heartbeat() const {
  return payload_case() == kHeartbeat;
}
inline void ClientMessage::set_has_heartbeat() {
  _impl_._oneof_case_[0] = kHeartbeat;
}
inline void ClientMessage::clear_heartbeat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kHeartbeat) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.heartbeat_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.heartbeat_);
    }
    clear_has_payload();
  }
}
inline ::t4proto::v1::service::Heartbeat* PROTOBUF_NULLABLE ClientMessage::release_heartbeat() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ClientMessage.heartbeat)
  if (payload_case() == kHeartbeat) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::service::Heartbeat*>(_impl_.payload_.heartbeat_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::service::Heartbeat& ClientMessage::_internal_heartbeat() const {
  return payload_case() == kHeartbeat ? *reinterpret_cast<::t4proto::v1::service::Heartbeat*>(_impl_.payload_.heartbeat_) : reinterpret_cast<::t4proto::v1::service::Heartbeat&>(::t4proto::v1::service::_Heartbeat_default_instance_);
}
inline const ::t4proto::v1::service::Heartbeat& ClientMessage::heartbeat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ClientMessage.heartbeat)
  return _internal_heartbeat();
}
inline ::t4proto::v1::service::Heartbeat* PROTOBUF_NULLABLE ClientMessage::unsafe_arena_release_heartbeat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ClientMessage.heartbeat)
  if (payload_case() == kHeartbeat) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::service::Heartbeat*>(_impl_.payload_.heartbeat_);
    _impl_.payload_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_heartbeat(
    ::t4proto::v1::service::Heartbeat* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_heartbeat();
    _impl_.payload_.heartbeat_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ClientMessage.heartbeat)
}
inline ::t4proto::v1::service::Heartbeat* PROTOBUF_NONNULL ClientMessage::_internal_mutable_heartbeat() {
  if (payload_case() != kHeartbeat) {
    clear_payload();
    set_has_heartbeat();
    _impl_.payload_.heartbeat_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::service::Heartbeat>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::service::Heartbeat*>(_impl_.payload_.heartbeat_);
}
inline ::t4proto::v1::service::Heartbeat* PROTOBUF_NONNULL ClientMessage::mutable_heartbeat()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::service::Heartbeat* _msg = _internal_mutable_heartbeat();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ClientMessage.heartbeat)
  return _msg;
}

// .t4proto.v1.auth.LoginRequest login_request = 2;
inline bool ClientMessage::has_login_request() const {
  return payload_case() == kLoginRequest;
}
inline bool ClientMessage::_internal_has_login_request() const {
  return payload_case() == kLoginRequest;
}
inline void ClientMessage::set_has_login_request() {
  _impl_._oneof_case_[0] = kLoginRequest;
}
inline ::t4proto::v1::auth::LoginRequest* PROTOBUF_NULLABLE ClientMessage::release_login_request() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ClientMessage.login_request)
  if (payload_case() == kLoginRequest) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::auth::LoginRequest*>(_impl_.payload_.login_request_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.login_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::auth::LoginRequest& ClientMessage::_internal_login_request() const {
  return payload_case() == kLoginRequest ? *reinterpret_cast<::t4proto::v1::auth::LoginRequest*>(_impl_.payload_.login_request_) : reinterpret_cast<::t4proto::v1::auth::LoginRequest&>(::t4proto::v1::auth::_LoginRequest_default_instance_);
}
inline const ::t4proto::v1::auth::LoginRequest& ClientMessage::login_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ClientMessage.login_request)
  return _internal_login_request();
}
inline ::t4proto::v1::auth::LoginRequest* PROTOBUF_NULLABLE ClientMessage::unsafe_arena_release_login_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ClientMessage.login_request)
  if (payload_case() == kLoginRequest) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::auth::LoginRequest*>(_impl_.payload_.login_request_);
    _impl_.payload_.login_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_login_request(
    ::t4proto::v1::auth::LoginRequest* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_login_request();
    _impl_.payload_.login_request_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ClientMessage.login_request)
}
inline ::t4proto::v1::auth::LoginRequest* PROTOBUF_NONNULL ClientMessage::_internal_mutable_login_request() {
  if (payload_case() != kLoginRequest) {
    clear_payload();
    set_has_login_request();
    _impl_.payload_.login_request_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::auth::LoginRequest>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::auth::LoginRequest*>(_impl_.payload_.login_request_);
}
inline ::t4proto::v1::auth::LoginRequest* PROTOBUF_NONNULL ClientMessage::mutable_login_request()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::auth::LoginRequest* _msg = _internal_mutable_login_request();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ClientMessage.login_request)
  return _msg;
}

// .t4proto.v1.auth.AuthenticationTokenRequest authentication_token_request = 3;
inline bool ClientMessage::has_authentication_token_request() const {
  return payload_case() == kAuthenticationTokenRequest;
}
inline bool ClientMessage::_internal_has_authentication_token_request() const {
  return payload_case() == kAuthenticationTokenRequest;
}
inline void ClientMessage::set_has_authentication_token_request() {
  _impl_._oneof_case_[0] = kAuthenticationTokenRequest;
}
inline ::t4proto::v1::auth::AuthenticationTokenRequest* PROTOBUF_NULLABLE ClientMessage::release_authentication_token_request() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ClientMessage.authentication_token_request)
  if (payload_case() == kAuthenticationTokenRequest) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::auth::AuthenticationTokenRequest*>(_impl_.payload_.authentication_token_request_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.authentication_token_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::auth::AuthenticationTokenRequest& ClientMessage::_internal_authentication_token_request() const {
  return payload_case() == kAuthenticationTokenRequest ? *reinterpret_cast<::t4proto::v1::auth::AuthenticationTokenRequest*>(_impl_.payload_.authentication_token_request_) : reinterpret_cast<::t4proto::v1::auth::AuthenticationTokenRequest&>(::t4proto::v1::auth::_AuthenticationTokenRequest_default_instance_);
}
inline const ::t4proto::v1::auth::AuthenticationTokenRequest& ClientMessage::authentication_token_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ClientMessage.authentication_token_request)
  return _internal_authentication_token_request();
}
inline ::t4proto::v1::auth::AuthenticationTokenRequest* PROTOBUF_NULLABLE ClientMessage::unsafe_arena_release_authentication_token_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ClientMessage.authentication_token_request)
  if (payload_case() == kAuthenticationTokenRequest) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::auth::AuthenticationTokenRequest*>(_impl_.payload_.authentication_token_request_);
    _impl_.payload_.authentication_token_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_authentication_token_request(
    ::t4proto::v1::auth::AuthenticationTokenRequest* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_authentication_token_request();
    _impl_.payload_.authentication_token_request_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ClientMessage.authentication_token_request)
}
inline ::t4proto::v1::auth::AuthenticationTokenRequest* PROTOBUF_NONNULL ClientMessage::_internal_mutable_authentication_token_request() {
  if (payload_case() != kAuthenticationTokenRequest) {
    clear_payload();
    set_has_authentication_token_request();
    _impl_.payload_.authentication_token_request_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::auth::AuthenticationTokenRequest>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::auth::AuthenticationTokenRequest*>(_impl_.payload_.authentication_token_request_);
}
inline ::t4proto::v1::auth::AuthenticationTokenRequest* PROTOBUF_NONNULL ClientMessage::mutable_authentication_token_request()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::auth::AuthenticationTokenRequest* _msg = _internal_mutable_authentication_token_request();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ClientMessage.authentication_token_request)
  return _msg;
}

// .t4proto.v1.market.MarketDepthSubscribe market_depth_subscribe = 100;
inline bool ClientMessage::has_market_depth_subscribe() const {
  return payload_case() == kMarketDepthSubscribe;
}
inline bool ClientMessage::_internal_has_market_depth_subscribe() const {
  return payload_case() == kMarketDepthSubscribe;
}
inline void ClientMessage::set_has_market_depth_subscribe() {
  _impl_._oneof_case_[0] = kMarketDepthSubscribe;
}
inline ::t4proto::v1::market::MarketDepthSubscribe* PROTOBUF_NULLABLE ClientMessage::release_market_depth_subscribe() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ClientMessage.market_depth_subscribe)
  if (payload_case() == kMarketDepthSubscribe) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::market::MarketDepthSubscribe*>(_impl_.payload_.market_depth_subscribe_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_depth_subscribe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketDepthSubscribe& ClientMessage::_internal_market_depth_subscribe() const {
  return payload_case() == kMarketDepthSubscribe ? *reinterpret_cast<::t4proto::v1::market::MarketDepthSubscribe*>(_impl_.payload_.market_depth_subscribe_) : reinterpret_cast<::t4proto::v1::market::MarketDepthSubscribe&>(::t4proto::v1::market::_MarketDepthSubscribe_default_instance_);
}
inline const ::t4proto::v1::market::MarketDepthSubscribe& ClientMessage::market_depth_subscribe() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ClientMessage.market_depth_subscribe)
  return _internal_market_depth_subscribe();
}
inline ::t4proto::v1::market::MarketDepthSubscribe* PROTOBUF_NULLABLE ClientMessage::unsafe_arena_release_market_depth_subscribe() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ClientMessage.market_depth_subscribe)
  if (payload_case() == kMarketDepthSubscribe) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::market::MarketDepthSubscribe*>(_impl_.payload_.market_depth_subscribe_);
    _impl_.payload_.market_depth_subscribe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_market_depth_subscribe(
    ::t4proto::v1::market::MarketDepthSubscribe* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_market_depth_subscribe();
    _impl_.payload_.market_depth_subscribe_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ClientMessage.market_depth_subscribe)
}
inline ::t4proto::v1::market::MarketDepthSubscribe* PROTOBUF_NONNULL ClientMessage::_internal_mutable_market_depth_subscribe() {
  if (payload_case() != kMarketDepthSubscribe) {
    clear_payload();
    set_has_market_depth_subscribe();
    _impl_.payload_.market_depth_subscribe_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::market::MarketDepthSubscribe>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::market::MarketDepthSubscribe*>(_impl_.payload_.market_depth_subscribe_);
}
inline ::t4proto::v1::market::MarketDepthSubscribe* PROTOBUF_NONNULL ClientMessage::mutable_market_depth_subscribe()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::market::MarketDepthSubscribe* _msg = _internal_mutable_market_depth_subscribe();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ClientMessage.market_depth_subscribe)
  return _msg;
}

// .t4proto.v1.market.MarketByOrderSubscribe market_by_order_subscribe = 101;
inline bool ClientMessage::has_market_by_order_subscribe() const {
  return payload_case() == kMarketByOrderSubscribe;
}
inline bool ClientMessage::_internal_has_market_by_order_subscribe() const {
  return payload_case() == kMarketByOrderSubscribe;
}
inline void ClientMessage::set_has_market_by_order_subscribe() {
  _impl_._oneof_case_[0] = kMarketByOrderSubscribe;
}
inline ::t4proto::v1::market::MarketByOrderSubscribe* PROTOBUF_NULLABLE ClientMessage::release_market_by_order_subscribe() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ClientMessage.market_by_order_subscribe)
  if (payload_case() == kMarketByOrderSubscribe) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::market::MarketByOrderSubscribe*>(_impl_.payload_.market_by_order_subscribe_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_by_order_subscribe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketByOrderSubscribe& ClientMessage::_internal_market_by_order_subscribe() const {
  return payload_case() == kMarketByOrderSubscribe ? *reinterpret_cast<::t4proto::v1::market::MarketByOrderSubscribe*>(_impl_.payload_.market_by_order_subscribe_) : reinterpret_cast<::t4proto::v1::market::MarketByOrderSubscribe&>(::t4proto::v1::market::_MarketByOrderSubscribe_default_instance_);
}
inline const ::t4proto::v1::market::MarketByOrderSubscribe& ClientMessage::market_by_order_subscribe() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ClientMessage.market_by_order_subscribe)
  return _internal_market_by_order_subscribe();
}
inline ::t4proto::v1::market::MarketByOrderSubscribe* PROTOBUF_NULLABLE ClientMessage::unsafe_arena_release_market_by_order_subscribe() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ClientMessage.market_by_order_subscribe)
  if (payload_case() == kMarketByOrderSubscribe) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::market::MarketByOrderSubscribe*>(_impl_.payload_.market_by_order_subscribe_);
    _impl_.payload_.market_by_order_subscribe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_market_by_order_subscribe(
    ::t4proto::v1::market::MarketByOrderSubscribe* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_market_by_order_subscribe();
    _impl_.payload_.market_by_order_subscribe_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ClientMessage.market_by_order_subscribe)
}
inline ::t4proto::v1::market::MarketByOrderSubscribe* PROTOBUF_NONNULL ClientMessage::_internal_mutable_market_by_order_subscribe() {
  if (payload_case() != kMarketByOrderSubscribe) {
    clear_payload();
    set_has_market_by_order_subscribe();
    _impl_.payload_.market_by_order_subscribe_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::market::MarketByOrderSubscribe>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::market::MarketByOrderSubscribe*>(_impl_.payload_.market_by_order_subscribe_);
}
inline ::t4proto::v1::market::MarketByOrderSubscribe* PROTOBUF_NONNULL ClientMessage::mutable_market_by_order_subscribe()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::market::MarketByOrderSubscribe* _msg = _internal_mutable_market_by_order_subscribe();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ClientMessage.market_by_order_subscribe)
  return _msg;
}

// .t4proto.v1.account.AccountSubscribe account_subscribe = 200;
inline bool ClientMessage::has_account_subscribe() const {
  return payload_case() == kAccountSubscribe;
}
inline bool ClientMessage::_internal_has_account_subscribe() const {
  return payload_case() == kAccountSubscribe;
}
inline void ClientMessage::set_has_account_subscribe() {
  _impl_._oneof_case_[0] = kAccountSubscribe;
}
inline ::t4proto::v1::account::AccountSubscribe* PROTOBUF_NULLABLE ClientMessage::release_account_subscribe() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ClientMessage.account_subscribe)
  if (payload_case() == kAccountSubscribe) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::account::AccountSubscribe*>(_impl_.payload_.account_subscribe_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.account_subscribe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::account::AccountSubscribe& ClientMessage::_internal_account_subscribe() const {
  return payload_case() == kAccountSubscribe ? *reinterpret_cast<::t4proto::v1::account::AccountSubscribe*>(_impl_.payload_.account_subscribe_) : reinterpret_cast<::t4proto::v1::account::AccountSubscribe&>(::t4proto::v1::account::_AccountSubscribe_default_instance_);
}
inline const ::t4proto::v1::account::AccountSubscribe& ClientMessage::account_subscribe() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ClientMessage.account_subscribe)
  return _internal_account_subscribe();
}
inline ::t4proto::v1::account::AccountSubscribe* PROTOBUF_NULLABLE ClientMessage::unsafe_arena_release_account_subscribe() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ClientMessage.account_subscribe)
  if (payload_case() == kAccountSubscribe) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::account::AccountSubscribe*>(_impl_.payload_.account_subscribe_);
    _impl_.payload_.account_subscribe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_account_subscribe(
    ::t4proto::v1::account::AccountSubscribe* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_account_subscribe();
    _impl_.payload_.account_subscribe_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ClientMessage.account_subscribe)
}
inline ::t4proto::v1::account::AccountSubscribe* PROTOBUF_NONNULL ClientMessage::_internal_mutable_account_subscribe() {
  if (payload_case() != kAccountSubscribe) {
    clear_payload();
    set_has_account_subscribe();
    _impl_.payload_.account_subscribe_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::account::AccountSubscribe>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::account::AccountSubscribe*>(_impl_.payload_.account_subscribe_);
}
inline ::t4proto::v1::account::AccountSubscribe* PROTOBUF_NONNULL ClientMessage::mutable_account_subscribe()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::account::AccountSubscribe* _msg = _internal_mutable_account_subscribe();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ClientMessage.account_subscribe)
  return _msg;
}

// .t4proto.v1.orderrouting.OrderSubmit order_submit = 300;
inline bool ClientMessage::has_order_submit() const {
  return payload_case() == kOrderSubmit;
}
inline bool ClientMessage::_internal_has_order_submit() const {
  return payload_case() == kOrderSubmit;
}
inline void ClientMessage::set_has_order_submit() {
  _impl_._oneof_case_[0] = kOrderSubmit;
}
inline ::t4proto::v1::orderrouting::OrderSubmit* PROTOBUF_NULLABLE ClientMessage::release_order_submit() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ClientMessage.order_submit)
  if (payload_case() == kOrderSubmit) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::orderrouting::OrderSubmit*>(_impl_.payload_.order_submit_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.order_submit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::OrderSubmit& ClientMessage::_internal_order_submit() const {
  return payload_case() == kOrderSubmit ? *reinterpret_cast<::t4proto::v1::orderrouting::OrderSubmit*>(_impl_.payload_.order_submit_) : reinterpret_cast<::t4proto::v1::orderrouting::OrderSubmit&>(::t4proto::v1::orderrouting::_OrderSubmit_default_instance_);
}
inline const ::t4proto::v1::orderrouting::OrderSubmit& ClientMessage::order_submit() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ClientMessage.order_submit)
  return _internal_order_submit();
}
inline ::t4proto::v1::orderrouting::OrderSubmit* PROTOBUF_NULLABLE ClientMessage::unsafe_arena_release_order_submit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ClientMessage.order_submit)
  if (payload_case() == kOrderSubmit) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::orderrouting::OrderSubmit*>(_impl_.payload_.order_submit_);
    _impl_.payload_.order_submit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_order_submit(
    ::t4proto::v1::orderrouting::OrderSubmit* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_order_submit();
    _impl_.payload_.order_submit_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ClientMessage.order_submit)
}
inline ::t4proto::v1::orderrouting::OrderSubmit* PROTOBUF_NONNULL ClientMessage::_internal_mutable_order_submit() {
  if (payload_case() != kOrderSubmit) {
    clear_payload();
    set_has_order_submit();
    _impl_.payload_.order_submit_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::orderrouting::OrderSubmit>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::orderrouting::OrderSubmit*>(_impl_.payload_.order_submit_);
}
inline ::t4proto::v1::orderrouting::OrderSubmit* PROTOBUF_NONNULL ClientMessage::mutable_order_submit()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::orderrouting::OrderSubmit* _msg = _internal_mutable_order_submit();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ClientMessage.order_submit)
  return _msg;
}

// .t4proto.v1.orderrouting.OrderRevise order_revise = 301;
inline bool ClientMessage::has_order_revise() const {
  return payload_case() == kOrderRevise;
}
inline bool ClientMessage::_internal_has_order_revise() const {
  return payload_case() == kOrderRevise;
}
inline void ClientMessage::set_has_order_revise() {
  _impl_._oneof_case_[0] = kOrderRevise;
}
inline ::t4proto::v1::orderrouting::OrderRevise* PROTOBUF_NULLABLE ClientMessage::release_order_revise() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ClientMessage.order_revise)
  if (payload_case() == kOrderRevise) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::orderrouting::OrderRevise*>(_impl_.payload_.order_revise_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.order_revise_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::OrderRevise& ClientMessage::_internal_order_revise() const {
  return payload_case() == kOrderRevise ? *reinterpret_cast<::t4proto::v1::orderrouting::OrderRevise*>(_impl_.payload_.order_revise_) : reinterpret_cast<::t4proto::v1::orderrouting::OrderRevise&>(::t4proto::v1::orderrouting::_OrderRevise_default_instance_);
}
inline const ::t4proto::v1::orderrouting::OrderRevise& ClientMessage::order_revise() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ClientMessage.order_revise)
  return _internal_order_revise();
}
inline ::t4proto::v1::orderrouting::OrderRevise* PROTOBUF_NULLABLE ClientMessage::unsafe_arena_release_order_revise() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ClientMessage.order_revise)
  if (payload_case() == kOrderRevise) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::orderrouting::OrderRevise*>(_impl_.payload_.order_revise_);
    _impl_.payload_.order_revise_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_order_revise(
    ::t4proto::v1::orderrouting::OrderRevise* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_order_revise();
    _impl_.payload_.order_revise_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ClientMessage.order_revise)
}
inline ::t4proto::v1::orderrouting::OrderRevise* PROTOBUF_NONNULL ClientMessage::_internal_mutable_order_revise() {
  if (payload_case() != kOrderRevise) {
    clear_payload();
    set_has_order_revise();
    _impl_.payload_.order_revise_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::orderrouting::OrderRevise>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::orderrouting::OrderRevise*>(_impl_.payload_.order_revise_);
}
inline ::t4proto::v1::orderrouting::OrderRevise* PROTOBUF_NONNULL ClientMessage::mutable_order_revise()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::orderrouting::OrderRevise* _msg = _internal_mutable_order_revise();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ClientMessage.order_revise)
  return _msg;
}

// .t4proto.v1.orderrouting.OrderPull order_pull = 302;
inline bool ClientMessage::has_order_pull() const {
  return payload_case() == kOrderPull;
}
inline bool ClientMessage::_internal_has_order_pull() const {
  return payload_case() == kOrderPull;
}
inline void ClientMessage::set_has_order_pull() {
  _impl_._oneof_case_[0] = kOrderPull;
}
inline ::t4proto::v1::orderrouting::OrderPull* PROTOBUF_NULLABLE ClientMessage::release_order_pull() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ClientMessage.order_pull)
  if (payload_case() == kOrderPull) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::orderrouting::OrderPull*>(_impl_.payload_.order_pull_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.order_pull_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::OrderPull& ClientMessage::_internal_order_pull() const {
  return payload_case() == kOrderPull ? *reinterpret_cast<::t4proto::v1::orderrouting::OrderPull*>(_impl_.payload_.order_pull_) : reinterpret_cast<::t4proto::v1::orderrouting::OrderPull&>(::t4proto::v1::orderrouting::_OrderPull_default_instance_);
}
inline const ::t4proto::v1::orderrouting::OrderPull& ClientMessage::order_pull() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ClientMessage.order_pull)
  return _internal_order_pull();
}
inline ::t4proto::v1::orderrouting::OrderPull* PROTOBUF_NULLABLE ClientMessage::unsafe_arena_release_order_pull() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ClientMessage.order_pull)
  if (payload_case() == kOrderPull) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::orderrouting::OrderPull*>(_impl_.payload_.order_pull_);
    _impl_.payload_.order_pull_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_order_pull(
    ::t4proto::v1::orderrouting::OrderPull* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_order_pull();
    _impl_.payload_.order_pull_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ClientMessage.order_pull)
}
inline ::t4proto::v1::orderrouting::OrderPull* PROTOBUF_NONNULL ClientMessage::_internal_mutable_order_pull() {
  if (payload_case() != kOrderPull) {
    clear_payload();
    set_has_order_pull();
    _impl_.payload_.order_pull_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::orderrouting::OrderPull>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::orderrouting::OrderPull*>(_impl_.payload_.order_pull_);
}
inline ::t4proto::v1::orderrouting::OrderPull* PROTOBUF_NONNULL ClientMessage::mutable_order_pull()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::orderrouting::OrderPull* _msg = _internal_mutable_order_pull();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ClientMessage.order_pull)
  return _msg;
}

// .t4proto.v1.orderrouting.CreateUDS create_uds = 340;
inline bool ClientMessage::has_create_uds() const {
  return payload_case() == kCreateUds;
}
inline bool ClientMessage::_internal_has_create_uds() const {
  return payload_case() == kCreateUds;
}
inline void ClientMessage::set_has_create_uds() {
  _impl_._oneof_case_[0] = kCreateUds;
}
inline ::t4proto::v1::orderrouting::CreateUDS* PROTOBUF_NULLABLE ClientMessage::release_create_uds() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ClientMessage.create_uds)
  if (payload_case() == kCreateUds) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::orderrouting::CreateUDS*>(_impl_.payload_.create_uds_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.create_uds_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::CreateUDS& ClientMessage::_internal_create_uds() const {
  return payload_case() == kCreateUds ? *reinterpret_cast<::t4proto::v1::orderrouting::CreateUDS*>(_impl_.payload_.create_uds_) : reinterpret_cast<::t4proto::v1::orderrouting::CreateUDS&>(::t4proto::v1::orderrouting::_CreateUDS_default_instance_);
}
inline const ::t4proto::v1::orderrouting::CreateUDS& ClientMessage::create_uds() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ClientMessage.create_uds)
  return _internal_create_uds();
}
inline ::t4proto::v1::orderrouting::CreateUDS* PROTOBUF_NULLABLE ClientMessage::unsafe_arena_release_create_uds() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ClientMessage.create_uds)
  if (payload_case() == kCreateUds) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::orderrouting::CreateUDS*>(_impl_.payload_.create_uds_);
    _impl_.payload_.create_uds_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_create_uds(
    ::t4proto::v1::orderrouting::CreateUDS* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_create_uds();
    _impl_.payload_.create_uds_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ClientMessage.create_uds)
}
inline ::t4proto::v1::orderrouting::CreateUDS* PROTOBUF_NONNULL ClientMessage::_internal_mutable_create_uds() {
  if (payload_case() != kCreateUds) {
    clear_payload();
    set_has_create_uds();
    _impl_.payload_.create_uds_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::orderrouting::CreateUDS>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::orderrouting::CreateUDS*>(_impl_.payload_.create_uds_);
}
inline ::t4proto::v1::orderrouting::CreateUDS* PROTOBUF_NONNULL ClientMessage::mutable_create_uds()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::orderrouting::CreateUDS* _msg = _internal_mutable_create_uds();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ClientMessage.create_uds)
  return _msg;
}

inline bool ClientMessage::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void ClientMessage::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline ClientMessage::PayloadCase ClientMessage::payload_case() const {
  return ClientMessage::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ServerMessage

// .t4proto.v1.service.Heartbeat heartbeat = 1;
inline bool ServerMessage::has_heartbeat() const {
  return payload_case() == kHeartbeat;
}
inline bool ServerMessage::_internal_has_heartbeat() const {
  return payload_case() == kHeartbeat;
}
inline void ServerMessage::set_has_heartbeat() {
  _impl_._oneof_case_[0] = kHeartbeat;
}
inline void ServerMessage::clear_heartbeat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kHeartbeat) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.heartbeat_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.heartbeat_);
    }
    clear_has_payload();
  }
}
inline ::t4proto::v1::service::Heartbeat* PROTOBUF_NULLABLE ServerMessage::release_heartbeat() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.heartbeat)
  if (payload_case() == kHeartbeat) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::service::Heartbeat*>(_impl_.payload_.heartbeat_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::service::Heartbeat& ServerMessage::_internal_heartbeat() const {
  return payload_case() == kHeartbeat ? *reinterpret_cast<::t4proto::v1::service::Heartbeat*>(_impl_.payload_.heartbeat_) : reinterpret_cast<::t4proto::v1::service::Heartbeat&>(::t4proto::v1::service::_Heartbeat_default_instance_);
}
inline const ::t4proto::v1::service::Heartbeat& ServerMessage::heartbeat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.heartbeat)
  return _internal_heartbeat();
}
inline ::t4proto::v1::service::Heartbeat* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_heartbeat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.heartbeat)
  if (payload_case() == kHeartbeat) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::service::Heartbeat*>(_impl_.payload_.heartbeat_);
    _impl_.payload_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_heartbeat(
    ::t4proto::v1::service::Heartbeat* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_heartbeat();
    _impl_.payload_.heartbeat_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.heartbeat)
}
inline ::t4proto::v1::service::Heartbeat* PROTOBUF_NONNULL ServerMessage::_internal_mutable_heartbeat() {
  if (payload_case() != kHeartbeat) {
    clear_payload();
    set_has_heartbeat();
    _impl_.payload_.heartbeat_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::service::Heartbeat>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::service::Heartbeat*>(_impl_.payload_.heartbeat_);
}
inline ::t4proto::v1::service::Heartbeat* PROTOBUF_NONNULL ServerMessage::mutable_heartbeat()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::service::Heartbeat* _msg = _internal_mutable_heartbeat();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.heartbeat)
  return _msg;
}

// .t4proto.v1.auth.LoginResponse login_response = 2;
inline bool ServerMessage::has_login_response() const {
  return payload_case() == kLoginResponse;
}
inline bool ServerMessage::_internal_has_login_response() const {
  return payload_case() == kLoginResponse;
}
inline void ServerMessage::set_has_login_response() {
  _impl_._oneof_case_[0] = kLoginResponse;
}
inline ::t4proto::v1::auth::LoginResponse* PROTOBUF_NULLABLE ServerMessage::release_login_response() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.login_response)
  if (payload_case() == kLoginResponse) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::auth::LoginResponse*>(_impl_.payload_.login_response_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.login_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::auth::LoginResponse& ServerMessage::_internal_login_response() const {
  return payload_case() == kLoginResponse ? *reinterpret_cast<::t4proto::v1::auth::LoginResponse*>(_impl_.payload_.login_response_) : reinterpret_cast<::t4proto::v1::auth::LoginResponse&>(::t4proto::v1::auth::_LoginResponse_default_instance_);
}
inline const ::t4proto::v1::auth::LoginResponse& ServerMessage::login_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.login_response)
  return _internal_login_response();
}
inline ::t4proto::v1::auth::LoginResponse* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_login_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.login_response)
  if (payload_case() == kLoginResponse) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::auth::LoginResponse*>(_impl_.payload_.login_response_);
    _impl_.payload_.login_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_login_response(
    ::t4proto::v1::auth::LoginResponse* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_login_response();
    _impl_.payload_.login_response_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.login_response)
}
inline ::t4proto::v1::auth::LoginResponse* PROTOBUF_NONNULL ServerMessage::_internal_mutable_login_response() {
  if (payload_case() != kLoginResponse) {
    clear_payload();
    set_has_login_response();
    _impl_.payload_.login_response_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::auth::LoginResponse>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::auth::LoginResponse*>(_impl_.payload_.login_response_);
}
inline ::t4proto::v1::auth::LoginResponse* PROTOBUF_NONNULL ServerMessage::mutable_login_response()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::auth::LoginResponse* _msg = _internal_mutable_login_response();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.login_response)
  return _msg;
}

// .t4proto.v1.auth.AuthenticationToken authentication_token = 3;
inline bool ServerMessage::has_authentication_token() const {
  return payload_case() == kAuthenticationToken;
}
inline bool ServerMessage::_internal_has_authentication_token() const {
  return payload_case() == kAuthenticationToken;
}
inline void ServerMessage::set_has_authentication_token() {
  _impl_._oneof_case_[0] = kAuthenticationToken;
}
inline ::t4proto::v1::auth::AuthenticationToken* PROTOBUF_NULLABLE ServerMessage::release_authentication_token() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.authentication_token)
  if (payload_case() == kAuthenticationToken) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::auth::AuthenticationToken*>(_impl_.payload_.authentication_token_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.authentication_token_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::auth::AuthenticationToken& ServerMessage::_internal_authentication_token() const {
  return payload_case() == kAuthenticationToken ? *reinterpret_cast<::t4proto::v1::auth::AuthenticationToken*>(_impl_.payload_.authentication_token_) : reinterpret_cast<::t4proto::v1::auth::AuthenticationToken&>(::t4proto::v1::auth::_AuthenticationToken_default_instance_);
}
inline const ::t4proto::v1::auth::AuthenticationToken& ServerMessage::authentication_token() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.authentication_token)
  return _internal_authentication_token();
}
inline ::t4proto::v1::auth::AuthenticationToken* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_authentication_token() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.authentication_token)
  if (payload_case() == kAuthenticationToken) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::auth::AuthenticationToken*>(_impl_.payload_.authentication_token_);
    _impl_.payload_.authentication_token_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_authentication_token(
    ::t4proto::v1::auth::AuthenticationToken* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_authentication_token();
    _impl_.payload_.authentication_token_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.authentication_token)
}
inline ::t4proto::v1::auth::AuthenticationToken* PROTOBUF_NONNULL ServerMessage::_internal_mutable_authentication_token() {
  if (payload_case() != kAuthenticationToken) {
    clear_payload();
    set_has_authentication_token();
    _impl_.payload_.authentication_token_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::auth::AuthenticationToken>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::auth::AuthenticationToken*>(_impl_.payload_.authentication_token_);
}
inline ::t4proto::v1::auth::AuthenticationToken* PROTOBUF_NONNULL ServerMessage::mutable_authentication_token()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::auth::AuthenticationToken* _msg = _internal_mutable_authentication_token();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.authentication_token)
  return _msg;
}

// .t4proto.v1.market.MarketDepthSubscribeReject market_depth_subscribe_reject = 100;
inline bool ServerMessage::has_market_depth_subscribe_reject() const {
  return payload_case() == kMarketDepthSubscribeReject;
}
inline bool ServerMessage::_internal_has_market_depth_subscribe_reject() const {
  return payload_case() == kMarketDepthSubscribeReject;
}
inline void ServerMessage::set_has_market_depth_subscribe_reject() {
  _impl_._oneof_case_[0] = kMarketDepthSubscribeReject;
}
inline ::t4proto::v1::market::MarketDepthSubscribeReject* PROTOBUF_NULLABLE ServerMessage::release_market_depth_subscribe_reject() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_depth_subscribe_reject)
  if (payload_case() == kMarketDepthSubscribeReject) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::market::MarketDepthSubscribeReject*>(_impl_.payload_.market_depth_subscribe_reject_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_depth_subscribe_reject_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketDepthSubscribeReject& ServerMessage::_internal_market_depth_subscribe_reject() const {
  return payload_case() == kMarketDepthSubscribeReject ? *reinterpret_cast<::t4proto::v1::market::MarketDepthSubscribeReject*>(_impl_.payload_.market_depth_subscribe_reject_) : reinterpret_cast<::t4proto::v1::market::MarketDepthSubscribeReject&>(::t4proto::v1::market::_MarketDepthSubscribeReject_default_instance_);
}
inline const ::t4proto::v1::market::MarketDepthSubscribeReject& ServerMessage::market_depth_subscribe_reject() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_depth_subscribe_reject)
  return _internal_market_depth_subscribe_reject();
}
inline ::t4proto::v1::market::MarketDepthSubscribeReject* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_market_depth_subscribe_reject() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_depth_subscribe_reject)
  if (payload_case() == kMarketDepthSubscribeReject) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::market::MarketDepthSubscribeReject*>(_impl_.payload_.market_depth_subscribe_reject_);
    _impl_.payload_.market_depth_subscribe_reject_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_depth_subscribe_reject(
    ::t4proto::v1::market::MarketDepthSubscribeReject* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_market_depth_subscribe_reject();
    _impl_.payload_.market_depth_subscribe_reject_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_depth_subscribe_reject)
}
inline ::t4proto::v1::market::MarketDepthSubscribeReject* PROTOBUF_NONNULL ServerMessage::_internal_mutable_market_depth_subscribe_reject() {
  if (payload_case() != kMarketDepthSubscribeReject) {
    clear_payload();
    set_has_market_depth_subscribe_reject();
    _impl_.payload_.market_depth_subscribe_reject_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::market::MarketDepthSubscribeReject>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::market::MarketDepthSubscribeReject*>(_impl_.payload_.market_depth_subscribe_reject_);
}
inline ::t4proto::v1::market::MarketDepthSubscribeReject* PROTOBUF_NONNULL ServerMessage::mutable_market_depth_subscribe_reject()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::market::MarketDepthSubscribeReject* _msg = _internal_mutable_market_depth_subscribe_reject();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_depth_subscribe_reject)
  return _msg;
}

// .t4proto.v1.market.MarketByOrderSubscribeReject market_by_order_subscribe_reject = 101;
inline bool ServerMessage::has_market_by_order_subscribe_reject() const {
  return payload_case() == kMarketByOrderSubscribeReject;
}
inline bool ServerMessage::_internal_has_market_by_order_subscribe_reject() const {
  return payload_case() == kMarketByOrderSubscribeReject;
}
inline void ServerMessage::set_has_market_by_order_subscribe_reject() {
  _impl_._oneof_case_[0] = kMarketByOrderSubscribeReject;
}
inline ::t4proto::v1::market::MarketByOrderSubscribeReject* PROTOBUF_NULLABLE ServerMessage::release_market_by_order_subscribe_reject() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_by_order_subscribe_reject)
  if (payload_case() == kMarketByOrderSubscribeReject) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::market::MarketByOrderSubscribeReject*>(_impl_.payload_.market_by_order_subscribe_reject_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_by_order_subscribe_reject_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketByOrderSubscribeReject& ServerMessage::_internal_market_by_order_subscribe_reject() const {
  return payload_case() == kMarketByOrderSubscribeReject ? *reinterpret_cast<::t4proto::v1::market::MarketByOrderSubscribeReject*>(_impl_.payload_.market_by_order_subscribe_reject_) : reinterpret_cast<::t4proto::v1::market::MarketByOrderSubscribeReject&>(::t4proto::v1::market::_MarketByOrderSubscribeReject_default_instance_);
}
inline const ::t4proto::v1::market::MarketByOrderSubscribeReject& ServerMessage::market_by_order_subscribe_reject() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_by_order_subscribe_reject)
  return _internal_market_by_order_subscribe_reject();
}
inline ::t4proto::v1::market::MarketByOrderSubscribeReject* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_market_by_order_subscribe_reject() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_by_order_subscribe_reject)
  if (payload_case() == kMarketByOrderSubscribeReject) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::market::MarketByOrderSubscribeReject*>(_impl_.payload_.market_by_order_subscribe_reject_);
    _impl_.payload_.market_by_order_subscribe_reject_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_by_order_subscribe_reject(
    ::t4proto::v1::market::MarketByOrderSubscribeReject* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_market_by_order_subscribe_reject();
    _impl_.payload_.market_by_order_subscribe_reject_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_by_order_subscribe_reject)
}
inline ::t4proto::v1::market::MarketByOrderSubscribeReject* PROTOBUF_NONNULL ServerMessage::_internal_mutable_market_by_order_subscribe_reject() {
  if (payload_case() != kMarketByOrderSubscribeReject) {
    clear_payload();
    set_has_market_by_order_subscribe_reject();
    _impl_.payload_.market_by_order_subscribe_reject_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::market::MarketByOrderSubscribeReject>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::market::MarketByOrderSubscribeReject*>(_impl_.payload_.market_by_order_subscribe_reject_);
}
inline ::t4proto::v1::market::MarketByOrderSubscribeReject* PROTOBUF_NONNULL ServerMessage::mutable_market_by_order_subscribe_reject()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::market::MarketByOrderSubscribeReject* _msg = _internal_mutable_market_by_order_subscribe_reject();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_by_order_subscribe_reject)
  return _msg;
}

// .t4proto.v1.market.MarketDetails market_details = 102;
inline bool ServerMessage::has_market_details() const {
  return payload_case() == kMarketDetails;
}
inline bool ServerMessage::_internal_has_market_details() const {
  return payload_case() == kMarketDetails;
}
inline void ServerMessage::set_has_market_details() {
  _impl_._oneof_case_[0] = kMarketDetails;
}
inline ::t4proto::v1::market::MarketDetails* PROTOBUF_NULLABLE ServerMessage::release_market_details() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_details)
  if (payload_case() == kMarketDetails) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::market::MarketDetails*>(_impl_.payload_.market_details_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_details_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketDetails& ServerMessage::_internal_market_details() const {
  return payload_case() == kMarketDetails ? *reinterpret_cast<::t4proto::v1::market::MarketDetails*>(_impl_.payload_.market_details_) : reinterpret_cast<::t4proto::v1::market::MarketDetails&>(::t4proto::v1::market::_MarketDetails_default_instance_);
}
inline const ::t4proto::v1::market::MarketDetails& ServerMessage::market_details() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_details)
  return _internal_market_details();
}
inline ::t4proto::v1::market::MarketDetails* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_market_details() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_details)
  if (payload_case() == kMarketDetails) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::market::MarketDetails*>(_impl_.payload_.market_details_);
    _impl_.payload_.market_details_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_details(
    ::t4proto::v1::market::MarketDetails* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_market_details();
    _impl_.payload_.market_details_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_details)
}
inline ::t4proto::v1::market::MarketDetails* PROTOBUF_NONNULL ServerMessage::_internal_mutable_market_details() {
  if (payload_case() != kMarketDetails) {
    clear_payload();
    set_has_market_details();
    _impl_.payload_.market_details_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::market::MarketDetails>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::market::MarketDetails*>(_impl_.payload_.market_details_);
}
inline ::t4proto::v1::market::MarketDetails* PROTOBUF_NONNULL ServerMessage::mutable_market_details()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::market::MarketDetails* _msg = _internal_mutable_market_details();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_details)
  return _msg;
}

// .t4proto.v1.market.MarketDepth market_depth = 103;
inline bool ServerMessage::has_market_depth() const {
  return payload_case() == kMarketDepth;
}
inline bool ServerMessage::_internal_has_market_depth() const {
  return payload_case() == kMarketDepth;
}
inline void ServerMessage::set_has_market_depth() {
  _impl_._oneof_case_[0] = kMarketDepth;
}
inline ::t4proto::v1::market::MarketDepth* PROTOBUF_NULLABLE ServerMessage::release_market_depth() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_depth)
  if (payload_case() == kMarketDepth) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::market::MarketDepth*>(_impl_.payload_.market_depth_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_depth_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketDepth& ServerMessage::_internal_market_depth() const {
  return payload_case() == kMarketDepth ? *reinterpret_cast<::t4proto::v1::market::MarketDepth*>(_impl_.payload_.market_depth_) : reinterpret_cast<::t4proto::v1::market::MarketDepth&>(::t4proto::v1::market::_MarketDepth_default_instance_);
}
inline const ::t4proto::v1::market::MarketDepth& ServerMessage::market_depth() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_depth)
  return _internal_market_depth();
}
inline ::t4proto::v1::market::MarketDepth* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_market_depth() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_depth)
  if (payload_case() == kMarketDepth) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::market::MarketDepth*>(_impl_.payload_.market_depth_);
    _impl_.payload_.market_depth_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_depth(
    ::t4proto::v1::market::MarketDepth* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_market_depth();
    _impl_.payload_.market_depth_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_depth)
}
inline ::t4proto::v1::market::MarketDepth* PROTOBUF_NONNULL ServerMessage::_internal_mutable_market_depth() {
  if (payload_case() != kMarketDepth) {
    clear_payload();
    set_has_market_depth();
    _impl_.payload_.market_depth_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::market::MarketDepth>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::market::MarketDepth*>(_impl_.payload_.market_depth_);
}
inline ::t4proto::v1::market::MarketDepth* PROTOBUF_NONNULL ServerMessage::mutable_market_depth()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::market::MarketDepth* _msg = _internal_mutable_market_depth();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_depth)
  return _msg;
}

// .t4proto.v1.market.MarketDepthTrade market_depth_trade = 104;
inline bool ServerMessage::has_market_depth_trade() const {
  return payload_case() == kMarketDepthTrade;
}
inline bool ServerMessage::_internal_has_market_depth_trade() const {
  return payload_case() == kMarketDepthTrade;
}
inline void ServerMessage::set_has_market_depth_trade() {
  _impl_._oneof_case_[0] = kMarketDepthTrade;
}
inline ::t4proto::v1::market::MarketDepthTrade* PROTOBUF_NULLABLE ServerMessage::release_market_depth_trade() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_depth_trade)
  if (payload_case() == kMarketDepthTrade) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::market::MarketDepthTrade*>(_impl_.payload_.market_depth_trade_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_depth_trade_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketDepthTrade& ServerMessage::_internal_market_depth_trade() const {
  return payload_case() == kMarketDepthTrade ? *reinterpret_cast<::t4proto::v1::market::MarketDepthTrade*>(_impl_.payload_.market_depth_trade_) : reinterpret_cast<::t4proto::v1::market::MarketDepthTrade&>(::t4proto::v1::market::_MarketDepthTrade_default_instance_);
}
inline const ::t4proto::v1::market::MarketDepthTrade& ServerMessage::market_depth_trade() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_depth_trade)
  return _internal_market_depth_trade();
}
inline ::t4proto::v1::market::MarketDepthTrade* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_market_depth_trade() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_depth_trade)
  if (payload_case() == kMarketDepthTrade) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::market::MarketDepthTrade*>(_impl_.payload_.market_depth_trade_);
    _impl_.payload_.market_depth_trade_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_depth_trade(
    ::t4proto::v1::market::MarketDepthTrade* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_market_depth_trade();
    _impl_.payload_.market_depth_trade_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_depth_trade)
}
inline ::t4proto::v1::market::MarketDepthTrade* PROTOBUF_NONNULL ServerMessage::_internal_mutable_market_depth_trade() {
  if (payload_case() != kMarketDepthTrade) {
    clear_payload();
    set_has_market_depth_trade();
    _impl_.payload_.market_depth_trade_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::market::MarketDepthTrade>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::market::MarketDepthTrade*>(_impl_.payload_.market_depth_trade_);
}
inline ::t4proto::v1::market::MarketDepthTrade* PROTOBUF_NONNULL ServerMessage::mutable_market_depth_trade()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::market::MarketDepthTrade* _msg = _internal_mutable_market_depth_trade();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_depth_trade)
  return _msg;
}

// .t4proto.v1.market.MarketHighLow market_high_low = 105;
inline bool ServerMessage::has_market_high_low() const {
  return payload_case() == kMarketHighLow;
}
inline bool ServerMessage::_internal_has_market_high_low() const {
  return payload_case() == kMarketHighLow;
}
inline void ServerMessage::set_has_market_high_low() {
  _impl_._oneof_case_[0] = kMarketHighLow;
}
inline ::t4proto::v1::market::MarketHighLow* PROTOBUF_NULLABLE ServerMessage::release_market_high_low() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_high_low)
  if (payload_case() == kMarketHighLow) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::market::MarketHighLow*>(_impl_.payload_.market_high_low_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_high_low_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketHighLow& ServerMessage::_internal_market_high_low() const {
  return payload_case() == kMarketHighLow ? *reinterpret_cast<::t4proto::v1::market::MarketHighLow*>(_impl_.payload_.market_high_low_) : reinterpret_cast<::t4proto::v1::market::MarketHighLow&>(::t4proto::v1::market::_MarketHighLow_default_instance_);
}
inline const ::t4proto::v1::market::MarketHighLow& ServerMessage::market_high_low() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_high_low)
  return _internal_market_high_low();
}
inline ::t4proto::v1::market::MarketHighLow* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_market_high_low() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_high_low)
  if (payload_case() == kMarketHighLow) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::market::MarketHighLow*>(_impl_.payload_.market_high_low_);
    _impl_.payload_.market_high_low_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_high_low(
    ::t4proto::v1::market::MarketHighLow* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_market_high_low();
    _impl_.payload_.market_high_low_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_high_low)
}
inline ::t4proto::v1::market::MarketHighLow* PROTOBUF_NONNULL ServerMessage::_internal_mutable_market_high_low() {
  if (payload_case() != kMarketHighLow) {
    clear_payload();
    set_has_market_high_low();
    _impl_.payload_.market_high_low_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::market::MarketHighLow>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::market::MarketHighLow*>(_impl_.payload_.market_high_low_);
}
inline ::t4proto::v1::market::MarketHighLow* PROTOBUF_NONNULL ServerMessage::mutable_market_high_low()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::market::MarketHighLow* _msg = _internal_mutable_market_high_low();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_high_low)
  return _msg;
}

// .t4proto.v1.market.MarketPriceLimits market_price_limits = 106;
inline bool ServerMessage::has_market_price_limits() const {
  return payload_case() == kMarketPriceLimits;
}
inline bool ServerMessage::_internal_has_market_price_limits() const {
  return payload_case() == kMarketPriceLimits;
}
inline void ServerMessage::set_has_market_price_limits() {
  _impl_._oneof_case_[0] = kMarketPriceLimits;
}
inline ::t4proto::v1::market::MarketPriceLimits* PROTOBUF_NULLABLE ServerMessage::release_market_price_limits() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_price_limits)
  if (payload_case() == kMarketPriceLimits) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::market::MarketPriceLimits*>(_impl_.payload_.market_price_limits_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_price_limits_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketPriceLimits& ServerMessage::_internal_market_price_limits() const {
  return payload_case() == kMarketPriceLimits ? *reinterpret_cast<::t4proto::v1::market::MarketPriceLimits*>(_impl_.payload_.market_price_limits_) : reinterpret_cast<::t4proto::v1::market::MarketPriceLimits&>(::t4proto::v1::market::_MarketPriceLimits_default_instance_);
}
inline const ::t4proto::v1::market::MarketPriceLimits& ServerMessage::market_price_limits() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_price_limits)
  return _internal_market_price_limits();
}
inline ::t4proto::v1::market::MarketPriceLimits* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_market_price_limits() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_price_limits)
  if (payload_case() == kMarketPriceLimits) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::market::MarketPriceLimits*>(_impl_.payload_.market_price_limits_);
    _impl_.payload_.market_price_limits_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_price_limits(
    ::t4proto::v1::market::MarketPriceLimits* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_market_price_limits();
    _impl_.payload_.market_price_limits_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_price_limits)
}
inline ::t4proto::v1::market::MarketPriceLimits* PROTOBUF_NONNULL ServerMessage::_internal_mutable_market_price_limits() {
  if (payload_case() != kMarketPriceLimits) {
    clear_payload();
    set_has_market_price_limits();
    _impl_.payload_.market_price_limits_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::market::MarketPriceLimits>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::market::MarketPriceLimits*>(_impl_.payload_.market_price_limits_);
}
inline ::t4proto::v1::market::MarketPriceLimits* PROTOBUF_NONNULL ServerMessage::mutable_market_price_limits()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::market::MarketPriceLimits* _msg = _internal_mutable_market_price_limits();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_price_limits)
  return _msg;
}

// .t4proto.v1.market.MarketSettlement market_settlement = 107;
inline bool ServerMessage::has_market_settlement() const {
  return payload_case() == kMarketSettlement;
}
inline bool ServerMessage::_internal_has_market_settlement() const {
  return payload_case() == kMarketSettlement;
}
inline void ServerMessage::set_has_market_settlement() {
  _impl_._oneof_case_[0] = kMarketSettlement;
}
inline ::t4proto::v1::market::MarketSettlement* PROTOBUF_NULLABLE ServerMessage::release_market_settlement() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_settlement)
  if (payload_case() == kMarketSettlement) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::market::MarketSettlement*>(_impl_.payload_.market_settlement_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_settlement_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketSettlement& ServerMessage::_internal_market_settlement() const {
  return payload_case() == kMarketSettlement ? *reinterpret_cast<::t4proto::v1::market::MarketSettlement*>(_impl_.payload_.market_settlement_) : reinterpret_cast<::t4proto::v1::market::MarketSettlement&>(::t4proto::v1::market::_MarketSettlement_default_instance_);
}
inline const ::t4proto::v1::market::MarketSettlement& ServerMessage::market_settlement() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_settlement)
  return _internal_market_settlement();
}
inline ::t4proto::v1::market::MarketSettlement* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_market_settlement() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_settlement)
  if (payload_case() == kMarketSettlement) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::market::MarketSettlement*>(_impl_.payload_.market_settlement_);
    _impl_.payload_.market_settlement_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_settlement(
    ::t4proto::v1::market::MarketSettlement* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_market_settlement();
    _impl_.payload_.market_settlement_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_settlement)
}
inline ::t4proto::v1::market::MarketSettlement* PROTOBUF_NONNULL ServerMessage::_internal_mutable_market_settlement() {
  if (payload_case() != kMarketSettlement) {
    clear_payload();
    set_has_market_settlement();
    _impl_.payload_.market_settlement_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::market::MarketSettlement>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::market::MarketSettlement*>(_impl_.payload_.market_settlement_);
}
inline ::t4proto::v1::market::MarketSettlement* PROTOBUF_NONNULL ServerMessage::mutable_market_settlement()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::market::MarketSettlement* _msg = _internal_mutable_market_settlement();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_settlement)
  return _msg;
}

// .t4proto.v1.market.MarketSnapshot market_snapshot = 108;
inline bool ServerMessage::has_market_snapshot() const {
  return payload_case() == kMarketSnapshot;
}
inline bool ServerMessage::_internal_has_market_snapshot() const {
  return payload_case() == kMarketSnapshot;
}
inline void ServerMessage::set_has_market_snapshot() {
  _impl_._oneof_case_[0] = kMarketSnapshot;
}
inline ::t4proto::v1::market::MarketSnapshot* PROTOBUF_NULLABLE ServerMessage::release_market_snapshot() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_snapshot)
  if (payload_case() == kMarketSnapshot) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::market::MarketSnapshot*>(_impl_.payload_.market_snapshot_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketSnapshot& ServerMessage::_internal_market_snapshot() const {
  return payload_case() == kMarketSnapshot ? *reinterpret_cast<::t4proto::v1::market::MarketSnapshot*>(_impl_.payload_.market_snapshot_) : reinterpret_cast<::t4proto::v1::market::MarketSnapshot&>(::t4proto::v1::market::_MarketSnapshot_default_instance_);
}
inline const ::t4proto::v1::market::MarketSnapshot& ServerMessage::market_snapshot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_snapshot)
  return _internal_market_snapshot();
}
inline ::t4proto::v1::market::MarketSnapshot* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_market_snapshot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_snapshot)
  if (payload_case() == kMarketSnapshot) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::market::MarketSnapshot*>(_impl_.payload_.market_snapshot_);
    _impl_.payload_.market_snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_snapshot(
    ::t4proto::v1::market::MarketSnapshot* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_market_snapshot();
    _impl_.payload_.market_snapshot_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_snapshot)
}
inline ::t4proto::v1::market::MarketSnapshot* PROTOBUF_NONNULL ServerMessage::_internal_mutable_market_snapshot() {
  if (payload_case() != kMarketSnapshot) {
    clear_payload();
    set_has_market_snapshot();
    _impl_.payload_.market_snapshot_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::market::MarketSnapshot>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::market::MarketSnapshot*>(_impl_.payload_.market_snapshot_);
}
inline ::t4proto::v1::market::MarketSnapshot* PROTOBUF_NONNULL ServerMessage::mutable_market_snapshot()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::market::MarketSnapshot* _msg = _internal_mutable_market_snapshot();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_snapshot)
  return _msg;
}

// .t4proto.v1.market.MarketByOrderSnapshot market_by_order_snapshot = 109;
inline bool ServerMessage::has_market_by_order_snapshot() const {
  return payload_case() == kMarketByOrderSnapshot;
}
inline bool ServerMessage::_internal_has_market_by_order_snapshot() const {
  return payload_case() == kMarketByOrderSnapshot;
}
inline void ServerMessage::set_has_market_by_order_snapshot() {
  _impl_._oneof_case_[0] = kMarketByOrderSnapshot;
}
inline ::t4proto::v1::market::MarketByOrderSnapshot* PROTOBUF_NULLABLE ServerMessage::release_market_by_order_snapshot() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_by_order_snapshot)
  if (payload_case() == kMarketByOrderSnapshot) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::market::MarketByOrderSnapshot*>(_impl_.payload_.market_by_order_snapshot_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_by_order_snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketByOrderSnapshot& ServerMessage::_internal_market_by_order_snapshot() const {
  return payload_case() == kMarketByOrderSnapshot ? *reinterpret_cast<::t4proto::v1::market::MarketByOrderSnapshot*>(_impl_.payload_.market_by_order_snapshot_) : reinterpret_cast<::t4proto::v1::market::MarketByOrderSnapshot&>(::t4proto::v1::market::_MarketByOrderSnapshot_default_instance_);
}
inline const ::t4proto::v1::market::MarketByOrderSnapshot& ServerMessage::market_by_order_snapshot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_by_order_snapshot)
  return _internal_market_by_order_snapshot();
}
inline ::t4proto::v1::market::MarketByOrderSnapshot* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_market_by_order_snapshot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_by_order_snapshot)
  if (payload_case() == kMarketByOrderSnapshot) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::market::MarketByOrderSnapshot*>(_impl_.payload_.market_by_order_snapshot_);
    _impl_.payload_.market_by_order_snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_by_order_snapshot(
    ::t4proto::v1::market::MarketByOrderSnapshot* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_market_by_order_snapshot();
    _impl_.payload_.market_by_order_snapshot_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_by_order_snapshot)
}
inline ::t4proto::v1::market::MarketByOrderSnapshot* PROTOBUF_NONNULL ServerMessage::_internal_mutable_market_by_order_snapshot() {
  if (payload_case() != kMarketByOrderSnapshot) {
    clear_payload();
    set_has_market_by_order_snapshot();
    _impl_.payload_.market_by_order_snapshot_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::market::MarketByOrderSnapshot>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::market::MarketByOrderSnapshot*>(_impl_.payload_.market_by_order_snapshot_);
}
inline ::t4proto::v1::market::MarketByOrderSnapshot* PROTOBUF_NONNULL ServerMessage::mutable_market_by_order_snapshot()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::market::MarketByOrderSnapshot* _msg = _internal_mutable_market_by_order_snapshot();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_by_order_snapshot)
  return _msg;
}

// .t4proto.v1.market.MarketByOrderUpdate market_by_order_update = 110;
inline bool ServerMessage::has_market_by_order_update() const {
  return payload_case() == kMarketByOrderUpdate;
}
inline bool ServerMessage::_internal_has_market_by_order_update() const {
  return payload_case() == kMarketByOrderUpdate;
}
inline void ServerMessage::set_has_market_by_order_update() {
  _impl_._oneof_case_[0] = kMarketByOrderUpdate;
}
inline ::t4proto::v1::market::MarketByOrderUpdate* PROTOBUF_NULLABLE ServerMessage::release_market_by_order_update() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_by_order_update)
  if (payload_case() == kMarketByOrderUpdate) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::market::MarketByOrderUpdate*>(_impl_.payload_.market_by_order_update_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_by_order_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketByOrderUpdate& ServerMessage::_internal_market_by_order_update() const {
  return payload_case() == kMarketByOrderUpdate ? *reinterpret_cast<::t4proto::v1::market::MarketByOrderUpdate*>(_impl_.payload_.market_by_order_update_) : reinterpret_cast<::t4proto::v1::market::MarketByOrderUpdate&>(::t4proto::v1::market::_MarketByOrderUpdate_default_instance_);
}
inline const ::t4proto::v1::market::MarketByOrderUpdate& ServerMessage::market_by_order_update() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_by_order_update)
  return _internal_market_by_order_update();
}
inline ::t4proto::v1::market::MarketByOrderUpdate* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_market_by_order_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_by_order_update)
  if (payload_case() == kMarketByOrderUpdate) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::market::MarketByOrderUpdate*>(_impl_.payload_.market_by_order_update_);
    _impl_.payload_.market_by_order_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_by_order_update(
    ::t4proto::v1::market::MarketByOrderUpdate* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_market_by_order_update();
    _impl_.payload_.market_by_order_update_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_by_order_update)
}
inline ::t4proto::v1::market::MarketByOrderUpdate* PROTOBUF_NONNULL ServerMessage::_internal_mutable_market_by_order_update() {
  if (payload_case() != kMarketByOrderUpdate) {
    clear_payload();
    set_has_market_by_order_update();
    _impl_.payload_.market_by_order_update_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::market::MarketByOrderUpdate>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::market::MarketByOrderUpdate*>(_impl_.payload_.market_by_order_update_);
}
inline ::t4proto::v1::market::MarketByOrderUpdate* PROTOBUF_NONNULL ServerMessage::mutable_market_by_order_update()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::market::MarketByOrderUpdate* _msg = _internal_mutable_market_by_order_update();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_by_order_update)
  return _msg;
}

// .t4proto.v1.account.AccountSubscribeResponse account_subscribe_response = 200;
inline bool ServerMessage::has_account_subscribe_response() const {
  return payload_case() == kAccountSubscribeResponse;
}
inline bool ServerMessage::_internal_has_account_subscribe_response() const {
  return payload_case() == kAccountSubscribeResponse;
}
inline void ServerMessage::set_has_account_subscribe_response() {
  _impl_._oneof_case_[0] = kAccountSubscribeResponse;
}
inline ::t4proto::v1::account::AccountSubscribeResponse* PROTOBUF_NULLABLE ServerMessage::release_account_subscribe_response() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.account_subscribe_response)
  if (payload_case() == kAccountSubscribeResponse) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::account::AccountSubscribeResponse*>(_impl_.payload_.account_subscribe_response_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.account_subscribe_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::account::AccountSubscribeResponse& ServerMessage::_internal_account_subscribe_response() const {
  return payload_case() == kAccountSubscribeResponse ? *reinterpret_cast<::t4proto::v1::account::AccountSubscribeResponse*>(_impl_.payload_.account_subscribe_response_) : reinterpret_cast<::t4proto::v1::account::AccountSubscribeResponse&>(::t4proto::v1::account::_AccountSubscribeResponse_default_instance_);
}
inline const ::t4proto::v1::account::AccountSubscribeResponse& ServerMessage::account_subscribe_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.account_subscribe_response)
  return _internal_account_subscribe_response();
}
inline ::t4proto::v1::account::AccountSubscribeResponse* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_account_subscribe_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.account_subscribe_response)
  if (payload_case() == kAccountSubscribeResponse) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::account::AccountSubscribeResponse*>(_impl_.payload_.account_subscribe_response_);
    _impl_.payload_.account_subscribe_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_account_subscribe_response(
    ::t4proto::v1::account::AccountSubscribeResponse* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_account_subscribe_response();
    _impl_.payload_.account_subscribe_response_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.account_subscribe_response)
}
inline ::t4proto::v1::account::AccountSubscribeResponse* PROTOBUF_NONNULL ServerMessage::_internal_mutable_account_subscribe_response() {
  if (payload_case() != kAccountSubscribeResponse) {
    clear_payload();
    set_has_account_subscribe_response();
    _impl_.payload_.account_subscribe_response_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::account::AccountSubscribeResponse>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::account::AccountSubscribeResponse*>(_impl_.payload_.account_subscribe_response_);
}
inline ::t4proto::v1::account::AccountSubscribeResponse* PROTOBUF_NONNULL ServerMessage::mutable_account_subscribe_response()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::account::AccountSubscribeResponse* _msg = _internal_mutable_account_subscribe_response();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.account_subscribe_response)
  return _msg;
}

// .t4proto.v1.account.AccountCurrency account_currency = 201;
inline bool ServerMessage::has_account_currency() const {
  return payload_case() == kAccountCurrency;
}
inline bool ServerMessage::_internal_has_account_currency() const {
  return payload_case() == kAccountCurrency;
}
inline void ServerMessage::set_has_account_currency() {
  _impl_._oneof_case_[0] = kAccountCurrency;
}
inline ::t4proto::v1::account::AccountCurrency* PROTOBUF_NULLABLE ServerMessage::release_account_currency() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.account_currency)
  if (payload_case() == kAccountCurrency) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::account::AccountCurrency*>(_impl_.payload_.account_currency_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.account_currency_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::account::AccountCurrency& ServerMessage::_internal_account_currency() const {
  return payload_case() == kAccountCurrency ? *reinterpret_cast<::t4proto::v1::account::AccountCurrency*>(_impl_.payload_.account_currency_) : reinterpret_cast<::t4proto::v1::account::AccountCurrency&>(::t4proto::v1::account::_AccountCurrency_default_instance_);
}
inline const ::t4proto::v1::account::AccountCurrency& ServerMessage::account_currency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.account_currency)
  return _internal_account_currency();
}
inline ::t4proto::v1::account::AccountCurrency* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_account_currency() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.account_currency)
  if (payload_case() == kAccountCurrency) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::account::AccountCurrency*>(_impl_.payload_.account_currency_);
    _impl_.payload_.account_currency_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_account_currency(
    ::t4proto::v1::account::AccountCurrency* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_account_currency();
    _impl_.payload_.account_currency_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.account_currency)
}
inline ::t4proto::v1::account::AccountCurrency* PROTOBUF_NONNULL ServerMessage::_internal_mutable_account_currency() {
  if (payload_case() != kAccountCurrency) {
    clear_payload();
    set_has_account_currency();
    _impl_.payload_.account_currency_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::account::AccountCurrency>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::account::AccountCurrency*>(_impl_.payload_.account_currency_);
}
inline ::t4proto::v1::account::AccountCurrency* PROTOBUF_NONNULL ServerMessage::mutable_account_currency()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::account::AccountCurrency* _msg = _internal_mutable_account_currency();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.account_currency)
  return _msg;
}

// .t4proto.v1.account.AccountPosition account_position = 202;
inline bool ServerMessage::has_account_position() const {
  return payload_case() == kAccountPosition;
}
inline bool ServerMessage::_internal_has_account_position() const {
  return payload_case() == kAccountPosition;
}
inline void ServerMessage::set_has_account_position() {
  _impl_._oneof_case_[0] = kAccountPosition;
}
inline ::t4proto::v1::account::AccountPosition* PROTOBUF_NULLABLE ServerMessage::release_account_position() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.account_position)
  if (payload_case() == kAccountPosition) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::account::AccountPosition*>(_impl_.payload_.account_position_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.account_position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::account::AccountPosition& ServerMessage::_internal_account_position() const {
  return payload_case() == kAccountPosition ? *reinterpret_cast<::t4proto::v1::account::AccountPosition*>(_impl_.payload_.account_position_) : reinterpret_cast<::t4proto::v1::account::AccountPosition&>(::t4proto::v1::account::_AccountPosition_default_instance_);
}
inline const ::t4proto::v1::account::AccountPosition& ServerMessage::account_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.account_position)
  return _internal_account_position();
}
inline ::t4proto::v1::account::AccountPosition* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_account_position() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.account_position)
  if (payload_case() == kAccountPosition) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::account::AccountPosition*>(_impl_.payload_.account_position_);
    _impl_.payload_.account_position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_account_position(
    ::t4proto::v1::account::AccountPosition* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_account_position();
    _impl_.payload_.account_position_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.account_position)
}
inline ::t4proto::v1::account::AccountPosition* PROTOBUF_NONNULL ServerMessage::_internal_mutable_account_position() {
  if (payload_case() != kAccountPosition) {
    clear_payload();
    set_has_account_position();
    _impl_.payload_.account_position_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::account::AccountPosition>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::account::AccountPosition*>(_impl_.payload_.account_position_);
}
inline ::t4proto::v1::account::AccountPosition* PROTOBUF_NONNULL ServerMessage::mutable_account_position()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::account::AccountPosition* _msg = _internal_mutable_account_position();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.account_position)
  return _msg;
}

// .t4proto.v1.account.AccountUpdate account_update = 203;
inline bool ServerMessage::has_account_update() const {
  return payload_case() == kAccountUpdate;
}
inline bool ServerMessage::_internal_has_account_update() const {
  return payload_case() == kAccountUpdate;
}
inline void ServerMessage::set_has_account_update() {
  _impl_._oneof_case_[0] = kAccountUpdate;
}
inline ::t4proto::v1::account::AccountUpdate* PROTOBUF_NULLABLE ServerMessage::release_account_update() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.account_update)
  if (payload_case() == kAccountUpdate) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::account::AccountUpdate*>(_impl_.payload_.account_update_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.account_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::account::AccountUpdate& ServerMessage::_internal_account_update() const {
  return payload_case() == kAccountUpdate ? *reinterpret_cast<::t4proto::v1::account::AccountUpdate*>(_impl_.payload_.account_update_) : reinterpret_cast<::t4proto::v1::account::AccountUpdate&>(::t4proto::v1::account::_AccountUpdate_default_instance_);
}
inline const ::t4proto::v1::account::AccountUpdate& ServerMessage::account_update() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.account_update)
  return _internal_account_update();
}
inline ::t4proto::v1::account::AccountUpdate* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_account_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.account_update)
  if (payload_case() == kAccountUpdate) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::account::AccountUpdate*>(_impl_.payload_.account_update_);
    _impl_.payload_.account_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_account_update(
    ::t4proto::v1::account::AccountUpdate* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_account_update();
    _impl_.payload_.account_update_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.account_update)
}
inline ::t4proto::v1::account::AccountUpdate* PROTOBUF_NONNULL ServerMessage::_internal_mutable_account_update() {
  if (payload_case() != kAccountUpdate) {
    clear_payload();
    set_has_account_update();
    _impl_.payload_.account_update_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::account::AccountUpdate>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::account::AccountUpdate*>(_impl_.payload_.account_update_);
}
inline ::t4proto::v1::account::AccountUpdate* PROTOBUF_NONNULL ServerMessage::mutable_account_update()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::account::AccountUpdate* _msg = _internal_mutable_account_update();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.account_update)
  return _msg;
}

// .t4proto.v1.account.AccountDetails account_details = 204;
inline bool ServerMessage::has_account_details() const {
  return payload_case() == kAccountDetails;
}
inline bool ServerMessage::_internal_has_account_details() const {
  return payload_case() == kAccountDetails;
}
inline void ServerMessage::set_has_account_details() {
  _impl_._oneof_case_[0] = kAccountDetails;
}
inline ::t4proto::v1::account::AccountDetails* PROTOBUF_NULLABLE ServerMessage::release_account_details() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.account_details)
  if (payload_case() == kAccountDetails) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::account::AccountDetails*>(_impl_.payload_.account_details_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.account_details_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::account::AccountDetails& ServerMessage::_internal_account_details() const {
  return payload_case() == kAccountDetails ? *reinterpret_cast<::t4proto::v1::account::AccountDetails*>(_impl_.payload_.account_details_) : reinterpret_cast<::t4proto::v1::account::AccountDetails&>(::t4proto::v1::account::_AccountDetails_default_instance_);
}
inline const ::t4proto::v1::account::AccountDetails& ServerMessage::account_details() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.account_details)
  return _internal_account_details();
}
inline ::t4proto::v1::account::AccountDetails* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_account_details() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.account_details)
  if (payload_case() == kAccountDetails) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::account::AccountDetails*>(_impl_.payload_.account_details_);
    _impl_.payload_.account_details_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_account_details(
    ::t4proto::v1::account::AccountDetails* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_account_details();
    _impl_.payload_.account_details_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.account_details)
}
inline ::t4proto::v1::account::AccountDetails* PROTOBUF_NONNULL ServerMessage::_internal_mutable_account_details() {
  if (payload_case() != kAccountDetails) {
    clear_payload();
    set_has_account_details();
    _impl_.payload_.account_details_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::account::AccountDetails>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::account::AccountDetails*>(_impl_.payload_.account_details_);
}
inline ::t4proto::v1::account::AccountDetails* PROTOBUF_NONNULL ServerMessage::mutable_account_details()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::account::AccountDetails* _msg = _internal_mutable_account_details();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.account_details)
  return _msg;
}

// .t4proto.v1.account.AccountSnapshot account_snapshot = 205;
inline bool ServerMessage::has_account_snapshot() const {
  return payload_case() == kAccountSnapshot;
}
inline bool ServerMessage::_internal_has_account_snapshot() const {
  return payload_case() == kAccountSnapshot;
}
inline void ServerMessage::set_has_account_snapshot() {
  _impl_._oneof_case_[0] = kAccountSnapshot;
}
inline ::t4proto::v1::account::AccountSnapshot* PROTOBUF_NULLABLE ServerMessage::release_account_snapshot() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.account_snapshot)
  if (payload_case() == kAccountSnapshot) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::account::AccountSnapshot*>(_impl_.payload_.account_snapshot_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.account_snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::account::AccountSnapshot& ServerMessage::_internal_account_snapshot() const {
  return payload_case() == kAccountSnapshot ? *reinterpret_cast<::t4proto::v1::account::AccountSnapshot*>(_impl_.payload_.account_snapshot_) : reinterpret_cast<::t4proto::v1::account::AccountSnapshot&>(::t4proto::v1::account::_AccountSnapshot_default_instance_);
}
inline const ::t4proto::v1::account::AccountSnapshot& ServerMessage::account_snapshot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.account_snapshot)
  return _internal_account_snapshot();
}
inline ::t4proto::v1::account::AccountSnapshot* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_account_snapshot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.account_snapshot)
  if (payload_case() == kAccountSnapshot) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::account::AccountSnapshot*>(_impl_.payload_.account_snapshot_);
    _impl_.payload_.account_snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_account_snapshot(
    ::t4proto::v1::account::AccountSnapshot* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_account_snapshot();
    _impl_.payload_.account_snapshot_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.account_snapshot)
}
inline ::t4proto::v1::account::AccountSnapshot* PROTOBUF_NONNULL ServerMessage::_internal_mutable_account_snapshot() {
  if (payload_case() != kAccountSnapshot) {
    clear_payload();
    set_has_account_snapshot();
    _impl_.payload_.account_snapshot_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::account::AccountSnapshot>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::account::AccountSnapshot*>(_impl_.payload_.account_snapshot_);
}
inline ::t4proto::v1::account::AccountSnapshot* PROTOBUF_NONNULL ServerMessage::mutable_account_snapshot()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::account::AccountSnapshot* _msg = _internal_mutable_account_snapshot();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.account_snapshot)
  return _msg;
}

// .t4proto.v1.orderrouting.OrderUpdate order_update = 300;
inline bool ServerMessage::has_order_update() const {
  return payload_case() == kOrderUpdate;
}
inline bool ServerMessage::_internal_has_order_update() const {
  return payload_case() == kOrderUpdate;
}
inline void ServerMessage::set_has_order_update() {
  _impl_._oneof_case_[0] = kOrderUpdate;
}
inline ::t4proto::v1::orderrouting::OrderUpdate* PROTOBUF_NULLABLE ServerMessage::release_order_update() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.order_update)
  if (payload_case() == kOrderUpdate) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdate*>(_impl_.payload_.order_update_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.order_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::OrderUpdate& ServerMessage::_internal_order_update() const {
  return payload_case() == kOrderUpdate ? *reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdate*>(_impl_.payload_.order_update_) : reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdate&>(::t4proto::v1::orderrouting::_OrderUpdate_default_instance_);
}
inline const ::t4proto::v1::orderrouting::OrderUpdate& ServerMessage::order_update() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.order_update)
  return _internal_order_update();
}
inline ::t4proto::v1::orderrouting::OrderUpdate* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_order_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.order_update)
  if (payload_case() == kOrderUpdate) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdate*>(_impl_.payload_.order_update_);
    _impl_.payload_.order_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_order_update(
    ::t4proto::v1::orderrouting::OrderUpdate* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_order_update();
    _impl_.payload_.order_update_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.order_update)
}
inline ::t4proto::v1::orderrouting::OrderUpdate* PROTOBUF_NONNULL ServerMessage::_internal_mutable_order_update() {
  if (payload_case() != kOrderUpdate) {
    clear_payload();
    set_has_order_update();
    _impl_.payload_.order_update_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::orderrouting::OrderUpdate>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdate*>(_impl_.payload_.order_update_);
}
inline ::t4proto::v1::orderrouting::OrderUpdate* PROTOBUF_NONNULL ServerMessage::mutable_order_update()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::orderrouting::OrderUpdate* _msg = _internal_mutable_order_update();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.order_update)
  return _msg;
}

// .t4proto.v1.orderrouting.OrderUpdateMulti order_update_multi = 301;
inline bool ServerMessage::has_order_update_multi() const {
  return payload_case() == kOrderUpdateMulti;
}
inline bool ServerMessage::_internal_has_order_update_multi() const {
  return payload_case() == kOrderUpdateMulti;
}
inline void ServerMessage::set_has_order_update_multi() {
  _impl_._oneof_case_[0] = kOrderUpdateMulti;
}
inline ::t4proto::v1::orderrouting::OrderUpdateMulti* PROTOBUF_NULLABLE ServerMessage::release_order_update_multi() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.order_update_multi)
  if (payload_case() == kOrderUpdateMulti) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdateMulti*>(_impl_.payload_.order_update_multi_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.order_update_multi_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::OrderUpdateMulti& ServerMessage::_internal_order_update_multi() const {
  return payload_case() == kOrderUpdateMulti ? *reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdateMulti*>(_impl_.payload_.order_update_multi_) : reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdateMulti&>(::t4proto::v1::orderrouting::_OrderUpdateMulti_default_instance_);
}
inline const ::t4proto::v1::orderrouting::OrderUpdateMulti& ServerMessage::order_update_multi() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.order_update_multi)
  return _internal_order_update_multi();
}
inline ::t4proto::v1::orderrouting::OrderUpdateMulti* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_order_update_multi() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.order_update_multi)
  if (payload_case() == kOrderUpdateMulti) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdateMulti*>(_impl_.payload_.order_update_multi_);
    _impl_.payload_.order_update_multi_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_order_update_multi(
    ::t4proto::v1::orderrouting::OrderUpdateMulti* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_order_update_multi();
    _impl_.payload_.order_update_multi_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.order_update_multi)
}
inline ::t4proto::v1::orderrouting::OrderUpdateMulti* PROTOBUF_NONNULL ServerMessage::_internal_mutable_order_update_multi() {
  if (payload_case() != kOrderUpdateMulti) {
    clear_payload();
    set_has_order_update_multi();
    _impl_.payload_.order_update_multi_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::orderrouting::OrderUpdateMulti>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdateMulti*>(_impl_.payload_.order_update_multi_);
}
inline ::t4proto::v1::orderrouting::OrderUpdateMulti* PROTOBUF_NONNULL ServerMessage::mutable_order_update_multi()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::orderrouting::OrderUpdateMulti* _msg = _internal_mutable_order_update_multi();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.order_update_multi)
  return _msg;
}

// .t4proto.v1.orderrouting.OrderUpdateFailed order_update_failed = 302;
inline bool ServerMessage::has_order_update_failed() const {
  return payload_case() == kOrderUpdateFailed;
}
inline bool ServerMessage::_internal_has_order_update_failed() const {
  return payload_case() == kOrderUpdateFailed;
}
inline void ServerMessage::set_has_order_update_failed() {
  _impl_._oneof_case_[0] = kOrderUpdateFailed;
}
inline ::t4proto::v1::orderrouting::OrderUpdateFailed* PROTOBUF_NULLABLE ServerMessage::release_order_update_failed() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.order_update_failed)
  if (payload_case() == kOrderUpdateFailed) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdateFailed*>(_impl_.payload_.order_update_failed_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.order_update_failed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::OrderUpdateFailed& ServerMessage::_internal_order_update_failed() const {
  return payload_case() == kOrderUpdateFailed ? *reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdateFailed*>(_impl_.payload_.order_update_failed_) : reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdateFailed&>(::t4proto::v1::orderrouting::_OrderUpdateFailed_default_instance_);
}
inline const ::t4proto::v1::orderrouting::OrderUpdateFailed& ServerMessage::order_update_failed() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.order_update_failed)
  return _internal_order_update_failed();
}
inline ::t4proto::v1::orderrouting::OrderUpdateFailed* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_order_update_failed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.order_update_failed)
  if (payload_case() == kOrderUpdateFailed) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdateFailed*>(_impl_.payload_.order_update_failed_);
    _impl_.payload_.order_update_failed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_order_update_failed(
    ::t4proto::v1::orderrouting::OrderUpdateFailed* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_order_update_failed();
    _impl_.payload_.order_update_failed_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.order_update_failed)
}
inline ::t4proto::v1::orderrouting::OrderUpdateFailed* PROTOBUF_NONNULL ServerMessage::_internal_mutable_order_update_failed() {
  if (payload_case() != kOrderUpdateFailed) {
    clear_payload();
    set_has_order_update_failed();
    _impl_.payload_.order_update_failed_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::orderrouting::OrderUpdateFailed>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdateFailed*>(_impl_.payload_.order_update_failed_);
}
inline ::t4proto::v1::orderrouting::OrderUpdateFailed* PROTOBUF_NONNULL ServerMessage::mutable_order_update_failed()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::orderrouting::OrderUpdateFailed* _msg = _internal_mutable_order_update_failed();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.order_update_failed)
  return _msg;
}

// .t4proto.v1.orderrouting.OrderUpdateStatus order_update_status = 303;
inline bool ServerMessage::has_order_update_status() const {
  return payload_case() == kOrderUpdateStatus;
}
inline bool ServerMessage::_internal_has_order_update_status() const {
  return payload_case() == kOrderUpdateStatus;
}
inline void ServerMessage::set_has_order_update_status() {
  _impl_._oneof_case_[0] = kOrderUpdateStatus;
}
inline ::t4proto::v1::orderrouting::OrderUpdateStatus* PROTOBUF_NULLABLE ServerMessage::release_order_update_status() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.order_update_status)
  if (payload_case() == kOrderUpdateStatus) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdateStatus*>(_impl_.payload_.order_update_status_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.order_update_status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::OrderUpdateStatus& ServerMessage::_internal_order_update_status() const {
  return payload_case() == kOrderUpdateStatus ? *reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdateStatus*>(_impl_.payload_.order_update_status_) : reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdateStatus&>(::t4proto::v1::orderrouting::_OrderUpdateStatus_default_instance_);
}
inline const ::t4proto::v1::orderrouting::OrderUpdateStatus& ServerMessage::order_update_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.order_update_status)
  return _internal_order_update_status();
}
inline ::t4proto::v1::orderrouting::OrderUpdateStatus* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_order_update_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.order_update_status)
  if (payload_case() == kOrderUpdateStatus) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdateStatus*>(_impl_.payload_.order_update_status_);
    _impl_.payload_.order_update_status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_order_update_status(
    ::t4proto::v1::orderrouting::OrderUpdateStatus* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_order_update_status();
    _impl_.payload_.order_update_status_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.order_update_status)
}
inline ::t4proto::v1::orderrouting::OrderUpdateStatus* PROTOBUF_NONNULL ServerMessage::_internal_mutable_order_update_status() {
  if (payload_case() != kOrderUpdateStatus) {
    clear_payload();
    set_has_order_update_status();
    _impl_.payload_.order_update_status_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::orderrouting::OrderUpdateStatus>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdateStatus*>(_impl_.payload_.order_update_status_);
}
inline ::t4proto::v1::orderrouting::OrderUpdateStatus* PROTOBUF_NONNULL ServerMessage::mutable_order_update_status()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::orderrouting::OrderUpdateStatus* _msg = _internal_mutable_order_update_status();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.order_update_status)
  return _msg;
}

// .t4proto.v1.orderrouting.OrderUpdateTrade order_update_trade = 304;
inline bool ServerMessage::has_order_update_trade() const {
  return payload_case() == kOrderUpdateTrade;
}
inline bool ServerMessage::_internal_has_order_update_trade() const {
  return payload_case() == kOrderUpdateTrade;
}
inline void ServerMessage::set_has_order_update_trade() {
  _impl_._oneof_case_[0] = kOrderUpdateTrade;
}
inline ::t4proto::v1::orderrouting::OrderUpdateTrade* PROTOBUF_NULLABLE ServerMessage::release_order_update_trade() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.order_update_trade)
  if (payload_case() == kOrderUpdateTrade) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdateTrade*>(_impl_.payload_.order_update_trade_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.order_update_trade_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::OrderUpdateTrade& ServerMessage::_internal_order_update_trade() const {
  return payload_case() == kOrderUpdateTrade ? *reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdateTrade*>(_impl_.payload_.order_update_trade_) : reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdateTrade&>(::t4proto::v1::orderrouting::_OrderUpdateTrade_default_instance_);
}
inline const ::t4proto::v1::orderrouting::OrderUpdateTrade& ServerMessage::order_update_trade() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.order_update_trade)
  return _internal_order_update_trade();
}
inline ::t4proto::v1::orderrouting::OrderUpdateTrade* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_order_update_trade() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.order_update_trade)
  if (payload_case() == kOrderUpdateTrade) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdateTrade*>(_impl_.payload_.order_update_trade_);
    _impl_.payload_.order_update_trade_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_order_update_trade(
    ::t4proto::v1::orderrouting::OrderUpdateTrade* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_order_update_trade();
    _impl_.payload_.order_update_trade_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.order_update_trade)
}
inline ::t4proto::v1::orderrouting::OrderUpdateTrade* PROTOBUF_NONNULL ServerMessage::_internal_mutable_order_update_trade() {
  if (payload_case() != kOrderUpdateTrade) {
    clear_payload();
    set_has_order_update_trade();
    _impl_.payload_.order_update_trade_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::orderrouting::OrderUpdateTrade>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdateTrade*>(_impl_.payload_.order_update_trade_);
}
inline ::t4proto::v1::orderrouting::OrderUpdateTrade* PROTOBUF_NONNULL ServerMessage::mutable_order_update_trade()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::orderrouting::OrderUpdateTrade* _msg = _internal_mutable_order_update_trade();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.order_update_trade)
  return _msg;
}

// .t4proto.v1.orderrouting.OrderUpdateTradeLeg order_update_trade_leg = 305;
inline bool ServerMessage::has_order_update_trade_leg() const {
  return payload_case() == kOrderUpdateTradeLeg;
}
inline bool ServerMessage::_internal_has_order_update_trade_leg() const {
  return payload_case() == kOrderUpdateTradeLeg;
}
inline void ServerMessage::set_has_order_update_trade_leg() {
  _impl_._oneof_case_[0] = kOrderUpdateTradeLeg;
}
inline ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* PROTOBUF_NULLABLE ServerMessage::release_order_update_trade_leg() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.order_update_trade_leg)
  if (payload_case() == kOrderUpdateTradeLeg) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdateTradeLeg*>(_impl_.payload_.order_update_trade_leg_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.order_update_trade_leg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::OrderUpdateTradeLeg& ServerMessage::_internal_order_update_trade_leg() const {
  return payload_case() == kOrderUpdateTradeLeg ? *reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdateTradeLeg*>(_impl_.payload_.order_update_trade_leg_) : reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdateTradeLeg&>(::t4proto::v1::orderrouting::_OrderUpdateTradeLeg_default_instance_);
}
inline const ::t4proto::v1::orderrouting::OrderUpdateTradeLeg& ServerMessage::order_update_trade_leg() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.order_update_trade_leg)
  return _internal_order_update_trade_leg();
}
inline ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_order_update_trade_leg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.order_update_trade_leg)
  if (payload_case() == kOrderUpdateTradeLeg) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdateTradeLeg*>(_impl_.payload_.order_update_trade_leg_);
    _impl_.payload_.order_update_trade_leg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_order_update_trade_leg(
    ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_order_update_trade_leg();
    _impl_.payload_.order_update_trade_leg_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.order_update_trade_leg)
}
inline ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* PROTOBUF_NONNULL ServerMessage::_internal_mutable_order_update_trade_leg() {
  if (payload_case() != kOrderUpdateTradeLeg) {
    clear_payload();
    set_has_order_update_trade_leg();
    _impl_.payload_.order_update_trade_leg_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::orderrouting::OrderUpdateTradeLeg>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdateTradeLeg*>(_impl_.payload_.order_update_trade_leg_);
}
inline ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* PROTOBUF_NONNULL ServerMessage::mutable_order_update_trade_leg()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* _msg = _internal_mutable_order_update_trade_leg();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.order_update_trade_leg)
  return _msg;
}

// .t4proto.v1.orderrouting.CreateUDSResponse create_uds_response = 340;
inline bool ServerMessage::has_create_uds_response() const {
  return payload_case() == kCreateUdsResponse;
}
inline bool ServerMessage::_internal_has_create_uds_response() const {
  return payload_case() == kCreateUdsResponse;
}
inline void ServerMessage::set_has_create_uds_response() {
  _impl_._oneof_case_[0] = kCreateUdsResponse;
}
inline ::t4proto::v1::orderrouting::CreateUDSResponse* PROTOBUF_NULLABLE ServerMessage::release_create_uds_response() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.create_uds_response)
  if (payload_case() == kCreateUdsResponse) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::orderrouting::CreateUDSResponse*>(_impl_.payload_.create_uds_response_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.create_uds_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::CreateUDSResponse& ServerMessage::_internal_create_uds_response() const {
  return payload_case() == kCreateUdsResponse ? *reinterpret_cast<::t4proto::v1::orderrouting::CreateUDSResponse*>(_impl_.payload_.create_uds_response_) : reinterpret_cast<::t4proto::v1::orderrouting::CreateUDSResponse&>(::t4proto::v1::orderrouting::_CreateUDSResponse_default_instance_);
}
inline const ::t4proto::v1::orderrouting::CreateUDSResponse& ServerMessage::create_uds_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.create_uds_response)
  return _internal_create_uds_response();
}
inline ::t4proto::v1::orderrouting::CreateUDSResponse* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_create_uds_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.create_uds_response)
  if (payload_case() == kCreateUdsResponse) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::t4proto::v1::orderrouting::CreateUDSResponse*>(_impl_.payload_.create_uds_response_);
    _impl_.payload_.create_uds_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_create_uds_response(
    ::t4proto::v1::orderrouting::CreateUDSResponse* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_create_uds_response();
    _impl_.payload_.create_uds_response_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.create_uds_response)
}
inline ::t4proto::v1::orderrouting::CreateUDSResponse* PROTOBUF_NONNULL ServerMessage::_internal_mutable_create_uds_response() {
  if (payload_case() != kCreateUdsResponse) {
    clear_payload();
    set_has_create_uds_response();
    _impl_.payload_.create_uds_response_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::orderrouting::CreateUDSResponse>(GetArena()));
  }
  return reinterpret_cast<::t4proto::v1::orderrouting::CreateUDSResponse*>(_impl_.payload_.create_uds_response_);
}
inline ::t4proto::v1::orderrouting::CreateUDSResponse* PROTOBUF_NONNULL ServerMessage::mutable_create_uds_response()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::orderrouting::CreateUDSResponse* _msg = _internal_mutable_create_uds_response();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.create_uds_response)
  return _msg;
}

inline bool ServerMessage::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void ServerMessage::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline ServerMessage::PayloadCase ServerMessage::payload_case() const {
  return ServerMessage::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Heartbeat

// int64 timestamp = 1;
inline void Heartbeat::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t Heartbeat::timestamp() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.Heartbeat.timestamp)
  return _internal_timestamp();
}
inline void Heartbeat::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:t4proto.v1.service.Heartbeat.timestamp)
}
inline ::int64_t Heartbeat::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_;
}
inline void Heartbeat::_internal_set_timestamp(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace service
}  // namespace v1
}  // namespace t4proto


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // t4_2fv1_2fservice_2eproto_2epb_2eh
