// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: t4/v1/service.proto
// Protobuf C++ Version: 5.29.3

#ifndef t4_2fv1_2fservice_2eproto_2epb_2eh
#define t4_2fv1_2fservice_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "t4/v1/auth/auth.pb.h"
#include "t4/v1/market/market.pb.h"
#include "t4/v1/account/account.pb.h"
#include "t4/v1/orderrouting/orderrouting.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_t4_2fv1_2fservice_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_t4_2fv1_2fservice_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_t4_2fv1_2fservice_2eproto;
namespace t4proto {
namespace v1 {
namespace service {
class ClientMessage;
struct ClientMessageDefaultTypeInternal;
extern ClientMessageDefaultTypeInternal _ClientMessage_default_instance_;
class Heartbeat;
struct HeartbeatDefaultTypeInternal;
extern HeartbeatDefaultTypeInternal _Heartbeat_default_instance_;
class ServerMessage;
struct ServerMessageDefaultTypeInternal;
extern ServerMessageDefaultTypeInternal _ServerMessage_default_instance_;
}  // namespace service
}  // namespace v1
}  // namespace t4proto
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace t4proto {
namespace v1 {
namespace service {

// ===================================================================


// -------------------------------------------------------------------

class Heartbeat final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:t4proto.v1.service.Heartbeat) */ {
 public:
  inline Heartbeat() : Heartbeat(nullptr) {}
  ~Heartbeat() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Heartbeat* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Heartbeat));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Heartbeat(
      ::google::protobuf::internal::ConstantInitialized);

  inline Heartbeat(const Heartbeat& from) : Heartbeat(nullptr, from) {}
  inline Heartbeat(Heartbeat&& from) noexcept
      : Heartbeat(nullptr, std::move(from)) {}
  inline Heartbeat& operator=(const Heartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Heartbeat& operator=(Heartbeat&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Heartbeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Heartbeat* internal_default_instance() {
    return reinterpret_cast<const Heartbeat*>(
        &_Heartbeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Heartbeat& a, Heartbeat& b) { a.Swap(&b); }
  inline void Swap(Heartbeat* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Heartbeat* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Heartbeat* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Heartbeat>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Heartbeat& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Heartbeat& from) { Heartbeat::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Heartbeat* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "t4proto.v1.service.Heartbeat"; }

 protected:
  explicit Heartbeat(::google::protobuf::Arena* arena);
  Heartbeat(::google::protobuf::Arena* arena, const Heartbeat& from);
  Heartbeat(::google::protobuf::Arena* arena, Heartbeat&& from) noexcept
      : Heartbeat(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTimestampFieldNumber = 1,
  };
  // int64 timestamp = 1;
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:t4proto.v1.service.Heartbeat)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Heartbeat& from_msg);
    ::int64_t timestamp_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t4_2fv1_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ClientMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:t4proto.v1.service.ClientMessage) */ {
 public:
  inline ClientMessage() : ClientMessage(nullptr) {}
  ~ClientMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ClientMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ClientMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ClientMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline ClientMessage(const ClientMessage& from) : ClientMessage(nullptr, from) {}
  inline ClientMessage(ClientMessage&& from) noexcept
      : ClientMessage(nullptr, std::move(from)) {}
  inline ClientMessage& operator=(const ClientMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientMessage& operator=(ClientMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientMessage& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kHeartbeat = 1,
    kLoginRequest = 2,
    kAuthenticationTokenRequest = 3,
    kMarketDepthSubscribe = 100,
    kMarketByOrderSubscribe = 101,
    kAccountSubscribe = 200,
    kOrderSubmit = 300,
    kOrderRevise = 301,
    kOrderPull = 302,
    kCreateUds = 340,
    PAYLOAD_NOT_SET = 0,
  };
  static inline const ClientMessage* internal_default_instance() {
    return reinterpret_cast<const ClientMessage*>(
        &_ClientMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(ClientMessage& a, ClientMessage& b) { a.Swap(&b); }
  inline void Swap(ClientMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ClientMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ClientMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ClientMessage& from) { ClientMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ClientMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "t4proto.v1.service.ClientMessage"; }

 protected:
  explicit ClientMessage(::google::protobuf::Arena* arena);
  ClientMessage(::google::protobuf::Arena* arena, const ClientMessage& from);
  ClientMessage(::google::protobuf::Arena* arena, ClientMessage&& from) noexcept
      : ClientMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHeartbeatFieldNumber = 1,
    kLoginRequestFieldNumber = 2,
    kAuthenticationTokenRequestFieldNumber = 3,
    kMarketDepthSubscribeFieldNumber = 100,
    kMarketByOrderSubscribeFieldNumber = 101,
    kAccountSubscribeFieldNumber = 200,
    kOrderSubmitFieldNumber = 300,
    kOrderReviseFieldNumber = 301,
    kOrderPullFieldNumber = 302,
    kCreateUdsFieldNumber = 340,
  };
  // .t4proto.v1.service.Heartbeat heartbeat = 1;
  bool has_heartbeat() const;
  private:
  bool _internal_has_heartbeat() const;

  public:
  void clear_heartbeat() ;
  const ::t4proto::v1::service::Heartbeat& heartbeat() const;
  PROTOBUF_NODISCARD ::t4proto::v1::service::Heartbeat* release_heartbeat();
  ::t4proto::v1::service::Heartbeat* mutable_heartbeat();
  void set_allocated_heartbeat(::t4proto::v1::service::Heartbeat* value);
  void unsafe_arena_set_allocated_heartbeat(::t4proto::v1::service::Heartbeat* value);
  ::t4proto::v1::service::Heartbeat* unsafe_arena_release_heartbeat();

  private:
  const ::t4proto::v1::service::Heartbeat& _internal_heartbeat() const;
  ::t4proto::v1::service::Heartbeat* _internal_mutable_heartbeat();

  public:
  // .t4proto.v1.auth.LoginRequest login_request = 2;
  bool has_login_request() const;
  private:
  bool _internal_has_login_request() const;

  public:
  void clear_login_request() ;
  const ::t4proto::v1::auth::LoginRequest& login_request() const;
  PROTOBUF_NODISCARD ::t4proto::v1::auth::LoginRequest* release_login_request();
  ::t4proto::v1::auth::LoginRequest* mutable_login_request();
  void set_allocated_login_request(::t4proto::v1::auth::LoginRequest* value);
  void unsafe_arena_set_allocated_login_request(::t4proto::v1::auth::LoginRequest* value);
  ::t4proto::v1::auth::LoginRequest* unsafe_arena_release_login_request();

  private:
  const ::t4proto::v1::auth::LoginRequest& _internal_login_request() const;
  ::t4proto::v1::auth::LoginRequest* _internal_mutable_login_request();

  public:
  // .t4proto.v1.auth.AuthenticationTokenRequest authentication_token_request = 3;
  bool has_authentication_token_request() const;
  private:
  bool _internal_has_authentication_token_request() const;

  public:
  void clear_authentication_token_request() ;
  const ::t4proto::v1::auth::AuthenticationTokenRequest& authentication_token_request() const;
  PROTOBUF_NODISCARD ::t4proto::v1::auth::AuthenticationTokenRequest* release_authentication_token_request();
  ::t4proto::v1::auth::AuthenticationTokenRequest* mutable_authentication_token_request();
  void set_allocated_authentication_token_request(::t4proto::v1::auth::AuthenticationTokenRequest* value);
  void unsafe_arena_set_allocated_authentication_token_request(::t4proto::v1::auth::AuthenticationTokenRequest* value);
  ::t4proto::v1::auth::AuthenticationTokenRequest* unsafe_arena_release_authentication_token_request();

  private:
  const ::t4proto::v1::auth::AuthenticationTokenRequest& _internal_authentication_token_request() const;
  ::t4proto::v1::auth::AuthenticationTokenRequest* _internal_mutable_authentication_token_request();

  public:
  // .t4proto.v1.market.MarketDepthSubscribe market_depth_subscribe = 100;
  bool has_market_depth_subscribe() const;
  private:
  bool _internal_has_market_depth_subscribe() const;

  public:
  void clear_market_depth_subscribe() ;
  const ::t4proto::v1::market::MarketDepthSubscribe& market_depth_subscribe() const;
  PROTOBUF_NODISCARD ::t4proto::v1::market::MarketDepthSubscribe* release_market_depth_subscribe();
  ::t4proto::v1::market::MarketDepthSubscribe* mutable_market_depth_subscribe();
  void set_allocated_market_depth_subscribe(::t4proto::v1::market::MarketDepthSubscribe* value);
  void unsafe_arena_set_allocated_market_depth_subscribe(::t4proto::v1::market::MarketDepthSubscribe* value);
  ::t4proto::v1::market::MarketDepthSubscribe* unsafe_arena_release_market_depth_subscribe();

  private:
  const ::t4proto::v1::market::MarketDepthSubscribe& _internal_market_depth_subscribe() const;
  ::t4proto::v1::market::MarketDepthSubscribe* _internal_mutable_market_depth_subscribe();

  public:
  // .t4proto.v1.market.MarketByOrderSubscribe market_by_order_subscribe = 101;
  bool has_market_by_order_subscribe() const;
  private:
  bool _internal_has_market_by_order_subscribe() const;

  public:
  void clear_market_by_order_subscribe() ;
  const ::t4proto::v1::market::MarketByOrderSubscribe& market_by_order_subscribe() const;
  PROTOBUF_NODISCARD ::t4proto::v1::market::MarketByOrderSubscribe* release_market_by_order_subscribe();
  ::t4proto::v1::market::MarketByOrderSubscribe* mutable_market_by_order_subscribe();
  void set_allocated_market_by_order_subscribe(::t4proto::v1::market::MarketByOrderSubscribe* value);
  void unsafe_arena_set_allocated_market_by_order_subscribe(::t4proto::v1::market::MarketByOrderSubscribe* value);
  ::t4proto::v1::market::MarketByOrderSubscribe* unsafe_arena_release_market_by_order_subscribe();

  private:
  const ::t4proto::v1::market::MarketByOrderSubscribe& _internal_market_by_order_subscribe() const;
  ::t4proto::v1::market::MarketByOrderSubscribe* _internal_mutable_market_by_order_subscribe();

  public:
  // .t4proto.v1.account.AccountSubscribe account_subscribe = 200;
  bool has_account_subscribe() const;
  private:
  bool _internal_has_account_subscribe() const;

  public:
  void clear_account_subscribe() ;
  const ::t4proto::v1::account::AccountSubscribe& account_subscribe() const;
  PROTOBUF_NODISCARD ::t4proto::v1::account::AccountSubscribe* release_account_subscribe();
  ::t4proto::v1::account::AccountSubscribe* mutable_account_subscribe();
  void set_allocated_account_subscribe(::t4proto::v1::account::AccountSubscribe* value);
  void unsafe_arena_set_allocated_account_subscribe(::t4proto::v1::account::AccountSubscribe* value);
  ::t4proto::v1::account::AccountSubscribe* unsafe_arena_release_account_subscribe();

  private:
  const ::t4proto::v1::account::AccountSubscribe& _internal_account_subscribe() const;
  ::t4proto::v1::account::AccountSubscribe* _internal_mutable_account_subscribe();

  public:
  // .t4proto.v1.orderrouting.OrderSubmit order_submit = 300;
  bool has_order_submit() const;
  private:
  bool _internal_has_order_submit() const;

  public:
  void clear_order_submit() ;
  const ::t4proto::v1::orderrouting::OrderSubmit& order_submit() const;
  PROTOBUF_NODISCARD ::t4proto::v1::orderrouting::OrderSubmit* release_order_submit();
  ::t4proto::v1::orderrouting::OrderSubmit* mutable_order_submit();
  void set_allocated_order_submit(::t4proto::v1::orderrouting::OrderSubmit* value);
  void unsafe_arena_set_allocated_order_submit(::t4proto::v1::orderrouting::OrderSubmit* value);
  ::t4proto::v1::orderrouting::OrderSubmit* unsafe_arena_release_order_submit();

  private:
  const ::t4proto::v1::orderrouting::OrderSubmit& _internal_order_submit() const;
  ::t4proto::v1::orderrouting::OrderSubmit* _internal_mutable_order_submit();

  public:
  // .t4proto.v1.orderrouting.OrderRevise order_revise = 301;
  bool has_order_revise() const;
  private:
  bool _internal_has_order_revise() const;

  public:
  void clear_order_revise() ;
  const ::t4proto::v1::orderrouting::OrderRevise& order_revise() const;
  PROTOBUF_NODISCARD ::t4proto::v1::orderrouting::OrderRevise* release_order_revise();
  ::t4proto::v1::orderrouting::OrderRevise* mutable_order_revise();
  void set_allocated_order_revise(::t4proto::v1::orderrouting::OrderRevise* value);
  void unsafe_arena_set_allocated_order_revise(::t4proto::v1::orderrouting::OrderRevise* value);
  ::t4proto::v1::orderrouting::OrderRevise* unsafe_arena_release_order_revise();

  private:
  const ::t4proto::v1::orderrouting::OrderRevise& _internal_order_revise() const;
  ::t4proto::v1::orderrouting::OrderRevise* _internal_mutable_order_revise();

  public:
  // .t4proto.v1.orderrouting.OrderPull order_pull = 302;
  bool has_order_pull() const;
  private:
  bool _internal_has_order_pull() const;

  public:
  void clear_order_pull() ;
  const ::t4proto::v1::orderrouting::OrderPull& order_pull() const;
  PROTOBUF_NODISCARD ::t4proto::v1::orderrouting::OrderPull* release_order_pull();
  ::t4proto::v1::orderrouting::OrderPull* mutable_order_pull();
  void set_allocated_order_pull(::t4proto::v1::orderrouting::OrderPull* value);
  void unsafe_arena_set_allocated_order_pull(::t4proto::v1::orderrouting::OrderPull* value);
  ::t4proto::v1::orderrouting::OrderPull* unsafe_arena_release_order_pull();

  private:
  const ::t4proto::v1::orderrouting::OrderPull& _internal_order_pull() const;
  ::t4proto::v1::orderrouting::OrderPull* _internal_mutable_order_pull();

  public:
  // .t4proto.v1.orderrouting.CreateUDS create_uds = 340;
  bool has_create_uds() const;
  private:
  bool _internal_has_create_uds() const;

  public:
  void clear_create_uds() ;
  const ::t4proto::v1::orderrouting::CreateUDS& create_uds() const;
  PROTOBUF_NODISCARD ::t4proto::v1::orderrouting::CreateUDS* release_create_uds();
  ::t4proto::v1::orderrouting::CreateUDS* mutable_create_uds();
  void set_allocated_create_uds(::t4proto::v1::orderrouting::CreateUDS* value);
  void unsafe_arena_set_allocated_create_uds(::t4proto::v1::orderrouting::CreateUDS* value);
  ::t4proto::v1::orderrouting::CreateUDS* unsafe_arena_release_create_uds();

  private:
  const ::t4proto::v1::orderrouting::CreateUDS& _internal_create_uds() const;
  ::t4proto::v1::orderrouting::CreateUDS* _internal_mutable_create_uds();

  public:
  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:t4proto.v1.service.ClientMessage)
 private:
  class _Internal;
  void set_has_heartbeat();
  void set_has_login_request();
  void set_has_authentication_token_request();
  void set_has_market_depth_subscribe();
  void set_has_market_by_order_subscribe();
  void set_has_account_subscribe();
  void set_has_order_submit();
  void set_has_order_revise();
  void set_has_order_pull();
  void set_has_create_uds();
  inline bool has_payload() const;
  inline void clear_has_payload();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 10, 10,
      0, 21>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ClientMessage& from_msg);
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::t4proto::v1::service::Heartbeat* heartbeat_;
      ::t4proto::v1::auth::LoginRequest* login_request_;
      ::t4proto::v1::auth::AuthenticationTokenRequest* authentication_token_request_;
      ::t4proto::v1::market::MarketDepthSubscribe* market_depth_subscribe_;
      ::t4proto::v1::market::MarketByOrderSubscribe* market_by_order_subscribe_;
      ::t4proto::v1::account::AccountSubscribe* account_subscribe_;
      ::t4proto::v1::orderrouting::OrderSubmit* order_submit_;
      ::t4proto::v1::orderrouting::OrderRevise* order_revise_;
      ::t4proto::v1::orderrouting::OrderPull* order_pull_;
      ::t4proto::v1::orderrouting::CreateUDS* create_uds_;
    } payload_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t4_2fv1_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ServerMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:t4proto.v1.service.ServerMessage) */ {
 public:
  inline ServerMessage() : ServerMessage(nullptr) {}
  ~ServerMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ServerMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ServerMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ServerMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline ServerMessage(const ServerMessage& from) : ServerMessage(nullptr, from) {}
  inline ServerMessage(ServerMessage&& from) noexcept
      : ServerMessage(nullptr, std::move(from)) {}
  inline ServerMessage& operator=(const ServerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerMessage& operator=(ServerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerMessage& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kHeartbeat = 1,
    kLoginResponse = 2,
    kAuthenticationToken = 3,
    kMarketDepthSubscribeReject = 100,
    kMarketByOrderSubscribeReject = 101,
    kMarketDetails = 102,
    kMarketDepth = 103,
    kMarketDepthTrade = 104,
    kMarketHighLow = 105,
    kMarketPriceLimits = 106,
    kMarketSettlement = 107,
    kMarketSnapshot = 108,
    kMarketByOrderSnapshot = 109,
    kMarketByOrderUpdate = 110,
    kAccountSubscribeResponse = 200,
    kAccountCurrency = 201,
    kAccountPosition = 202,
    kAccountUpdate = 203,
    kAccountDetails = 204,
    kAccountSnapshot = 205,
    kAccountProfit = 206,
    kAccountPositionProfit = 207,
    kOrderUpdate = 300,
    kOrderUpdateMulti = 301,
    kOrderUpdateFailed = 302,
    kOrderUpdateStatus = 303,
    kOrderUpdateTrade = 304,
    kOrderUpdateTradeLeg = 305,
    kCreateUdsResponse = 340,
    PAYLOAD_NOT_SET = 0,
  };
  static inline const ServerMessage* internal_default_instance() {
    return reinterpret_cast<const ServerMessage*>(
        &_ServerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(ServerMessage& a, ServerMessage& b) { a.Swap(&b); }
  inline void Swap(ServerMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ServerMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ServerMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ServerMessage& from) { ServerMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ServerMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "t4proto.v1.service.ServerMessage"; }

 protected:
  explicit ServerMessage(::google::protobuf::Arena* arena);
  ServerMessage(::google::protobuf::Arena* arena, const ServerMessage& from);
  ServerMessage(::google::protobuf::Arena* arena, ServerMessage&& from) noexcept
      : ServerMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHeartbeatFieldNumber = 1,
    kLoginResponseFieldNumber = 2,
    kAuthenticationTokenFieldNumber = 3,
    kMarketDepthSubscribeRejectFieldNumber = 100,
    kMarketByOrderSubscribeRejectFieldNumber = 101,
    kMarketDetailsFieldNumber = 102,
    kMarketDepthFieldNumber = 103,
    kMarketDepthTradeFieldNumber = 104,
    kMarketHighLowFieldNumber = 105,
    kMarketPriceLimitsFieldNumber = 106,
    kMarketSettlementFieldNumber = 107,
    kMarketSnapshotFieldNumber = 108,
    kMarketByOrderSnapshotFieldNumber = 109,
    kMarketByOrderUpdateFieldNumber = 110,
    kAccountSubscribeResponseFieldNumber = 200,
    kAccountCurrencyFieldNumber = 201,
    kAccountPositionFieldNumber = 202,
    kAccountUpdateFieldNumber = 203,
    kAccountDetailsFieldNumber = 204,
    kAccountSnapshotFieldNumber = 205,
    kAccountProfitFieldNumber = 206,
    kAccountPositionProfitFieldNumber = 207,
    kOrderUpdateFieldNumber = 300,
    kOrderUpdateMultiFieldNumber = 301,
    kOrderUpdateFailedFieldNumber = 302,
    kOrderUpdateStatusFieldNumber = 303,
    kOrderUpdateTradeFieldNumber = 304,
    kOrderUpdateTradeLegFieldNumber = 305,
    kCreateUdsResponseFieldNumber = 340,
  };
  // .t4proto.v1.service.Heartbeat heartbeat = 1;
  bool has_heartbeat() const;
  private:
  bool _internal_has_heartbeat() const;

  public:
  void clear_heartbeat() ;
  const ::t4proto::v1::service::Heartbeat& heartbeat() const;
  PROTOBUF_NODISCARD ::t4proto::v1::service::Heartbeat* release_heartbeat();
  ::t4proto::v1::service::Heartbeat* mutable_heartbeat();
  void set_allocated_heartbeat(::t4proto::v1::service::Heartbeat* value);
  void unsafe_arena_set_allocated_heartbeat(::t4proto::v1::service::Heartbeat* value);
  ::t4proto::v1::service::Heartbeat* unsafe_arena_release_heartbeat();

  private:
  const ::t4proto::v1::service::Heartbeat& _internal_heartbeat() const;
  ::t4proto::v1::service::Heartbeat* _internal_mutable_heartbeat();

  public:
  // .t4proto.v1.auth.LoginResponse login_response = 2;
  bool has_login_response() const;
  private:
  bool _internal_has_login_response() const;

  public:
  void clear_login_response() ;
  const ::t4proto::v1::auth::LoginResponse& login_response() const;
  PROTOBUF_NODISCARD ::t4proto::v1::auth::LoginResponse* release_login_response();
  ::t4proto::v1::auth::LoginResponse* mutable_login_response();
  void set_allocated_login_response(::t4proto::v1::auth::LoginResponse* value);
  void unsafe_arena_set_allocated_login_response(::t4proto::v1::auth::LoginResponse* value);
  ::t4proto::v1::auth::LoginResponse* unsafe_arena_release_login_response();

  private:
  const ::t4proto::v1::auth::LoginResponse& _internal_login_response() const;
  ::t4proto::v1::auth::LoginResponse* _internal_mutable_login_response();

  public:
  // .t4proto.v1.auth.AuthenticationToken authentication_token = 3;
  bool has_authentication_token() const;
  private:
  bool _internal_has_authentication_token() const;

  public:
  void clear_authentication_token() ;
  const ::t4proto::v1::auth::AuthenticationToken& authentication_token() const;
  PROTOBUF_NODISCARD ::t4proto::v1::auth::AuthenticationToken* release_authentication_token();
  ::t4proto::v1::auth::AuthenticationToken* mutable_authentication_token();
  void set_allocated_authentication_token(::t4proto::v1::auth::AuthenticationToken* value);
  void unsafe_arena_set_allocated_authentication_token(::t4proto::v1::auth::AuthenticationToken* value);
  ::t4proto::v1::auth::AuthenticationToken* unsafe_arena_release_authentication_token();

  private:
  const ::t4proto::v1::auth::AuthenticationToken& _internal_authentication_token() const;
  ::t4proto::v1::auth::AuthenticationToken* _internal_mutable_authentication_token();

  public:
  // .t4proto.v1.market.MarketDepthSubscribeReject market_depth_subscribe_reject = 100;
  bool has_market_depth_subscribe_reject() const;
  private:
  bool _internal_has_market_depth_subscribe_reject() const;

  public:
  void clear_market_depth_subscribe_reject() ;
  const ::t4proto::v1::market::MarketDepthSubscribeReject& market_depth_subscribe_reject() const;
  PROTOBUF_NODISCARD ::t4proto::v1::market::MarketDepthSubscribeReject* release_market_depth_subscribe_reject();
  ::t4proto::v1::market::MarketDepthSubscribeReject* mutable_market_depth_subscribe_reject();
  void set_allocated_market_depth_subscribe_reject(::t4proto::v1::market::MarketDepthSubscribeReject* value);
  void unsafe_arena_set_allocated_market_depth_subscribe_reject(::t4proto::v1::market::MarketDepthSubscribeReject* value);
  ::t4proto::v1::market::MarketDepthSubscribeReject* unsafe_arena_release_market_depth_subscribe_reject();

  private:
  const ::t4proto::v1::market::MarketDepthSubscribeReject& _internal_market_depth_subscribe_reject() const;
  ::t4proto::v1::market::MarketDepthSubscribeReject* _internal_mutable_market_depth_subscribe_reject();

  public:
  // .t4proto.v1.market.MarketByOrderSubscribeReject market_by_order_subscribe_reject = 101;
  bool has_market_by_order_subscribe_reject() const;
  private:
  bool _internal_has_market_by_order_subscribe_reject() const;

  public:
  void clear_market_by_order_subscribe_reject() ;
  const ::t4proto::v1::market::MarketByOrderSubscribeReject& market_by_order_subscribe_reject() const;
  PROTOBUF_NODISCARD ::t4proto::v1::market::MarketByOrderSubscribeReject* release_market_by_order_subscribe_reject();
  ::t4proto::v1::market::MarketByOrderSubscribeReject* mutable_market_by_order_subscribe_reject();
  void set_allocated_market_by_order_subscribe_reject(::t4proto::v1::market::MarketByOrderSubscribeReject* value);
  void unsafe_arena_set_allocated_market_by_order_subscribe_reject(::t4proto::v1::market::MarketByOrderSubscribeReject* value);
  ::t4proto::v1::market::MarketByOrderSubscribeReject* unsafe_arena_release_market_by_order_subscribe_reject();

  private:
  const ::t4proto::v1::market::MarketByOrderSubscribeReject& _internal_market_by_order_subscribe_reject() const;
  ::t4proto::v1::market::MarketByOrderSubscribeReject* _internal_mutable_market_by_order_subscribe_reject();

  public:
  // .t4proto.v1.market.MarketDetails market_details = 102;
  bool has_market_details() const;
  private:
  bool _internal_has_market_details() const;

  public:
  void clear_market_details() ;
  const ::t4proto::v1::market::MarketDetails& market_details() const;
  PROTOBUF_NODISCARD ::t4proto::v1::market::MarketDetails* release_market_details();
  ::t4proto::v1::market::MarketDetails* mutable_market_details();
  void set_allocated_market_details(::t4proto::v1::market::MarketDetails* value);
  void unsafe_arena_set_allocated_market_details(::t4proto::v1::market::MarketDetails* value);
  ::t4proto::v1::market::MarketDetails* unsafe_arena_release_market_details();

  private:
  const ::t4proto::v1::market::MarketDetails& _internal_market_details() const;
  ::t4proto::v1::market::MarketDetails* _internal_mutable_market_details();

  public:
  // .t4proto.v1.market.MarketDepth market_depth = 103;
  bool has_market_depth() const;
  private:
  bool _internal_has_market_depth() const;

  public:
  void clear_market_depth() ;
  const ::t4proto::v1::market::MarketDepth& market_depth() const;
  PROTOBUF_NODISCARD ::t4proto::v1::market::MarketDepth* release_market_depth();
  ::t4proto::v1::market::MarketDepth* mutable_market_depth();
  void set_allocated_market_depth(::t4proto::v1::market::MarketDepth* value);
  void unsafe_arena_set_allocated_market_depth(::t4proto::v1::market::MarketDepth* value);
  ::t4proto::v1::market::MarketDepth* unsafe_arena_release_market_depth();

  private:
  const ::t4proto::v1::market::MarketDepth& _internal_market_depth() const;
  ::t4proto::v1::market::MarketDepth* _internal_mutable_market_depth();

  public:
  // .t4proto.v1.market.MarketDepthTrade market_depth_trade = 104;
  bool has_market_depth_trade() const;
  private:
  bool _internal_has_market_depth_trade() const;

  public:
  void clear_market_depth_trade() ;
  const ::t4proto::v1::market::MarketDepthTrade& market_depth_trade() const;
  PROTOBUF_NODISCARD ::t4proto::v1::market::MarketDepthTrade* release_market_depth_trade();
  ::t4proto::v1::market::MarketDepthTrade* mutable_market_depth_trade();
  void set_allocated_market_depth_trade(::t4proto::v1::market::MarketDepthTrade* value);
  void unsafe_arena_set_allocated_market_depth_trade(::t4proto::v1::market::MarketDepthTrade* value);
  ::t4proto::v1::market::MarketDepthTrade* unsafe_arena_release_market_depth_trade();

  private:
  const ::t4proto::v1::market::MarketDepthTrade& _internal_market_depth_trade() const;
  ::t4proto::v1::market::MarketDepthTrade* _internal_mutable_market_depth_trade();

  public:
  // .t4proto.v1.market.MarketHighLow market_high_low = 105;
  bool has_market_high_low() const;
  private:
  bool _internal_has_market_high_low() const;

  public:
  void clear_market_high_low() ;
  const ::t4proto::v1::market::MarketHighLow& market_high_low() const;
  PROTOBUF_NODISCARD ::t4proto::v1::market::MarketHighLow* release_market_high_low();
  ::t4proto::v1::market::MarketHighLow* mutable_market_high_low();
  void set_allocated_market_high_low(::t4proto::v1::market::MarketHighLow* value);
  void unsafe_arena_set_allocated_market_high_low(::t4proto::v1::market::MarketHighLow* value);
  ::t4proto::v1::market::MarketHighLow* unsafe_arena_release_market_high_low();

  private:
  const ::t4proto::v1::market::MarketHighLow& _internal_market_high_low() const;
  ::t4proto::v1::market::MarketHighLow* _internal_mutable_market_high_low();

  public:
  // .t4proto.v1.market.MarketPriceLimits market_price_limits = 106;
  bool has_market_price_limits() const;
  private:
  bool _internal_has_market_price_limits() const;

  public:
  void clear_market_price_limits() ;
  const ::t4proto::v1::market::MarketPriceLimits& market_price_limits() const;
  PROTOBUF_NODISCARD ::t4proto::v1::market::MarketPriceLimits* release_market_price_limits();
  ::t4proto::v1::market::MarketPriceLimits* mutable_market_price_limits();
  void set_allocated_market_price_limits(::t4proto::v1::market::MarketPriceLimits* value);
  void unsafe_arena_set_allocated_market_price_limits(::t4proto::v1::market::MarketPriceLimits* value);
  ::t4proto::v1::market::MarketPriceLimits* unsafe_arena_release_market_price_limits();

  private:
  const ::t4proto::v1::market::MarketPriceLimits& _internal_market_price_limits() const;
  ::t4proto::v1::market::MarketPriceLimits* _internal_mutable_market_price_limits();

  public:
  // .t4proto.v1.market.MarketSettlement market_settlement = 107;
  bool has_market_settlement() const;
  private:
  bool _internal_has_market_settlement() const;

  public:
  void clear_market_settlement() ;
  const ::t4proto::v1::market::MarketSettlement& market_settlement() const;
  PROTOBUF_NODISCARD ::t4proto::v1::market::MarketSettlement* release_market_settlement();
  ::t4proto::v1::market::MarketSettlement* mutable_market_settlement();
  void set_allocated_market_settlement(::t4proto::v1::market::MarketSettlement* value);
  void unsafe_arena_set_allocated_market_settlement(::t4proto::v1::market::MarketSettlement* value);
  ::t4proto::v1::market::MarketSettlement* unsafe_arena_release_market_settlement();

  private:
  const ::t4proto::v1::market::MarketSettlement& _internal_market_settlement() const;
  ::t4proto::v1::market::MarketSettlement* _internal_mutable_market_settlement();

  public:
  // .t4proto.v1.market.MarketSnapshot market_snapshot = 108;
  bool has_market_snapshot() const;
  private:
  bool _internal_has_market_snapshot() const;

  public:
  void clear_market_snapshot() ;
  const ::t4proto::v1::market::MarketSnapshot& market_snapshot() const;
  PROTOBUF_NODISCARD ::t4proto::v1::market::MarketSnapshot* release_market_snapshot();
  ::t4proto::v1::market::MarketSnapshot* mutable_market_snapshot();
  void set_allocated_market_snapshot(::t4proto::v1::market::MarketSnapshot* value);
  void unsafe_arena_set_allocated_market_snapshot(::t4proto::v1::market::MarketSnapshot* value);
  ::t4proto::v1::market::MarketSnapshot* unsafe_arena_release_market_snapshot();

  private:
  const ::t4proto::v1::market::MarketSnapshot& _internal_market_snapshot() const;
  ::t4proto::v1::market::MarketSnapshot* _internal_mutable_market_snapshot();

  public:
  // .t4proto.v1.market.MarketByOrderSnapshot market_by_order_snapshot = 109;
  bool has_market_by_order_snapshot() const;
  private:
  bool _internal_has_market_by_order_snapshot() const;

  public:
  void clear_market_by_order_snapshot() ;
  const ::t4proto::v1::market::MarketByOrderSnapshot& market_by_order_snapshot() const;
  PROTOBUF_NODISCARD ::t4proto::v1::market::MarketByOrderSnapshot* release_market_by_order_snapshot();
  ::t4proto::v1::market::MarketByOrderSnapshot* mutable_market_by_order_snapshot();
  void set_allocated_market_by_order_snapshot(::t4proto::v1::market::MarketByOrderSnapshot* value);
  void unsafe_arena_set_allocated_market_by_order_snapshot(::t4proto::v1::market::MarketByOrderSnapshot* value);
  ::t4proto::v1::market::MarketByOrderSnapshot* unsafe_arena_release_market_by_order_snapshot();

  private:
  const ::t4proto::v1::market::MarketByOrderSnapshot& _internal_market_by_order_snapshot() const;
  ::t4proto::v1::market::MarketByOrderSnapshot* _internal_mutable_market_by_order_snapshot();

  public:
  // .t4proto.v1.market.MarketByOrderUpdate market_by_order_update = 110;
  bool has_market_by_order_update() const;
  private:
  bool _internal_has_market_by_order_update() const;

  public:
  void clear_market_by_order_update() ;
  const ::t4proto::v1::market::MarketByOrderUpdate& market_by_order_update() const;
  PROTOBUF_NODISCARD ::t4proto::v1::market::MarketByOrderUpdate* release_market_by_order_update();
  ::t4proto::v1::market::MarketByOrderUpdate* mutable_market_by_order_update();
  void set_allocated_market_by_order_update(::t4proto::v1::market::MarketByOrderUpdate* value);
  void unsafe_arena_set_allocated_market_by_order_update(::t4proto::v1::market::MarketByOrderUpdate* value);
  ::t4proto::v1::market::MarketByOrderUpdate* unsafe_arena_release_market_by_order_update();

  private:
  const ::t4proto::v1::market::MarketByOrderUpdate& _internal_market_by_order_update() const;
  ::t4proto::v1::market::MarketByOrderUpdate* _internal_mutable_market_by_order_update();

  public:
  // .t4proto.v1.account.AccountSubscribeResponse account_subscribe_response = 200;
  bool has_account_subscribe_response() const;
  private:
  bool _internal_has_account_subscribe_response() const;

  public:
  void clear_account_subscribe_response() ;
  const ::t4proto::v1::account::AccountSubscribeResponse& account_subscribe_response() const;
  PROTOBUF_NODISCARD ::t4proto::v1::account::AccountSubscribeResponse* release_account_subscribe_response();
  ::t4proto::v1::account::AccountSubscribeResponse* mutable_account_subscribe_response();
  void set_allocated_account_subscribe_response(::t4proto::v1::account::AccountSubscribeResponse* value);
  void unsafe_arena_set_allocated_account_subscribe_response(::t4proto::v1::account::AccountSubscribeResponse* value);
  ::t4proto::v1::account::AccountSubscribeResponse* unsafe_arena_release_account_subscribe_response();

  private:
  const ::t4proto::v1::account::AccountSubscribeResponse& _internal_account_subscribe_response() const;
  ::t4proto::v1::account::AccountSubscribeResponse* _internal_mutable_account_subscribe_response();

  public:
  // .t4proto.v1.account.AccountCurrency account_currency = 201;
  bool has_account_currency() const;
  private:
  bool _internal_has_account_currency() const;

  public:
  void clear_account_currency() ;
  const ::t4proto::v1::account::AccountCurrency& account_currency() const;
  PROTOBUF_NODISCARD ::t4proto::v1::account::AccountCurrency* release_account_currency();
  ::t4proto::v1::account::AccountCurrency* mutable_account_currency();
  void set_allocated_account_currency(::t4proto::v1::account::AccountCurrency* value);
  void unsafe_arena_set_allocated_account_currency(::t4proto::v1::account::AccountCurrency* value);
  ::t4proto::v1::account::AccountCurrency* unsafe_arena_release_account_currency();

  private:
  const ::t4proto::v1::account::AccountCurrency& _internal_account_currency() const;
  ::t4proto::v1::account::AccountCurrency* _internal_mutable_account_currency();

  public:
  // .t4proto.v1.account.AccountPosition account_position = 202;
  bool has_account_position() const;
  private:
  bool _internal_has_account_position() const;

  public:
  void clear_account_position() ;
  const ::t4proto::v1::account::AccountPosition& account_position() const;
  PROTOBUF_NODISCARD ::t4proto::v1::account::AccountPosition* release_account_position();
  ::t4proto::v1::account::AccountPosition* mutable_account_position();
  void set_allocated_account_position(::t4proto::v1::account::AccountPosition* value);
  void unsafe_arena_set_allocated_account_position(::t4proto::v1::account::AccountPosition* value);
  ::t4proto::v1::account::AccountPosition* unsafe_arena_release_account_position();

  private:
  const ::t4proto::v1::account::AccountPosition& _internal_account_position() const;
  ::t4proto::v1::account::AccountPosition* _internal_mutable_account_position();

  public:
  // .t4proto.v1.account.AccountUpdate account_update = 203;
  bool has_account_update() const;
  private:
  bool _internal_has_account_update() const;

  public:
  void clear_account_update() ;
  const ::t4proto::v1::account::AccountUpdate& account_update() const;
  PROTOBUF_NODISCARD ::t4proto::v1::account::AccountUpdate* release_account_update();
  ::t4proto::v1::account::AccountUpdate* mutable_account_update();
  void set_allocated_account_update(::t4proto::v1::account::AccountUpdate* value);
  void unsafe_arena_set_allocated_account_update(::t4proto::v1::account::AccountUpdate* value);
  ::t4proto::v1::account::AccountUpdate* unsafe_arena_release_account_update();

  private:
  const ::t4proto::v1::account::AccountUpdate& _internal_account_update() const;
  ::t4proto::v1::account::AccountUpdate* _internal_mutable_account_update();

  public:
  // .t4proto.v1.account.AccountDetails account_details = 204;
  bool has_account_details() const;
  private:
  bool _internal_has_account_details() const;

  public:
  void clear_account_details() ;
  const ::t4proto::v1::account::AccountDetails& account_details() const;
  PROTOBUF_NODISCARD ::t4proto::v1::account::AccountDetails* release_account_details();
  ::t4proto::v1::account::AccountDetails* mutable_account_details();
  void set_allocated_account_details(::t4proto::v1::account::AccountDetails* value);
  void unsafe_arena_set_allocated_account_details(::t4proto::v1::account::AccountDetails* value);
  ::t4proto::v1::account::AccountDetails* unsafe_arena_release_account_details();

  private:
  const ::t4proto::v1::account::AccountDetails& _internal_account_details() const;
  ::t4proto::v1::account::AccountDetails* _internal_mutable_account_details();

  public:
  // .t4proto.v1.account.AccountSnapshot account_snapshot = 205;
  bool has_account_snapshot() const;
  private:
  bool _internal_has_account_snapshot() const;

  public:
  void clear_account_snapshot() ;
  const ::t4proto::v1::account::AccountSnapshot& account_snapshot() const;
  PROTOBUF_NODISCARD ::t4proto::v1::account::AccountSnapshot* release_account_snapshot();
  ::t4proto::v1::account::AccountSnapshot* mutable_account_snapshot();
  void set_allocated_account_snapshot(::t4proto::v1::account::AccountSnapshot* value);
  void unsafe_arena_set_allocated_account_snapshot(::t4proto::v1::account::AccountSnapshot* value);
  ::t4proto::v1::account::AccountSnapshot* unsafe_arena_release_account_snapshot();

  private:
  const ::t4proto::v1::account::AccountSnapshot& _internal_account_snapshot() const;
  ::t4proto::v1::account::AccountSnapshot* _internal_mutable_account_snapshot();

  public:
  // .t4proto.v1.account.AccountProfit account_profit = 206;
  bool has_account_profit() const;
  private:
  bool _internal_has_account_profit() const;

  public:
  void clear_account_profit() ;
  const ::t4proto::v1::account::AccountProfit& account_profit() const;
  PROTOBUF_NODISCARD ::t4proto::v1::account::AccountProfit* release_account_profit();
  ::t4proto::v1::account::AccountProfit* mutable_account_profit();
  void set_allocated_account_profit(::t4proto::v1::account::AccountProfit* value);
  void unsafe_arena_set_allocated_account_profit(::t4proto::v1::account::AccountProfit* value);
  ::t4proto::v1::account::AccountProfit* unsafe_arena_release_account_profit();

  private:
  const ::t4proto::v1::account::AccountProfit& _internal_account_profit() const;
  ::t4proto::v1::account::AccountProfit* _internal_mutable_account_profit();

  public:
  // .t4proto.v1.account.AccountPositionProfit account_position_profit = 207;
  bool has_account_position_profit() const;
  private:
  bool _internal_has_account_position_profit() const;

  public:
  void clear_account_position_profit() ;
  const ::t4proto::v1::account::AccountPositionProfit& account_position_profit() const;
  PROTOBUF_NODISCARD ::t4proto::v1::account::AccountPositionProfit* release_account_position_profit();
  ::t4proto::v1::account::AccountPositionProfit* mutable_account_position_profit();
  void set_allocated_account_position_profit(::t4proto::v1::account::AccountPositionProfit* value);
  void unsafe_arena_set_allocated_account_position_profit(::t4proto::v1::account::AccountPositionProfit* value);
  ::t4proto::v1::account::AccountPositionProfit* unsafe_arena_release_account_position_profit();

  private:
  const ::t4proto::v1::account::AccountPositionProfit& _internal_account_position_profit() const;
  ::t4proto::v1::account::AccountPositionProfit* _internal_mutable_account_position_profit();

  public:
  // .t4proto.v1.orderrouting.OrderUpdate order_update = 300;
  bool has_order_update() const;
  private:
  bool _internal_has_order_update() const;

  public:
  void clear_order_update() ;
  const ::t4proto::v1::orderrouting::OrderUpdate& order_update() const;
  PROTOBUF_NODISCARD ::t4proto::v1::orderrouting::OrderUpdate* release_order_update();
  ::t4proto::v1::orderrouting::OrderUpdate* mutable_order_update();
  void set_allocated_order_update(::t4proto::v1::orderrouting::OrderUpdate* value);
  void unsafe_arena_set_allocated_order_update(::t4proto::v1::orderrouting::OrderUpdate* value);
  ::t4proto::v1::orderrouting::OrderUpdate* unsafe_arena_release_order_update();

  private:
  const ::t4proto::v1::orderrouting::OrderUpdate& _internal_order_update() const;
  ::t4proto::v1::orderrouting::OrderUpdate* _internal_mutable_order_update();

  public:
  // .t4proto.v1.orderrouting.OrderUpdateMulti order_update_multi = 301;
  bool has_order_update_multi() const;
  private:
  bool _internal_has_order_update_multi() const;

  public:
  void clear_order_update_multi() ;
  const ::t4proto::v1::orderrouting::OrderUpdateMulti& order_update_multi() const;
  PROTOBUF_NODISCARD ::t4proto::v1::orderrouting::OrderUpdateMulti* release_order_update_multi();
  ::t4proto::v1::orderrouting::OrderUpdateMulti* mutable_order_update_multi();
  void set_allocated_order_update_multi(::t4proto::v1::orderrouting::OrderUpdateMulti* value);
  void unsafe_arena_set_allocated_order_update_multi(::t4proto::v1::orderrouting::OrderUpdateMulti* value);
  ::t4proto::v1::orderrouting::OrderUpdateMulti* unsafe_arena_release_order_update_multi();

  private:
  const ::t4proto::v1::orderrouting::OrderUpdateMulti& _internal_order_update_multi() const;
  ::t4proto::v1::orderrouting::OrderUpdateMulti* _internal_mutable_order_update_multi();

  public:
  // .t4proto.v1.orderrouting.OrderUpdateFailed order_update_failed = 302;
  bool has_order_update_failed() const;
  private:
  bool _internal_has_order_update_failed() const;

  public:
  void clear_order_update_failed() ;
  const ::t4proto::v1::orderrouting::OrderUpdateFailed& order_update_failed() const;
  PROTOBUF_NODISCARD ::t4proto::v1::orderrouting::OrderUpdateFailed* release_order_update_failed();
  ::t4proto::v1::orderrouting::OrderUpdateFailed* mutable_order_update_failed();
  void set_allocated_order_update_failed(::t4proto::v1::orderrouting::OrderUpdateFailed* value);
  void unsafe_arena_set_allocated_order_update_failed(::t4proto::v1::orderrouting::OrderUpdateFailed* value);
  ::t4proto::v1::orderrouting::OrderUpdateFailed* unsafe_arena_release_order_update_failed();

  private:
  const ::t4proto::v1::orderrouting::OrderUpdateFailed& _internal_order_update_failed() const;
  ::t4proto::v1::orderrouting::OrderUpdateFailed* _internal_mutable_order_update_failed();

  public:
  // .t4proto.v1.orderrouting.OrderUpdateStatus order_update_status = 303;
  bool has_order_update_status() const;
  private:
  bool _internal_has_order_update_status() const;

  public:
  void clear_order_update_status() ;
  const ::t4proto::v1::orderrouting::OrderUpdateStatus& order_update_status() const;
  PROTOBUF_NODISCARD ::t4proto::v1::orderrouting::OrderUpdateStatus* release_order_update_status();
  ::t4proto::v1::orderrouting::OrderUpdateStatus* mutable_order_update_status();
  void set_allocated_order_update_status(::t4proto::v1::orderrouting::OrderUpdateStatus* value);
  void unsafe_arena_set_allocated_order_update_status(::t4proto::v1::orderrouting::OrderUpdateStatus* value);
  ::t4proto::v1::orderrouting::OrderUpdateStatus* unsafe_arena_release_order_update_status();

  private:
  const ::t4proto::v1::orderrouting::OrderUpdateStatus& _internal_order_update_status() const;
  ::t4proto::v1::orderrouting::OrderUpdateStatus* _internal_mutable_order_update_status();

  public:
  // .t4proto.v1.orderrouting.OrderUpdateTrade order_update_trade = 304;
  bool has_order_update_trade() const;
  private:
  bool _internal_has_order_update_trade() const;

  public:
  void clear_order_update_trade() ;
  const ::t4proto::v1::orderrouting::OrderUpdateTrade& order_update_trade() const;
  PROTOBUF_NODISCARD ::t4proto::v1::orderrouting::OrderUpdateTrade* release_order_update_trade();
  ::t4proto::v1::orderrouting::OrderUpdateTrade* mutable_order_update_trade();
  void set_allocated_order_update_trade(::t4proto::v1::orderrouting::OrderUpdateTrade* value);
  void unsafe_arena_set_allocated_order_update_trade(::t4proto::v1::orderrouting::OrderUpdateTrade* value);
  ::t4proto::v1::orderrouting::OrderUpdateTrade* unsafe_arena_release_order_update_trade();

  private:
  const ::t4proto::v1::orderrouting::OrderUpdateTrade& _internal_order_update_trade() const;
  ::t4proto::v1::orderrouting::OrderUpdateTrade* _internal_mutable_order_update_trade();

  public:
  // .t4proto.v1.orderrouting.OrderUpdateTradeLeg order_update_trade_leg = 305;
  bool has_order_update_trade_leg() const;
  private:
  bool _internal_has_order_update_trade_leg() const;

  public:
  void clear_order_update_trade_leg() ;
  const ::t4proto::v1::orderrouting::OrderUpdateTradeLeg& order_update_trade_leg() const;
  PROTOBUF_NODISCARD ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* release_order_update_trade_leg();
  ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* mutable_order_update_trade_leg();
  void set_allocated_order_update_trade_leg(::t4proto::v1::orderrouting::OrderUpdateTradeLeg* value);
  void unsafe_arena_set_allocated_order_update_trade_leg(::t4proto::v1::orderrouting::OrderUpdateTradeLeg* value);
  ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* unsafe_arena_release_order_update_trade_leg();

  private:
  const ::t4proto::v1::orderrouting::OrderUpdateTradeLeg& _internal_order_update_trade_leg() const;
  ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* _internal_mutable_order_update_trade_leg();

  public:
  // .t4proto.v1.orderrouting.CreateUDSResponse create_uds_response = 340;
  bool has_create_uds_response() const;
  private:
  bool _internal_has_create_uds_response() const;

  public:
  void clear_create_uds_response() ;
  const ::t4proto::v1::orderrouting::CreateUDSResponse& create_uds_response() const;
  PROTOBUF_NODISCARD ::t4proto::v1::orderrouting::CreateUDSResponse* release_create_uds_response();
  ::t4proto::v1::orderrouting::CreateUDSResponse* mutable_create_uds_response();
  void set_allocated_create_uds_response(::t4proto::v1::orderrouting::CreateUDSResponse* value);
  void unsafe_arena_set_allocated_create_uds_response(::t4proto::v1::orderrouting::CreateUDSResponse* value);
  ::t4proto::v1::orderrouting::CreateUDSResponse* unsafe_arena_release_create_uds_response();

  private:
  const ::t4proto::v1::orderrouting::CreateUDSResponse& _internal_create_uds_response() const;
  ::t4proto::v1::orderrouting::CreateUDSResponse* _internal_mutable_create_uds_response();

  public:
  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:t4proto.v1.service.ServerMessage)
 private:
  class _Internal;
  void set_has_heartbeat();
  void set_has_login_response();
  void set_has_authentication_token();
  void set_has_market_depth_subscribe_reject();
  void set_has_market_by_order_subscribe_reject();
  void set_has_market_details();
  void set_has_market_depth();
  void set_has_market_depth_trade();
  void set_has_market_high_low();
  void set_has_market_price_limits();
  void set_has_market_settlement();
  void set_has_market_snapshot();
  void set_has_market_by_order_snapshot();
  void set_has_market_by_order_update();
  void set_has_account_subscribe_response();
  void set_has_account_currency();
  void set_has_account_position();
  void set_has_account_update();
  void set_has_account_details();
  void set_has_account_snapshot();
  void set_has_account_profit();
  void set_has_account_position_profit();
  void set_has_order_update();
  void set_has_order_update_multi();
  void set_has_order_update_failed();
  void set_has_order_update_status();
  void set_has_order_update_trade();
  void set_has_order_update_trade_leg();
  void set_has_create_uds_response();
  inline bool has_payload() const;
  inline void clear_has_payload();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 29, 29,
      0, 21>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ServerMessage& from_msg);
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::t4proto::v1::service::Heartbeat* heartbeat_;
      ::t4proto::v1::auth::LoginResponse* login_response_;
      ::t4proto::v1::auth::AuthenticationToken* authentication_token_;
      ::t4proto::v1::market::MarketDepthSubscribeReject* market_depth_subscribe_reject_;
      ::t4proto::v1::market::MarketByOrderSubscribeReject* market_by_order_subscribe_reject_;
      ::t4proto::v1::market::MarketDetails* market_details_;
      ::t4proto::v1::market::MarketDepth* market_depth_;
      ::t4proto::v1::market::MarketDepthTrade* market_depth_trade_;
      ::t4proto::v1::market::MarketHighLow* market_high_low_;
      ::t4proto::v1::market::MarketPriceLimits* market_price_limits_;
      ::t4proto::v1::market::MarketSettlement* market_settlement_;
      ::t4proto::v1::market::MarketSnapshot* market_snapshot_;
      ::t4proto::v1::market::MarketByOrderSnapshot* market_by_order_snapshot_;
      ::t4proto::v1::market::MarketByOrderUpdate* market_by_order_update_;
      ::t4proto::v1::account::AccountSubscribeResponse* account_subscribe_response_;
      ::t4proto::v1::account::AccountCurrency* account_currency_;
      ::t4proto::v1::account::AccountPosition* account_position_;
      ::t4proto::v1::account::AccountUpdate* account_update_;
      ::t4proto::v1::account::AccountDetails* account_details_;
      ::t4proto::v1::account::AccountSnapshot* account_snapshot_;
      ::t4proto::v1::account::AccountProfit* account_profit_;
      ::t4proto::v1::account::AccountPositionProfit* account_position_profit_;
      ::t4proto::v1::orderrouting::OrderUpdate* order_update_;
      ::t4proto::v1::orderrouting::OrderUpdateMulti* order_update_multi_;
      ::t4proto::v1::orderrouting::OrderUpdateFailed* order_update_failed_;
      ::t4proto::v1::orderrouting::OrderUpdateStatus* order_update_status_;
      ::t4proto::v1::orderrouting::OrderUpdateTrade* order_update_trade_;
      ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* order_update_trade_leg_;
      ::t4proto::v1::orderrouting::CreateUDSResponse* create_uds_response_;
    } payload_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t4_2fv1_2fservice_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ClientMessage

// .t4proto.v1.service.Heartbeat heartbeat = 1;
inline bool ClientMessage::has_heartbeat() const {
  return payload_case() == kHeartbeat;
}
inline bool ClientMessage::_internal_has_heartbeat() const {
  return payload_case() == kHeartbeat;
}
inline void ClientMessage::set_has_heartbeat() {
  _impl_._oneof_case_[0] = kHeartbeat;
}
inline void ClientMessage::clear_heartbeat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kHeartbeat) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.heartbeat_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.heartbeat_);
    }
    clear_has_payload();
  }
}
inline ::t4proto::v1::service::Heartbeat* ClientMessage::release_heartbeat() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ClientMessage.heartbeat)
  if (payload_case() == kHeartbeat) {
    clear_has_payload();
    auto* temp = _impl_.payload_.heartbeat_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::service::Heartbeat& ClientMessage::_internal_heartbeat() const {
  return payload_case() == kHeartbeat ? *_impl_.payload_.heartbeat_ : reinterpret_cast<::t4proto::v1::service::Heartbeat&>(::t4proto::v1::service::_Heartbeat_default_instance_);
}
inline const ::t4proto::v1::service::Heartbeat& ClientMessage::heartbeat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ClientMessage.heartbeat)
  return _internal_heartbeat();
}
inline ::t4proto::v1::service::Heartbeat* ClientMessage::unsafe_arena_release_heartbeat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ClientMessage.heartbeat)
  if (payload_case() == kHeartbeat) {
    clear_has_payload();
    auto* temp = _impl_.payload_.heartbeat_;
    _impl_.payload_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_heartbeat(::t4proto::v1::service::Heartbeat* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_heartbeat();
    _impl_.payload_.heartbeat_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ClientMessage.heartbeat)
}
inline ::t4proto::v1::service::Heartbeat* ClientMessage::_internal_mutable_heartbeat() {
  if (payload_case() != kHeartbeat) {
    clear_payload();
    set_has_heartbeat();
    _impl_.payload_.heartbeat_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::service::Heartbeat>(GetArena());
  }
  return _impl_.payload_.heartbeat_;
}
inline ::t4proto::v1::service::Heartbeat* ClientMessage::mutable_heartbeat() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::service::Heartbeat* _msg = _internal_mutable_heartbeat();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ClientMessage.heartbeat)
  return _msg;
}

// .t4proto.v1.auth.LoginRequest login_request = 2;
inline bool ClientMessage::has_login_request() const {
  return payload_case() == kLoginRequest;
}
inline bool ClientMessage::_internal_has_login_request() const {
  return payload_case() == kLoginRequest;
}
inline void ClientMessage::set_has_login_request() {
  _impl_._oneof_case_[0] = kLoginRequest;
}
inline ::t4proto::v1::auth::LoginRequest* ClientMessage::release_login_request() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ClientMessage.login_request)
  if (payload_case() == kLoginRequest) {
    clear_has_payload();
    auto* temp = _impl_.payload_.login_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.login_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::auth::LoginRequest& ClientMessage::_internal_login_request() const {
  return payload_case() == kLoginRequest ? *_impl_.payload_.login_request_ : reinterpret_cast<::t4proto::v1::auth::LoginRequest&>(::t4proto::v1::auth::_LoginRequest_default_instance_);
}
inline const ::t4proto::v1::auth::LoginRequest& ClientMessage::login_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ClientMessage.login_request)
  return _internal_login_request();
}
inline ::t4proto::v1::auth::LoginRequest* ClientMessage::unsafe_arena_release_login_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ClientMessage.login_request)
  if (payload_case() == kLoginRequest) {
    clear_has_payload();
    auto* temp = _impl_.payload_.login_request_;
    _impl_.payload_.login_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_login_request(::t4proto::v1::auth::LoginRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_login_request();
    _impl_.payload_.login_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ClientMessage.login_request)
}
inline ::t4proto::v1::auth::LoginRequest* ClientMessage::_internal_mutable_login_request() {
  if (payload_case() != kLoginRequest) {
    clear_payload();
    set_has_login_request();
    _impl_.payload_.login_request_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::auth::LoginRequest>(GetArena());
  }
  return _impl_.payload_.login_request_;
}
inline ::t4proto::v1::auth::LoginRequest* ClientMessage::mutable_login_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::auth::LoginRequest* _msg = _internal_mutable_login_request();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ClientMessage.login_request)
  return _msg;
}

// .t4proto.v1.auth.AuthenticationTokenRequest authentication_token_request = 3;
inline bool ClientMessage::has_authentication_token_request() const {
  return payload_case() == kAuthenticationTokenRequest;
}
inline bool ClientMessage::_internal_has_authentication_token_request() const {
  return payload_case() == kAuthenticationTokenRequest;
}
inline void ClientMessage::set_has_authentication_token_request() {
  _impl_._oneof_case_[0] = kAuthenticationTokenRequest;
}
inline ::t4proto::v1::auth::AuthenticationTokenRequest* ClientMessage::release_authentication_token_request() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ClientMessage.authentication_token_request)
  if (payload_case() == kAuthenticationTokenRequest) {
    clear_has_payload();
    auto* temp = _impl_.payload_.authentication_token_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.authentication_token_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::auth::AuthenticationTokenRequest& ClientMessage::_internal_authentication_token_request() const {
  return payload_case() == kAuthenticationTokenRequest ? *_impl_.payload_.authentication_token_request_ : reinterpret_cast<::t4proto::v1::auth::AuthenticationTokenRequest&>(::t4proto::v1::auth::_AuthenticationTokenRequest_default_instance_);
}
inline const ::t4proto::v1::auth::AuthenticationTokenRequest& ClientMessage::authentication_token_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ClientMessage.authentication_token_request)
  return _internal_authentication_token_request();
}
inline ::t4proto::v1::auth::AuthenticationTokenRequest* ClientMessage::unsafe_arena_release_authentication_token_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ClientMessage.authentication_token_request)
  if (payload_case() == kAuthenticationTokenRequest) {
    clear_has_payload();
    auto* temp = _impl_.payload_.authentication_token_request_;
    _impl_.payload_.authentication_token_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_authentication_token_request(::t4proto::v1::auth::AuthenticationTokenRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_authentication_token_request();
    _impl_.payload_.authentication_token_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ClientMessage.authentication_token_request)
}
inline ::t4proto::v1::auth::AuthenticationTokenRequest* ClientMessage::_internal_mutable_authentication_token_request() {
  if (payload_case() != kAuthenticationTokenRequest) {
    clear_payload();
    set_has_authentication_token_request();
    _impl_.payload_.authentication_token_request_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::auth::AuthenticationTokenRequest>(GetArena());
  }
  return _impl_.payload_.authentication_token_request_;
}
inline ::t4proto::v1::auth::AuthenticationTokenRequest* ClientMessage::mutable_authentication_token_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::auth::AuthenticationTokenRequest* _msg = _internal_mutable_authentication_token_request();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ClientMessage.authentication_token_request)
  return _msg;
}

// .t4proto.v1.market.MarketDepthSubscribe market_depth_subscribe = 100;
inline bool ClientMessage::has_market_depth_subscribe() const {
  return payload_case() == kMarketDepthSubscribe;
}
inline bool ClientMessage::_internal_has_market_depth_subscribe() const {
  return payload_case() == kMarketDepthSubscribe;
}
inline void ClientMessage::set_has_market_depth_subscribe() {
  _impl_._oneof_case_[0] = kMarketDepthSubscribe;
}
inline ::t4proto::v1::market::MarketDepthSubscribe* ClientMessage::release_market_depth_subscribe() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ClientMessage.market_depth_subscribe)
  if (payload_case() == kMarketDepthSubscribe) {
    clear_has_payload();
    auto* temp = _impl_.payload_.market_depth_subscribe_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_depth_subscribe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketDepthSubscribe& ClientMessage::_internal_market_depth_subscribe() const {
  return payload_case() == kMarketDepthSubscribe ? *_impl_.payload_.market_depth_subscribe_ : reinterpret_cast<::t4proto::v1::market::MarketDepthSubscribe&>(::t4proto::v1::market::_MarketDepthSubscribe_default_instance_);
}
inline const ::t4proto::v1::market::MarketDepthSubscribe& ClientMessage::market_depth_subscribe() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ClientMessage.market_depth_subscribe)
  return _internal_market_depth_subscribe();
}
inline ::t4proto::v1::market::MarketDepthSubscribe* ClientMessage::unsafe_arena_release_market_depth_subscribe() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ClientMessage.market_depth_subscribe)
  if (payload_case() == kMarketDepthSubscribe) {
    clear_has_payload();
    auto* temp = _impl_.payload_.market_depth_subscribe_;
    _impl_.payload_.market_depth_subscribe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_market_depth_subscribe(::t4proto::v1::market::MarketDepthSubscribe* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_market_depth_subscribe();
    _impl_.payload_.market_depth_subscribe_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ClientMessage.market_depth_subscribe)
}
inline ::t4proto::v1::market::MarketDepthSubscribe* ClientMessage::_internal_mutable_market_depth_subscribe() {
  if (payload_case() != kMarketDepthSubscribe) {
    clear_payload();
    set_has_market_depth_subscribe();
    _impl_.payload_.market_depth_subscribe_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::market::MarketDepthSubscribe>(GetArena());
  }
  return _impl_.payload_.market_depth_subscribe_;
}
inline ::t4proto::v1::market::MarketDepthSubscribe* ClientMessage::mutable_market_depth_subscribe() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::market::MarketDepthSubscribe* _msg = _internal_mutable_market_depth_subscribe();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ClientMessage.market_depth_subscribe)
  return _msg;
}

// .t4proto.v1.market.MarketByOrderSubscribe market_by_order_subscribe = 101;
inline bool ClientMessage::has_market_by_order_subscribe() const {
  return payload_case() == kMarketByOrderSubscribe;
}
inline bool ClientMessage::_internal_has_market_by_order_subscribe() const {
  return payload_case() == kMarketByOrderSubscribe;
}
inline void ClientMessage::set_has_market_by_order_subscribe() {
  _impl_._oneof_case_[0] = kMarketByOrderSubscribe;
}
inline ::t4proto::v1::market::MarketByOrderSubscribe* ClientMessage::release_market_by_order_subscribe() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ClientMessage.market_by_order_subscribe)
  if (payload_case() == kMarketByOrderSubscribe) {
    clear_has_payload();
    auto* temp = _impl_.payload_.market_by_order_subscribe_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_by_order_subscribe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketByOrderSubscribe& ClientMessage::_internal_market_by_order_subscribe() const {
  return payload_case() == kMarketByOrderSubscribe ? *_impl_.payload_.market_by_order_subscribe_ : reinterpret_cast<::t4proto::v1::market::MarketByOrderSubscribe&>(::t4proto::v1::market::_MarketByOrderSubscribe_default_instance_);
}
inline const ::t4proto::v1::market::MarketByOrderSubscribe& ClientMessage::market_by_order_subscribe() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ClientMessage.market_by_order_subscribe)
  return _internal_market_by_order_subscribe();
}
inline ::t4proto::v1::market::MarketByOrderSubscribe* ClientMessage::unsafe_arena_release_market_by_order_subscribe() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ClientMessage.market_by_order_subscribe)
  if (payload_case() == kMarketByOrderSubscribe) {
    clear_has_payload();
    auto* temp = _impl_.payload_.market_by_order_subscribe_;
    _impl_.payload_.market_by_order_subscribe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_market_by_order_subscribe(::t4proto::v1::market::MarketByOrderSubscribe* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_market_by_order_subscribe();
    _impl_.payload_.market_by_order_subscribe_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ClientMessage.market_by_order_subscribe)
}
inline ::t4proto::v1::market::MarketByOrderSubscribe* ClientMessage::_internal_mutable_market_by_order_subscribe() {
  if (payload_case() != kMarketByOrderSubscribe) {
    clear_payload();
    set_has_market_by_order_subscribe();
    _impl_.payload_.market_by_order_subscribe_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::market::MarketByOrderSubscribe>(GetArena());
  }
  return _impl_.payload_.market_by_order_subscribe_;
}
inline ::t4proto::v1::market::MarketByOrderSubscribe* ClientMessage::mutable_market_by_order_subscribe() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::market::MarketByOrderSubscribe* _msg = _internal_mutable_market_by_order_subscribe();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ClientMessage.market_by_order_subscribe)
  return _msg;
}

// .t4proto.v1.account.AccountSubscribe account_subscribe = 200;
inline bool ClientMessage::has_account_subscribe() const {
  return payload_case() == kAccountSubscribe;
}
inline bool ClientMessage::_internal_has_account_subscribe() const {
  return payload_case() == kAccountSubscribe;
}
inline void ClientMessage::set_has_account_subscribe() {
  _impl_._oneof_case_[0] = kAccountSubscribe;
}
inline ::t4proto::v1::account::AccountSubscribe* ClientMessage::release_account_subscribe() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ClientMessage.account_subscribe)
  if (payload_case() == kAccountSubscribe) {
    clear_has_payload();
    auto* temp = _impl_.payload_.account_subscribe_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.account_subscribe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::account::AccountSubscribe& ClientMessage::_internal_account_subscribe() const {
  return payload_case() == kAccountSubscribe ? *_impl_.payload_.account_subscribe_ : reinterpret_cast<::t4proto::v1::account::AccountSubscribe&>(::t4proto::v1::account::_AccountSubscribe_default_instance_);
}
inline const ::t4proto::v1::account::AccountSubscribe& ClientMessage::account_subscribe() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ClientMessage.account_subscribe)
  return _internal_account_subscribe();
}
inline ::t4proto::v1::account::AccountSubscribe* ClientMessage::unsafe_arena_release_account_subscribe() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ClientMessage.account_subscribe)
  if (payload_case() == kAccountSubscribe) {
    clear_has_payload();
    auto* temp = _impl_.payload_.account_subscribe_;
    _impl_.payload_.account_subscribe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_account_subscribe(::t4proto::v1::account::AccountSubscribe* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_account_subscribe();
    _impl_.payload_.account_subscribe_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ClientMessage.account_subscribe)
}
inline ::t4proto::v1::account::AccountSubscribe* ClientMessage::_internal_mutable_account_subscribe() {
  if (payload_case() != kAccountSubscribe) {
    clear_payload();
    set_has_account_subscribe();
    _impl_.payload_.account_subscribe_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::account::AccountSubscribe>(GetArena());
  }
  return _impl_.payload_.account_subscribe_;
}
inline ::t4proto::v1::account::AccountSubscribe* ClientMessage::mutable_account_subscribe() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::account::AccountSubscribe* _msg = _internal_mutable_account_subscribe();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ClientMessage.account_subscribe)
  return _msg;
}

// .t4proto.v1.orderrouting.OrderSubmit order_submit = 300;
inline bool ClientMessage::has_order_submit() const {
  return payload_case() == kOrderSubmit;
}
inline bool ClientMessage::_internal_has_order_submit() const {
  return payload_case() == kOrderSubmit;
}
inline void ClientMessage::set_has_order_submit() {
  _impl_._oneof_case_[0] = kOrderSubmit;
}
inline ::t4proto::v1::orderrouting::OrderSubmit* ClientMessage::release_order_submit() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ClientMessage.order_submit)
  if (payload_case() == kOrderSubmit) {
    clear_has_payload();
    auto* temp = _impl_.payload_.order_submit_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.order_submit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::OrderSubmit& ClientMessage::_internal_order_submit() const {
  return payload_case() == kOrderSubmit ? *_impl_.payload_.order_submit_ : reinterpret_cast<::t4proto::v1::orderrouting::OrderSubmit&>(::t4proto::v1::orderrouting::_OrderSubmit_default_instance_);
}
inline const ::t4proto::v1::orderrouting::OrderSubmit& ClientMessage::order_submit() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ClientMessage.order_submit)
  return _internal_order_submit();
}
inline ::t4proto::v1::orderrouting::OrderSubmit* ClientMessage::unsafe_arena_release_order_submit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ClientMessage.order_submit)
  if (payload_case() == kOrderSubmit) {
    clear_has_payload();
    auto* temp = _impl_.payload_.order_submit_;
    _impl_.payload_.order_submit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_order_submit(::t4proto::v1::orderrouting::OrderSubmit* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_order_submit();
    _impl_.payload_.order_submit_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ClientMessage.order_submit)
}
inline ::t4proto::v1::orderrouting::OrderSubmit* ClientMessage::_internal_mutable_order_submit() {
  if (payload_case() != kOrderSubmit) {
    clear_payload();
    set_has_order_submit();
    _impl_.payload_.order_submit_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::orderrouting::OrderSubmit>(GetArena());
  }
  return _impl_.payload_.order_submit_;
}
inline ::t4proto::v1::orderrouting::OrderSubmit* ClientMessage::mutable_order_submit() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::orderrouting::OrderSubmit* _msg = _internal_mutable_order_submit();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ClientMessage.order_submit)
  return _msg;
}

// .t4proto.v1.orderrouting.OrderRevise order_revise = 301;
inline bool ClientMessage::has_order_revise() const {
  return payload_case() == kOrderRevise;
}
inline bool ClientMessage::_internal_has_order_revise() const {
  return payload_case() == kOrderRevise;
}
inline void ClientMessage::set_has_order_revise() {
  _impl_._oneof_case_[0] = kOrderRevise;
}
inline ::t4proto::v1::orderrouting::OrderRevise* ClientMessage::release_order_revise() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ClientMessage.order_revise)
  if (payload_case() == kOrderRevise) {
    clear_has_payload();
    auto* temp = _impl_.payload_.order_revise_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.order_revise_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::OrderRevise& ClientMessage::_internal_order_revise() const {
  return payload_case() == kOrderRevise ? *_impl_.payload_.order_revise_ : reinterpret_cast<::t4proto::v1::orderrouting::OrderRevise&>(::t4proto::v1::orderrouting::_OrderRevise_default_instance_);
}
inline const ::t4proto::v1::orderrouting::OrderRevise& ClientMessage::order_revise() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ClientMessage.order_revise)
  return _internal_order_revise();
}
inline ::t4proto::v1::orderrouting::OrderRevise* ClientMessage::unsafe_arena_release_order_revise() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ClientMessage.order_revise)
  if (payload_case() == kOrderRevise) {
    clear_has_payload();
    auto* temp = _impl_.payload_.order_revise_;
    _impl_.payload_.order_revise_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_order_revise(::t4proto::v1::orderrouting::OrderRevise* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_order_revise();
    _impl_.payload_.order_revise_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ClientMessage.order_revise)
}
inline ::t4proto::v1::orderrouting::OrderRevise* ClientMessage::_internal_mutable_order_revise() {
  if (payload_case() != kOrderRevise) {
    clear_payload();
    set_has_order_revise();
    _impl_.payload_.order_revise_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::orderrouting::OrderRevise>(GetArena());
  }
  return _impl_.payload_.order_revise_;
}
inline ::t4proto::v1::orderrouting::OrderRevise* ClientMessage::mutable_order_revise() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::orderrouting::OrderRevise* _msg = _internal_mutable_order_revise();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ClientMessage.order_revise)
  return _msg;
}

// .t4proto.v1.orderrouting.OrderPull order_pull = 302;
inline bool ClientMessage::has_order_pull() const {
  return payload_case() == kOrderPull;
}
inline bool ClientMessage::_internal_has_order_pull() const {
  return payload_case() == kOrderPull;
}
inline void ClientMessage::set_has_order_pull() {
  _impl_._oneof_case_[0] = kOrderPull;
}
inline ::t4proto::v1::orderrouting::OrderPull* ClientMessage::release_order_pull() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ClientMessage.order_pull)
  if (payload_case() == kOrderPull) {
    clear_has_payload();
    auto* temp = _impl_.payload_.order_pull_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.order_pull_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::OrderPull& ClientMessage::_internal_order_pull() const {
  return payload_case() == kOrderPull ? *_impl_.payload_.order_pull_ : reinterpret_cast<::t4proto::v1::orderrouting::OrderPull&>(::t4proto::v1::orderrouting::_OrderPull_default_instance_);
}
inline const ::t4proto::v1::orderrouting::OrderPull& ClientMessage::order_pull() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ClientMessage.order_pull)
  return _internal_order_pull();
}
inline ::t4proto::v1::orderrouting::OrderPull* ClientMessage::unsafe_arena_release_order_pull() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ClientMessage.order_pull)
  if (payload_case() == kOrderPull) {
    clear_has_payload();
    auto* temp = _impl_.payload_.order_pull_;
    _impl_.payload_.order_pull_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_order_pull(::t4proto::v1::orderrouting::OrderPull* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_order_pull();
    _impl_.payload_.order_pull_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ClientMessage.order_pull)
}
inline ::t4proto::v1::orderrouting::OrderPull* ClientMessage::_internal_mutable_order_pull() {
  if (payload_case() != kOrderPull) {
    clear_payload();
    set_has_order_pull();
    _impl_.payload_.order_pull_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::orderrouting::OrderPull>(GetArena());
  }
  return _impl_.payload_.order_pull_;
}
inline ::t4proto::v1::orderrouting::OrderPull* ClientMessage::mutable_order_pull() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::orderrouting::OrderPull* _msg = _internal_mutable_order_pull();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ClientMessage.order_pull)
  return _msg;
}

// .t4proto.v1.orderrouting.CreateUDS create_uds = 340;
inline bool ClientMessage::has_create_uds() const {
  return payload_case() == kCreateUds;
}
inline bool ClientMessage::_internal_has_create_uds() const {
  return payload_case() == kCreateUds;
}
inline void ClientMessage::set_has_create_uds() {
  _impl_._oneof_case_[0] = kCreateUds;
}
inline ::t4proto::v1::orderrouting::CreateUDS* ClientMessage::release_create_uds() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ClientMessage.create_uds)
  if (payload_case() == kCreateUds) {
    clear_has_payload();
    auto* temp = _impl_.payload_.create_uds_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.create_uds_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::CreateUDS& ClientMessage::_internal_create_uds() const {
  return payload_case() == kCreateUds ? *_impl_.payload_.create_uds_ : reinterpret_cast<::t4proto::v1::orderrouting::CreateUDS&>(::t4proto::v1::orderrouting::_CreateUDS_default_instance_);
}
inline const ::t4proto::v1::orderrouting::CreateUDS& ClientMessage::create_uds() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ClientMessage.create_uds)
  return _internal_create_uds();
}
inline ::t4proto::v1::orderrouting::CreateUDS* ClientMessage::unsafe_arena_release_create_uds() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ClientMessage.create_uds)
  if (payload_case() == kCreateUds) {
    clear_has_payload();
    auto* temp = _impl_.payload_.create_uds_;
    _impl_.payload_.create_uds_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_create_uds(::t4proto::v1::orderrouting::CreateUDS* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_create_uds();
    _impl_.payload_.create_uds_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ClientMessage.create_uds)
}
inline ::t4proto::v1::orderrouting::CreateUDS* ClientMessage::_internal_mutable_create_uds() {
  if (payload_case() != kCreateUds) {
    clear_payload();
    set_has_create_uds();
    _impl_.payload_.create_uds_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::orderrouting::CreateUDS>(GetArena());
  }
  return _impl_.payload_.create_uds_;
}
inline ::t4proto::v1::orderrouting::CreateUDS* ClientMessage::mutable_create_uds() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::orderrouting::CreateUDS* _msg = _internal_mutable_create_uds();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ClientMessage.create_uds)
  return _msg;
}

inline bool ClientMessage::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void ClientMessage::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline ClientMessage::PayloadCase ClientMessage::payload_case() const {
  return ClientMessage::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ServerMessage

// .t4proto.v1.service.Heartbeat heartbeat = 1;
inline bool ServerMessage::has_heartbeat() const {
  return payload_case() == kHeartbeat;
}
inline bool ServerMessage::_internal_has_heartbeat() const {
  return payload_case() == kHeartbeat;
}
inline void ServerMessage::set_has_heartbeat() {
  _impl_._oneof_case_[0] = kHeartbeat;
}
inline void ServerMessage::clear_heartbeat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kHeartbeat) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.heartbeat_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.heartbeat_);
    }
    clear_has_payload();
  }
}
inline ::t4proto::v1::service::Heartbeat* ServerMessage::release_heartbeat() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.heartbeat)
  if (payload_case() == kHeartbeat) {
    clear_has_payload();
    auto* temp = _impl_.payload_.heartbeat_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::service::Heartbeat& ServerMessage::_internal_heartbeat() const {
  return payload_case() == kHeartbeat ? *_impl_.payload_.heartbeat_ : reinterpret_cast<::t4proto::v1::service::Heartbeat&>(::t4proto::v1::service::_Heartbeat_default_instance_);
}
inline const ::t4proto::v1::service::Heartbeat& ServerMessage::heartbeat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.heartbeat)
  return _internal_heartbeat();
}
inline ::t4proto::v1::service::Heartbeat* ServerMessage::unsafe_arena_release_heartbeat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.heartbeat)
  if (payload_case() == kHeartbeat) {
    clear_has_payload();
    auto* temp = _impl_.payload_.heartbeat_;
    _impl_.payload_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_heartbeat(::t4proto::v1::service::Heartbeat* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_heartbeat();
    _impl_.payload_.heartbeat_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.heartbeat)
}
inline ::t4proto::v1::service::Heartbeat* ServerMessage::_internal_mutable_heartbeat() {
  if (payload_case() != kHeartbeat) {
    clear_payload();
    set_has_heartbeat();
    _impl_.payload_.heartbeat_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::service::Heartbeat>(GetArena());
  }
  return _impl_.payload_.heartbeat_;
}
inline ::t4proto::v1::service::Heartbeat* ServerMessage::mutable_heartbeat() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::service::Heartbeat* _msg = _internal_mutable_heartbeat();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.heartbeat)
  return _msg;
}

// .t4proto.v1.auth.LoginResponse login_response = 2;
inline bool ServerMessage::has_login_response() const {
  return payload_case() == kLoginResponse;
}
inline bool ServerMessage::_internal_has_login_response() const {
  return payload_case() == kLoginResponse;
}
inline void ServerMessage::set_has_login_response() {
  _impl_._oneof_case_[0] = kLoginResponse;
}
inline ::t4proto::v1::auth::LoginResponse* ServerMessage::release_login_response() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.login_response)
  if (payload_case() == kLoginResponse) {
    clear_has_payload();
    auto* temp = _impl_.payload_.login_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.login_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::auth::LoginResponse& ServerMessage::_internal_login_response() const {
  return payload_case() == kLoginResponse ? *_impl_.payload_.login_response_ : reinterpret_cast<::t4proto::v1::auth::LoginResponse&>(::t4proto::v1::auth::_LoginResponse_default_instance_);
}
inline const ::t4proto::v1::auth::LoginResponse& ServerMessage::login_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.login_response)
  return _internal_login_response();
}
inline ::t4proto::v1::auth::LoginResponse* ServerMessage::unsafe_arena_release_login_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.login_response)
  if (payload_case() == kLoginResponse) {
    clear_has_payload();
    auto* temp = _impl_.payload_.login_response_;
    _impl_.payload_.login_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_login_response(::t4proto::v1::auth::LoginResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_login_response();
    _impl_.payload_.login_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.login_response)
}
inline ::t4proto::v1::auth::LoginResponse* ServerMessage::_internal_mutable_login_response() {
  if (payload_case() != kLoginResponse) {
    clear_payload();
    set_has_login_response();
    _impl_.payload_.login_response_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::auth::LoginResponse>(GetArena());
  }
  return _impl_.payload_.login_response_;
}
inline ::t4proto::v1::auth::LoginResponse* ServerMessage::mutable_login_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::auth::LoginResponse* _msg = _internal_mutable_login_response();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.login_response)
  return _msg;
}

// .t4proto.v1.auth.AuthenticationToken authentication_token = 3;
inline bool ServerMessage::has_authentication_token() const {
  return payload_case() == kAuthenticationToken;
}
inline bool ServerMessage::_internal_has_authentication_token() const {
  return payload_case() == kAuthenticationToken;
}
inline void ServerMessage::set_has_authentication_token() {
  _impl_._oneof_case_[0] = kAuthenticationToken;
}
inline ::t4proto::v1::auth::AuthenticationToken* ServerMessage::release_authentication_token() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.authentication_token)
  if (payload_case() == kAuthenticationToken) {
    clear_has_payload();
    auto* temp = _impl_.payload_.authentication_token_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.authentication_token_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::auth::AuthenticationToken& ServerMessage::_internal_authentication_token() const {
  return payload_case() == kAuthenticationToken ? *_impl_.payload_.authentication_token_ : reinterpret_cast<::t4proto::v1::auth::AuthenticationToken&>(::t4proto::v1::auth::_AuthenticationToken_default_instance_);
}
inline const ::t4proto::v1::auth::AuthenticationToken& ServerMessage::authentication_token() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.authentication_token)
  return _internal_authentication_token();
}
inline ::t4proto::v1::auth::AuthenticationToken* ServerMessage::unsafe_arena_release_authentication_token() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.authentication_token)
  if (payload_case() == kAuthenticationToken) {
    clear_has_payload();
    auto* temp = _impl_.payload_.authentication_token_;
    _impl_.payload_.authentication_token_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_authentication_token(::t4proto::v1::auth::AuthenticationToken* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_authentication_token();
    _impl_.payload_.authentication_token_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.authentication_token)
}
inline ::t4proto::v1::auth::AuthenticationToken* ServerMessage::_internal_mutable_authentication_token() {
  if (payload_case() != kAuthenticationToken) {
    clear_payload();
    set_has_authentication_token();
    _impl_.payload_.authentication_token_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::auth::AuthenticationToken>(GetArena());
  }
  return _impl_.payload_.authentication_token_;
}
inline ::t4proto::v1::auth::AuthenticationToken* ServerMessage::mutable_authentication_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::auth::AuthenticationToken* _msg = _internal_mutable_authentication_token();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.authentication_token)
  return _msg;
}

// .t4proto.v1.market.MarketDepthSubscribeReject market_depth_subscribe_reject = 100;
inline bool ServerMessage::has_market_depth_subscribe_reject() const {
  return payload_case() == kMarketDepthSubscribeReject;
}
inline bool ServerMessage::_internal_has_market_depth_subscribe_reject() const {
  return payload_case() == kMarketDepthSubscribeReject;
}
inline void ServerMessage::set_has_market_depth_subscribe_reject() {
  _impl_._oneof_case_[0] = kMarketDepthSubscribeReject;
}
inline ::t4proto::v1::market::MarketDepthSubscribeReject* ServerMessage::release_market_depth_subscribe_reject() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_depth_subscribe_reject)
  if (payload_case() == kMarketDepthSubscribeReject) {
    clear_has_payload();
    auto* temp = _impl_.payload_.market_depth_subscribe_reject_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_depth_subscribe_reject_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketDepthSubscribeReject& ServerMessage::_internal_market_depth_subscribe_reject() const {
  return payload_case() == kMarketDepthSubscribeReject ? *_impl_.payload_.market_depth_subscribe_reject_ : reinterpret_cast<::t4proto::v1::market::MarketDepthSubscribeReject&>(::t4proto::v1::market::_MarketDepthSubscribeReject_default_instance_);
}
inline const ::t4proto::v1::market::MarketDepthSubscribeReject& ServerMessage::market_depth_subscribe_reject() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_depth_subscribe_reject)
  return _internal_market_depth_subscribe_reject();
}
inline ::t4proto::v1::market::MarketDepthSubscribeReject* ServerMessage::unsafe_arena_release_market_depth_subscribe_reject() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_depth_subscribe_reject)
  if (payload_case() == kMarketDepthSubscribeReject) {
    clear_has_payload();
    auto* temp = _impl_.payload_.market_depth_subscribe_reject_;
    _impl_.payload_.market_depth_subscribe_reject_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_depth_subscribe_reject(::t4proto::v1::market::MarketDepthSubscribeReject* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_market_depth_subscribe_reject();
    _impl_.payload_.market_depth_subscribe_reject_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_depth_subscribe_reject)
}
inline ::t4proto::v1::market::MarketDepthSubscribeReject* ServerMessage::_internal_mutable_market_depth_subscribe_reject() {
  if (payload_case() != kMarketDepthSubscribeReject) {
    clear_payload();
    set_has_market_depth_subscribe_reject();
    _impl_.payload_.market_depth_subscribe_reject_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::market::MarketDepthSubscribeReject>(GetArena());
  }
  return _impl_.payload_.market_depth_subscribe_reject_;
}
inline ::t4proto::v1::market::MarketDepthSubscribeReject* ServerMessage::mutable_market_depth_subscribe_reject() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::market::MarketDepthSubscribeReject* _msg = _internal_mutable_market_depth_subscribe_reject();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_depth_subscribe_reject)
  return _msg;
}

// .t4proto.v1.market.MarketByOrderSubscribeReject market_by_order_subscribe_reject = 101;
inline bool ServerMessage::has_market_by_order_subscribe_reject() const {
  return payload_case() == kMarketByOrderSubscribeReject;
}
inline bool ServerMessage::_internal_has_market_by_order_subscribe_reject() const {
  return payload_case() == kMarketByOrderSubscribeReject;
}
inline void ServerMessage::set_has_market_by_order_subscribe_reject() {
  _impl_._oneof_case_[0] = kMarketByOrderSubscribeReject;
}
inline ::t4proto::v1::market::MarketByOrderSubscribeReject* ServerMessage::release_market_by_order_subscribe_reject() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_by_order_subscribe_reject)
  if (payload_case() == kMarketByOrderSubscribeReject) {
    clear_has_payload();
    auto* temp = _impl_.payload_.market_by_order_subscribe_reject_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_by_order_subscribe_reject_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketByOrderSubscribeReject& ServerMessage::_internal_market_by_order_subscribe_reject() const {
  return payload_case() == kMarketByOrderSubscribeReject ? *_impl_.payload_.market_by_order_subscribe_reject_ : reinterpret_cast<::t4proto::v1::market::MarketByOrderSubscribeReject&>(::t4proto::v1::market::_MarketByOrderSubscribeReject_default_instance_);
}
inline const ::t4proto::v1::market::MarketByOrderSubscribeReject& ServerMessage::market_by_order_subscribe_reject() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_by_order_subscribe_reject)
  return _internal_market_by_order_subscribe_reject();
}
inline ::t4proto::v1::market::MarketByOrderSubscribeReject* ServerMessage::unsafe_arena_release_market_by_order_subscribe_reject() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_by_order_subscribe_reject)
  if (payload_case() == kMarketByOrderSubscribeReject) {
    clear_has_payload();
    auto* temp = _impl_.payload_.market_by_order_subscribe_reject_;
    _impl_.payload_.market_by_order_subscribe_reject_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_by_order_subscribe_reject(::t4proto::v1::market::MarketByOrderSubscribeReject* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_market_by_order_subscribe_reject();
    _impl_.payload_.market_by_order_subscribe_reject_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_by_order_subscribe_reject)
}
inline ::t4proto::v1::market::MarketByOrderSubscribeReject* ServerMessage::_internal_mutable_market_by_order_subscribe_reject() {
  if (payload_case() != kMarketByOrderSubscribeReject) {
    clear_payload();
    set_has_market_by_order_subscribe_reject();
    _impl_.payload_.market_by_order_subscribe_reject_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::market::MarketByOrderSubscribeReject>(GetArena());
  }
  return _impl_.payload_.market_by_order_subscribe_reject_;
}
inline ::t4proto::v1::market::MarketByOrderSubscribeReject* ServerMessage::mutable_market_by_order_subscribe_reject() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::market::MarketByOrderSubscribeReject* _msg = _internal_mutable_market_by_order_subscribe_reject();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_by_order_subscribe_reject)
  return _msg;
}

// .t4proto.v1.market.MarketDetails market_details = 102;
inline bool ServerMessage::has_market_details() const {
  return payload_case() == kMarketDetails;
}
inline bool ServerMessage::_internal_has_market_details() const {
  return payload_case() == kMarketDetails;
}
inline void ServerMessage::set_has_market_details() {
  _impl_._oneof_case_[0] = kMarketDetails;
}
inline ::t4proto::v1::market::MarketDetails* ServerMessage::release_market_details() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_details)
  if (payload_case() == kMarketDetails) {
    clear_has_payload();
    auto* temp = _impl_.payload_.market_details_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_details_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketDetails& ServerMessage::_internal_market_details() const {
  return payload_case() == kMarketDetails ? *_impl_.payload_.market_details_ : reinterpret_cast<::t4proto::v1::market::MarketDetails&>(::t4proto::v1::market::_MarketDetails_default_instance_);
}
inline const ::t4proto::v1::market::MarketDetails& ServerMessage::market_details() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_details)
  return _internal_market_details();
}
inline ::t4proto::v1::market::MarketDetails* ServerMessage::unsafe_arena_release_market_details() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_details)
  if (payload_case() == kMarketDetails) {
    clear_has_payload();
    auto* temp = _impl_.payload_.market_details_;
    _impl_.payload_.market_details_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_details(::t4proto::v1::market::MarketDetails* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_market_details();
    _impl_.payload_.market_details_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_details)
}
inline ::t4proto::v1::market::MarketDetails* ServerMessage::_internal_mutable_market_details() {
  if (payload_case() != kMarketDetails) {
    clear_payload();
    set_has_market_details();
    _impl_.payload_.market_details_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::market::MarketDetails>(GetArena());
  }
  return _impl_.payload_.market_details_;
}
inline ::t4proto::v1::market::MarketDetails* ServerMessage::mutable_market_details() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::market::MarketDetails* _msg = _internal_mutable_market_details();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_details)
  return _msg;
}

// .t4proto.v1.market.MarketDepth market_depth = 103;
inline bool ServerMessage::has_market_depth() const {
  return payload_case() == kMarketDepth;
}
inline bool ServerMessage::_internal_has_market_depth() const {
  return payload_case() == kMarketDepth;
}
inline void ServerMessage::set_has_market_depth() {
  _impl_._oneof_case_[0] = kMarketDepth;
}
inline ::t4proto::v1::market::MarketDepth* ServerMessage::release_market_depth() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_depth)
  if (payload_case() == kMarketDepth) {
    clear_has_payload();
    auto* temp = _impl_.payload_.market_depth_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_depth_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketDepth& ServerMessage::_internal_market_depth() const {
  return payload_case() == kMarketDepth ? *_impl_.payload_.market_depth_ : reinterpret_cast<::t4proto::v1::market::MarketDepth&>(::t4proto::v1::market::_MarketDepth_default_instance_);
}
inline const ::t4proto::v1::market::MarketDepth& ServerMessage::market_depth() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_depth)
  return _internal_market_depth();
}
inline ::t4proto::v1::market::MarketDepth* ServerMessage::unsafe_arena_release_market_depth() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_depth)
  if (payload_case() == kMarketDepth) {
    clear_has_payload();
    auto* temp = _impl_.payload_.market_depth_;
    _impl_.payload_.market_depth_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_depth(::t4proto::v1::market::MarketDepth* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_market_depth();
    _impl_.payload_.market_depth_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_depth)
}
inline ::t4proto::v1::market::MarketDepth* ServerMessage::_internal_mutable_market_depth() {
  if (payload_case() != kMarketDepth) {
    clear_payload();
    set_has_market_depth();
    _impl_.payload_.market_depth_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::market::MarketDepth>(GetArena());
  }
  return _impl_.payload_.market_depth_;
}
inline ::t4proto::v1::market::MarketDepth* ServerMessage::mutable_market_depth() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::market::MarketDepth* _msg = _internal_mutable_market_depth();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_depth)
  return _msg;
}

// .t4proto.v1.market.MarketDepthTrade market_depth_trade = 104;
inline bool ServerMessage::has_market_depth_trade() const {
  return payload_case() == kMarketDepthTrade;
}
inline bool ServerMessage::_internal_has_market_depth_trade() const {
  return payload_case() == kMarketDepthTrade;
}
inline void ServerMessage::set_has_market_depth_trade() {
  _impl_._oneof_case_[0] = kMarketDepthTrade;
}
inline ::t4proto::v1::market::MarketDepthTrade* ServerMessage::release_market_depth_trade() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_depth_trade)
  if (payload_case() == kMarketDepthTrade) {
    clear_has_payload();
    auto* temp = _impl_.payload_.market_depth_trade_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_depth_trade_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketDepthTrade& ServerMessage::_internal_market_depth_trade() const {
  return payload_case() == kMarketDepthTrade ? *_impl_.payload_.market_depth_trade_ : reinterpret_cast<::t4proto::v1::market::MarketDepthTrade&>(::t4proto::v1::market::_MarketDepthTrade_default_instance_);
}
inline const ::t4proto::v1::market::MarketDepthTrade& ServerMessage::market_depth_trade() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_depth_trade)
  return _internal_market_depth_trade();
}
inline ::t4proto::v1::market::MarketDepthTrade* ServerMessage::unsafe_arena_release_market_depth_trade() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_depth_trade)
  if (payload_case() == kMarketDepthTrade) {
    clear_has_payload();
    auto* temp = _impl_.payload_.market_depth_trade_;
    _impl_.payload_.market_depth_trade_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_depth_trade(::t4proto::v1::market::MarketDepthTrade* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_market_depth_trade();
    _impl_.payload_.market_depth_trade_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_depth_trade)
}
inline ::t4proto::v1::market::MarketDepthTrade* ServerMessage::_internal_mutable_market_depth_trade() {
  if (payload_case() != kMarketDepthTrade) {
    clear_payload();
    set_has_market_depth_trade();
    _impl_.payload_.market_depth_trade_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::market::MarketDepthTrade>(GetArena());
  }
  return _impl_.payload_.market_depth_trade_;
}
inline ::t4proto::v1::market::MarketDepthTrade* ServerMessage::mutable_market_depth_trade() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::market::MarketDepthTrade* _msg = _internal_mutable_market_depth_trade();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_depth_trade)
  return _msg;
}

// .t4proto.v1.market.MarketHighLow market_high_low = 105;
inline bool ServerMessage::has_market_high_low() const {
  return payload_case() == kMarketHighLow;
}
inline bool ServerMessage::_internal_has_market_high_low() const {
  return payload_case() == kMarketHighLow;
}
inline void ServerMessage::set_has_market_high_low() {
  _impl_._oneof_case_[0] = kMarketHighLow;
}
inline ::t4proto::v1::market::MarketHighLow* ServerMessage::release_market_high_low() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_high_low)
  if (payload_case() == kMarketHighLow) {
    clear_has_payload();
    auto* temp = _impl_.payload_.market_high_low_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_high_low_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketHighLow& ServerMessage::_internal_market_high_low() const {
  return payload_case() == kMarketHighLow ? *_impl_.payload_.market_high_low_ : reinterpret_cast<::t4proto::v1::market::MarketHighLow&>(::t4proto::v1::market::_MarketHighLow_default_instance_);
}
inline const ::t4proto::v1::market::MarketHighLow& ServerMessage::market_high_low() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_high_low)
  return _internal_market_high_low();
}
inline ::t4proto::v1::market::MarketHighLow* ServerMessage::unsafe_arena_release_market_high_low() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_high_low)
  if (payload_case() == kMarketHighLow) {
    clear_has_payload();
    auto* temp = _impl_.payload_.market_high_low_;
    _impl_.payload_.market_high_low_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_high_low(::t4proto::v1::market::MarketHighLow* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_market_high_low();
    _impl_.payload_.market_high_low_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_high_low)
}
inline ::t4proto::v1::market::MarketHighLow* ServerMessage::_internal_mutable_market_high_low() {
  if (payload_case() != kMarketHighLow) {
    clear_payload();
    set_has_market_high_low();
    _impl_.payload_.market_high_low_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::market::MarketHighLow>(GetArena());
  }
  return _impl_.payload_.market_high_low_;
}
inline ::t4proto::v1::market::MarketHighLow* ServerMessage::mutable_market_high_low() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::market::MarketHighLow* _msg = _internal_mutable_market_high_low();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_high_low)
  return _msg;
}

// .t4proto.v1.market.MarketPriceLimits market_price_limits = 106;
inline bool ServerMessage::has_market_price_limits() const {
  return payload_case() == kMarketPriceLimits;
}
inline bool ServerMessage::_internal_has_market_price_limits() const {
  return payload_case() == kMarketPriceLimits;
}
inline void ServerMessage::set_has_market_price_limits() {
  _impl_._oneof_case_[0] = kMarketPriceLimits;
}
inline ::t4proto::v1::market::MarketPriceLimits* ServerMessage::release_market_price_limits() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_price_limits)
  if (payload_case() == kMarketPriceLimits) {
    clear_has_payload();
    auto* temp = _impl_.payload_.market_price_limits_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_price_limits_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketPriceLimits& ServerMessage::_internal_market_price_limits() const {
  return payload_case() == kMarketPriceLimits ? *_impl_.payload_.market_price_limits_ : reinterpret_cast<::t4proto::v1::market::MarketPriceLimits&>(::t4proto::v1::market::_MarketPriceLimits_default_instance_);
}
inline const ::t4proto::v1::market::MarketPriceLimits& ServerMessage::market_price_limits() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_price_limits)
  return _internal_market_price_limits();
}
inline ::t4proto::v1::market::MarketPriceLimits* ServerMessage::unsafe_arena_release_market_price_limits() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_price_limits)
  if (payload_case() == kMarketPriceLimits) {
    clear_has_payload();
    auto* temp = _impl_.payload_.market_price_limits_;
    _impl_.payload_.market_price_limits_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_price_limits(::t4proto::v1::market::MarketPriceLimits* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_market_price_limits();
    _impl_.payload_.market_price_limits_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_price_limits)
}
inline ::t4proto::v1::market::MarketPriceLimits* ServerMessage::_internal_mutable_market_price_limits() {
  if (payload_case() != kMarketPriceLimits) {
    clear_payload();
    set_has_market_price_limits();
    _impl_.payload_.market_price_limits_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::market::MarketPriceLimits>(GetArena());
  }
  return _impl_.payload_.market_price_limits_;
}
inline ::t4proto::v1::market::MarketPriceLimits* ServerMessage::mutable_market_price_limits() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::market::MarketPriceLimits* _msg = _internal_mutable_market_price_limits();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_price_limits)
  return _msg;
}

// .t4proto.v1.market.MarketSettlement market_settlement = 107;
inline bool ServerMessage::has_market_settlement() const {
  return payload_case() == kMarketSettlement;
}
inline bool ServerMessage::_internal_has_market_settlement() const {
  return payload_case() == kMarketSettlement;
}
inline void ServerMessage::set_has_market_settlement() {
  _impl_._oneof_case_[0] = kMarketSettlement;
}
inline ::t4proto::v1::market::MarketSettlement* ServerMessage::release_market_settlement() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_settlement)
  if (payload_case() == kMarketSettlement) {
    clear_has_payload();
    auto* temp = _impl_.payload_.market_settlement_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_settlement_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketSettlement& ServerMessage::_internal_market_settlement() const {
  return payload_case() == kMarketSettlement ? *_impl_.payload_.market_settlement_ : reinterpret_cast<::t4proto::v1::market::MarketSettlement&>(::t4proto::v1::market::_MarketSettlement_default_instance_);
}
inline const ::t4proto::v1::market::MarketSettlement& ServerMessage::market_settlement() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_settlement)
  return _internal_market_settlement();
}
inline ::t4proto::v1::market::MarketSettlement* ServerMessage::unsafe_arena_release_market_settlement() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_settlement)
  if (payload_case() == kMarketSettlement) {
    clear_has_payload();
    auto* temp = _impl_.payload_.market_settlement_;
    _impl_.payload_.market_settlement_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_settlement(::t4proto::v1::market::MarketSettlement* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_market_settlement();
    _impl_.payload_.market_settlement_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_settlement)
}
inline ::t4proto::v1::market::MarketSettlement* ServerMessage::_internal_mutable_market_settlement() {
  if (payload_case() != kMarketSettlement) {
    clear_payload();
    set_has_market_settlement();
    _impl_.payload_.market_settlement_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::market::MarketSettlement>(GetArena());
  }
  return _impl_.payload_.market_settlement_;
}
inline ::t4proto::v1::market::MarketSettlement* ServerMessage::mutable_market_settlement() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::market::MarketSettlement* _msg = _internal_mutable_market_settlement();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_settlement)
  return _msg;
}

// .t4proto.v1.market.MarketSnapshot market_snapshot = 108;
inline bool ServerMessage::has_market_snapshot() const {
  return payload_case() == kMarketSnapshot;
}
inline bool ServerMessage::_internal_has_market_snapshot() const {
  return payload_case() == kMarketSnapshot;
}
inline void ServerMessage::set_has_market_snapshot() {
  _impl_._oneof_case_[0] = kMarketSnapshot;
}
inline ::t4proto::v1::market::MarketSnapshot* ServerMessage::release_market_snapshot() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_snapshot)
  if (payload_case() == kMarketSnapshot) {
    clear_has_payload();
    auto* temp = _impl_.payload_.market_snapshot_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketSnapshot& ServerMessage::_internal_market_snapshot() const {
  return payload_case() == kMarketSnapshot ? *_impl_.payload_.market_snapshot_ : reinterpret_cast<::t4proto::v1::market::MarketSnapshot&>(::t4proto::v1::market::_MarketSnapshot_default_instance_);
}
inline const ::t4proto::v1::market::MarketSnapshot& ServerMessage::market_snapshot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_snapshot)
  return _internal_market_snapshot();
}
inline ::t4proto::v1::market::MarketSnapshot* ServerMessage::unsafe_arena_release_market_snapshot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_snapshot)
  if (payload_case() == kMarketSnapshot) {
    clear_has_payload();
    auto* temp = _impl_.payload_.market_snapshot_;
    _impl_.payload_.market_snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_snapshot(::t4proto::v1::market::MarketSnapshot* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_market_snapshot();
    _impl_.payload_.market_snapshot_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_snapshot)
}
inline ::t4proto::v1::market::MarketSnapshot* ServerMessage::_internal_mutable_market_snapshot() {
  if (payload_case() != kMarketSnapshot) {
    clear_payload();
    set_has_market_snapshot();
    _impl_.payload_.market_snapshot_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::market::MarketSnapshot>(GetArena());
  }
  return _impl_.payload_.market_snapshot_;
}
inline ::t4proto::v1::market::MarketSnapshot* ServerMessage::mutable_market_snapshot() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::market::MarketSnapshot* _msg = _internal_mutable_market_snapshot();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_snapshot)
  return _msg;
}

// .t4proto.v1.market.MarketByOrderSnapshot market_by_order_snapshot = 109;
inline bool ServerMessage::has_market_by_order_snapshot() const {
  return payload_case() == kMarketByOrderSnapshot;
}
inline bool ServerMessage::_internal_has_market_by_order_snapshot() const {
  return payload_case() == kMarketByOrderSnapshot;
}
inline void ServerMessage::set_has_market_by_order_snapshot() {
  _impl_._oneof_case_[0] = kMarketByOrderSnapshot;
}
inline ::t4proto::v1::market::MarketByOrderSnapshot* ServerMessage::release_market_by_order_snapshot() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_by_order_snapshot)
  if (payload_case() == kMarketByOrderSnapshot) {
    clear_has_payload();
    auto* temp = _impl_.payload_.market_by_order_snapshot_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_by_order_snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketByOrderSnapshot& ServerMessage::_internal_market_by_order_snapshot() const {
  return payload_case() == kMarketByOrderSnapshot ? *_impl_.payload_.market_by_order_snapshot_ : reinterpret_cast<::t4proto::v1::market::MarketByOrderSnapshot&>(::t4proto::v1::market::_MarketByOrderSnapshot_default_instance_);
}
inline const ::t4proto::v1::market::MarketByOrderSnapshot& ServerMessage::market_by_order_snapshot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_by_order_snapshot)
  return _internal_market_by_order_snapshot();
}
inline ::t4proto::v1::market::MarketByOrderSnapshot* ServerMessage::unsafe_arena_release_market_by_order_snapshot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_by_order_snapshot)
  if (payload_case() == kMarketByOrderSnapshot) {
    clear_has_payload();
    auto* temp = _impl_.payload_.market_by_order_snapshot_;
    _impl_.payload_.market_by_order_snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_by_order_snapshot(::t4proto::v1::market::MarketByOrderSnapshot* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_market_by_order_snapshot();
    _impl_.payload_.market_by_order_snapshot_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_by_order_snapshot)
}
inline ::t4proto::v1::market::MarketByOrderSnapshot* ServerMessage::_internal_mutable_market_by_order_snapshot() {
  if (payload_case() != kMarketByOrderSnapshot) {
    clear_payload();
    set_has_market_by_order_snapshot();
    _impl_.payload_.market_by_order_snapshot_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::market::MarketByOrderSnapshot>(GetArena());
  }
  return _impl_.payload_.market_by_order_snapshot_;
}
inline ::t4proto::v1::market::MarketByOrderSnapshot* ServerMessage::mutable_market_by_order_snapshot() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::market::MarketByOrderSnapshot* _msg = _internal_mutable_market_by_order_snapshot();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_by_order_snapshot)
  return _msg;
}

// .t4proto.v1.market.MarketByOrderUpdate market_by_order_update = 110;
inline bool ServerMessage::has_market_by_order_update() const {
  return payload_case() == kMarketByOrderUpdate;
}
inline bool ServerMessage::_internal_has_market_by_order_update() const {
  return payload_case() == kMarketByOrderUpdate;
}
inline void ServerMessage::set_has_market_by_order_update() {
  _impl_._oneof_case_[0] = kMarketByOrderUpdate;
}
inline ::t4proto::v1::market::MarketByOrderUpdate* ServerMessage::release_market_by_order_update() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_by_order_update)
  if (payload_case() == kMarketByOrderUpdate) {
    clear_has_payload();
    auto* temp = _impl_.payload_.market_by_order_update_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_by_order_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketByOrderUpdate& ServerMessage::_internal_market_by_order_update() const {
  return payload_case() == kMarketByOrderUpdate ? *_impl_.payload_.market_by_order_update_ : reinterpret_cast<::t4proto::v1::market::MarketByOrderUpdate&>(::t4proto::v1::market::_MarketByOrderUpdate_default_instance_);
}
inline const ::t4proto::v1::market::MarketByOrderUpdate& ServerMessage::market_by_order_update() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_by_order_update)
  return _internal_market_by_order_update();
}
inline ::t4proto::v1::market::MarketByOrderUpdate* ServerMessage::unsafe_arena_release_market_by_order_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_by_order_update)
  if (payload_case() == kMarketByOrderUpdate) {
    clear_has_payload();
    auto* temp = _impl_.payload_.market_by_order_update_;
    _impl_.payload_.market_by_order_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_by_order_update(::t4proto::v1::market::MarketByOrderUpdate* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_market_by_order_update();
    _impl_.payload_.market_by_order_update_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_by_order_update)
}
inline ::t4proto::v1::market::MarketByOrderUpdate* ServerMessage::_internal_mutable_market_by_order_update() {
  if (payload_case() != kMarketByOrderUpdate) {
    clear_payload();
    set_has_market_by_order_update();
    _impl_.payload_.market_by_order_update_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::market::MarketByOrderUpdate>(GetArena());
  }
  return _impl_.payload_.market_by_order_update_;
}
inline ::t4proto::v1::market::MarketByOrderUpdate* ServerMessage::mutable_market_by_order_update() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::market::MarketByOrderUpdate* _msg = _internal_mutable_market_by_order_update();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_by_order_update)
  return _msg;
}

// .t4proto.v1.account.AccountSubscribeResponse account_subscribe_response = 200;
inline bool ServerMessage::has_account_subscribe_response() const {
  return payload_case() == kAccountSubscribeResponse;
}
inline bool ServerMessage::_internal_has_account_subscribe_response() const {
  return payload_case() == kAccountSubscribeResponse;
}
inline void ServerMessage::set_has_account_subscribe_response() {
  _impl_._oneof_case_[0] = kAccountSubscribeResponse;
}
inline ::t4proto::v1::account::AccountSubscribeResponse* ServerMessage::release_account_subscribe_response() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.account_subscribe_response)
  if (payload_case() == kAccountSubscribeResponse) {
    clear_has_payload();
    auto* temp = _impl_.payload_.account_subscribe_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.account_subscribe_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::account::AccountSubscribeResponse& ServerMessage::_internal_account_subscribe_response() const {
  return payload_case() == kAccountSubscribeResponse ? *_impl_.payload_.account_subscribe_response_ : reinterpret_cast<::t4proto::v1::account::AccountSubscribeResponse&>(::t4proto::v1::account::_AccountSubscribeResponse_default_instance_);
}
inline const ::t4proto::v1::account::AccountSubscribeResponse& ServerMessage::account_subscribe_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.account_subscribe_response)
  return _internal_account_subscribe_response();
}
inline ::t4proto::v1::account::AccountSubscribeResponse* ServerMessage::unsafe_arena_release_account_subscribe_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.account_subscribe_response)
  if (payload_case() == kAccountSubscribeResponse) {
    clear_has_payload();
    auto* temp = _impl_.payload_.account_subscribe_response_;
    _impl_.payload_.account_subscribe_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_account_subscribe_response(::t4proto::v1::account::AccountSubscribeResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_account_subscribe_response();
    _impl_.payload_.account_subscribe_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.account_subscribe_response)
}
inline ::t4proto::v1::account::AccountSubscribeResponse* ServerMessage::_internal_mutable_account_subscribe_response() {
  if (payload_case() != kAccountSubscribeResponse) {
    clear_payload();
    set_has_account_subscribe_response();
    _impl_.payload_.account_subscribe_response_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::account::AccountSubscribeResponse>(GetArena());
  }
  return _impl_.payload_.account_subscribe_response_;
}
inline ::t4proto::v1::account::AccountSubscribeResponse* ServerMessage::mutable_account_subscribe_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::account::AccountSubscribeResponse* _msg = _internal_mutable_account_subscribe_response();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.account_subscribe_response)
  return _msg;
}

// .t4proto.v1.account.AccountCurrency account_currency = 201;
inline bool ServerMessage::has_account_currency() const {
  return payload_case() == kAccountCurrency;
}
inline bool ServerMessage::_internal_has_account_currency() const {
  return payload_case() == kAccountCurrency;
}
inline void ServerMessage::set_has_account_currency() {
  _impl_._oneof_case_[0] = kAccountCurrency;
}
inline ::t4proto::v1::account::AccountCurrency* ServerMessage::release_account_currency() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.account_currency)
  if (payload_case() == kAccountCurrency) {
    clear_has_payload();
    auto* temp = _impl_.payload_.account_currency_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.account_currency_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::account::AccountCurrency& ServerMessage::_internal_account_currency() const {
  return payload_case() == kAccountCurrency ? *_impl_.payload_.account_currency_ : reinterpret_cast<::t4proto::v1::account::AccountCurrency&>(::t4proto::v1::account::_AccountCurrency_default_instance_);
}
inline const ::t4proto::v1::account::AccountCurrency& ServerMessage::account_currency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.account_currency)
  return _internal_account_currency();
}
inline ::t4proto::v1::account::AccountCurrency* ServerMessage::unsafe_arena_release_account_currency() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.account_currency)
  if (payload_case() == kAccountCurrency) {
    clear_has_payload();
    auto* temp = _impl_.payload_.account_currency_;
    _impl_.payload_.account_currency_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_account_currency(::t4proto::v1::account::AccountCurrency* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_account_currency();
    _impl_.payload_.account_currency_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.account_currency)
}
inline ::t4proto::v1::account::AccountCurrency* ServerMessage::_internal_mutable_account_currency() {
  if (payload_case() != kAccountCurrency) {
    clear_payload();
    set_has_account_currency();
    _impl_.payload_.account_currency_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::account::AccountCurrency>(GetArena());
  }
  return _impl_.payload_.account_currency_;
}
inline ::t4proto::v1::account::AccountCurrency* ServerMessage::mutable_account_currency() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::account::AccountCurrency* _msg = _internal_mutable_account_currency();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.account_currency)
  return _msg;
}

// .t4proto.v1.account.AccountPosition account_position = 202;
inline bool ServerMessage::has_account_position() const {
  return payload_case() == kAccountPosition;
}
inline bool ServerMessage::_internal_has_account_position() const {
  return payload_case() == kAccountPosition;
}
inline void ServerMessage::set_has_account_position() {
  _impl_._oneof_case_[0] = kAccountPosition;
}
inline ::t4proto::v1::account::AccountPosition* ServerMessage::release_account_position() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.account_position)
  if (payload_case() == kAccountPosition) {
    clear_has_payload();
    auto* temp = _impl_.payload_.account_position_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.account_position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::account::AccountPosition& ServerMessage::_internal_account_position() const {
  return payload_case() == kAccountPosition ? *_impl_.payload_.account_position_ : reinterpret_cast<::t4proto::v1::account::AccountPosition&>(::t4proto::v1::account::_AccountPosition_default_instance_);
}
inline const ::t4proto::v1::account::AccountPosition& ServerMessage::account_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.account_position)
  return _internal_account_position();
}
inline ::t4proto::v1::account::AccountPosition* ServerMessage::unsafe_arena_release_account_position() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.account_position)
  if (payload_case() == kAccountPosition) {
    clear_has_payload();
    auto* temp = _impl_.payload_.account_position_;
    _impl_.payload_.account_position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_account_position(::t4proto::v1::account::AccountPosition* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_account_position();
    _impl_.payload_.account_position_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.account_position)
}
inline ::t4proto::v1::account::AccountPosition* ServerMessage::_internal_mutable_account_position() {
  if (payload_case() != kAccountPosition) {
    clear_payload();
    set_has_account_position();
    _impl_.payload_.account_position_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::account::AccountPosition>(GetArena());
  }
  return _impl_.payload_.account_position_;
}
inline ::t4proto::v1::account::AccountPosition* ServerMessage::mutable_account_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::account::AccountPosition* _msg = _internal_mutable_account_position();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.account_position)
  return _msg;
}

// .t4proto.v1.account.AccountUpdate account_update = 203;
inline bool ServerMessage::has_account_update() const {
  return payload_case() == kAccountUpdate;
}
inline bool ServerMessage::_internal_has_account_update() const {
  return payload_case() == kAccountUpdate;
}
inline void ServerMessage::set_has_account_update() {
  _impl_._oneof_case_[0] = kAccountUpdate;
}
inline ::t4proto::v1::account::AccountUpdate* ServerMessage::release_account_update() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.account_update)
  if (payload_case() == kAccountUpdate) {
    clear_has_payload();
    auto* temp = _impl_.payload_.account_update_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.account_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::account::AccountUpdate& ServerMessage::_internal_account_update() const {
  return payload_case() == kAccountUpdate ? *_impl_.payload_.account_update_ : reinterpret_cast<::t4proto::v1::account::AccountUpdate&>(::t4proto::v1::account::_AccountUpdate_default_instance_);
}
inline const ::t4proto::v1::account::AccountUpdate& ServerMessage::account_update() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.account_update)
  return _internal_account_update();
}
inline ::t4proto::v1::account::AccountUpdate* ServerMessage::unsafe_arena_release_account_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.account_update)
  if (payload_case() == kAccountUpdate) {
    clear_has_payload();
    auto* temp = _impl_.payload_.account_update_;
    _impl_.payload_.account_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_account_update(::t4proto::v1::account::AccountUpdate* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_account_update();
    _impl_.payload_.account_update_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.account_update)
}
inline ::t4proto::v1::account::AccountUpdate* ServerMessage::_internal_mutable_account_update() {
  if (payload_case() != kAccountUpdate) {
    clear_payload();
    set_has_account_update();
    _impl_.payload_.account_update_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::account::AccountUpdate>(GetArena());
  }
  return _impl_.payload_.account_update_;
}
inline ::t4proto::v1::account::AccountUpdate* ServerMessage::mutable_account_update() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::account::AccountUpdate* _msg = _internal_mutable_account_update();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.account_update)
  return _msg;
}

// .t4proto.v1.account.AccountDetails account_details = 204;
inline bool ServerMessage::has_account_details() const {
  return payload_case() == kAccountDetails;
}
inline bool ServerMessage::_internal_has_account_details() const {
  return payload_case() == kAccountDetails;
}
inline void ServerMessage::set_has_account_details() {
  _impl_._oneof_case_[0] = kAccountDetails;
}
inline ::t4proto::v1::account::AccountDetails* ServerMessage::release_account_details() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.account_details)
  if (payload_case() == kAccountDetails) {
    clear_has_payload();
    auto* temp = _impl_.payload_.account_details_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.account_details_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::account::AccountDetails& ServerMessage::_internal_account_details() const {
  return payload_case() == kAccountDetails ? *_impl_.payload_.account_details_ : reinterpret_cast<::t4proto::v1::account::AccountDetails&>(::t4proto::v1::account::_AccountDetails_default_instance_);
}
inline const ::t4proto::v1::account::AccountDetails& ServerMessage::account_details() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.account_details)
  return _internal_account_details();
}
inline ::t4proto::v1::account::AccountDetails* ServerMessage::unsafe_arena_release_account_details() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.account_details)
  if (payload_case() == kAccountDetails) {
    clear_has_payload();
    auto* temp = _impl_.payload_.account_details_;
    _impl_.payload_.account_details_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_account_details(::t4proto::v1::account::AccountDetails* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_account_details();
    _impl_.payload_.account_details_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.account_details)
}
inline ::t4proto::v1::account::AccountDetails* ServerMessage::_internal_mutable_account_details() {
  if (payload_case() != kAccountDetails) {
    clear_payload();
    set_has_account_details();
    _impl_.payload_.account_details_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::account::AccountDetails>(GetArena());
  }
  return _impl_.payload_.account_details_;
}
inline ::t4proto::v1::account::AccountDetails* ServerMessage::mutable_account_details() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::account::AccountDetails* _msg = _internal_mutable_account_details();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.account_details)
  return _msg;
}

// .t4proto.v1.account.AccountSnapshot account_snapshot = 205;
inline bool ServerMessage::has_account_snapshot() const {
  return payload_case() == kAccountSnapshot;
}
inline bool ServerMessage::_internal_has_account_snapshot() const {
  return payload_case() == kAccountSnapshot;
}
inline void ServerMessage::set_has_account_snapshot() {
  _impl_._oneof_case_[0] = kAccountSnapshot;
}
inline ::t4proto::v1::account::AccountSnapshot* ServerMessage::release_account_snapshot() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.account_snapshot)
  if (payload_case() == kAccountSnapshot) {
    clear_has_payload();
    auto* temp = _impl_.payload_.account_snapshot_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.account_snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::account::AccountSnapshot& ServerMessage::_internal_account_snapshot() const {
  return payload_case() == kAccountSnapshot ? *_impl_.payload_.account_snapshot_ : reinterpret_cast<::t4proto::v1::account::AccountSnapshot&>(::t4proto::v1::account::_AccountSnapshot_default_instance_);
}
inline const ::t4proto::v1::account::AccountSnapshot& ServerMessage::account_snapshot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.account_snapshot)
  return _internal_account_snapshot();
}
inline ::t4proto::v1::account::AccountSnapshot* ServerMessage::unsafe_arena_release_account_snapshot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.account_snapshot)
  if (payload_case() == kAccountSnapshot) {
    clear_has_payload();
    auto* temp = _impl_.payload_.account_snapshot_;
    _impl_.payload_.account_snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_account_snapshot(::t4proto::v1::account::AccountSnapshot* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_account_snapshot();
    _impl_.payload_.account_snapshot_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.account_snapshot)
}
inline ::t4proto::v1::account::AccountSnapshot* ServerMessage::_internal_mutable_account_snapshot() {
  if (payload_case() != kAccountSnapshot) {
    clear_payload();
    set_has_account_snapshot();
    _impl_.payload_.account_snapshot_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::account::AccountSnapshot>(GetArena());
  }
  return _impl_.payload_.account_snapshot_;
}
inline ::t4proto::v1::account::AccountSnapshot* ServerMessage::mutable_account_snapshot() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::account::AccountSnapshot* _msg = _internal_mutable_account_snapshot();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.account_snapshot)
  return _msg;
}

// .t4proto.v1.account.AccountProfit account_profit = 206;
inline bool ServerMessage::has_account_profit() const {
  return payload_case() == kAccountProfit;
}
inline bool ServerMessage::_internal_has_account_profit() const {
  return payload_case() == kAccountProfit;
}
inline void ServerMessage::set_has_account_profit() {
  _impl_._oneof_case_[0] = kAccountProfit;
}
inline ::t4proto::v1::account::AccountProfit* ServerMessage::release_account_profit() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.account_profit)
  if (payload_case() == kAccountProfit) {
    clear_has_payload();
    auto* temp = _impl_.payload_.account_profit_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.account_profit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::account::AccountProfit& ServerMessage::_internal_account_profit() const {
  return payload_case() == kAccountProfit ? *_impl_.payload_.account_profit_ : reinterpret_cast<::t4proto::v1::account::AccountProfit&>(::t4proto::v1::account::_AccountProfit_default_instance_);
}
inline const ::t4proto::v1::account::AccountProfit& ServerMessage::account_profit() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.account_profit)
  return _internal_account_profit();
}
inline ::t4proto::v1::account::AccountProfit* ServerMessage::unsafe_arena_release_account_profit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.account_profit)
  if (payload_case() == kAccountProfit) {
    clear_has_payload();
    auto* temp = _impl_.payload_.account_profit_;
    _impl_.payload_.account_profit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_account_profit(::t4proto::v1::account::AccountProfit* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_account_profit();
    _impl_.payload_.account_profit_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.account_profit)
}
inline ::t4proto::v1::account::AccountProfit* ServerMessage::_internal_mutable_account_profit() {
  if (payload_case() != kAccountProfit) {
    clear_payload();
    set_has_account_profit();
    _impl_.payload_.account_profit_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::account::AccountProfit>(GetArena());
  }
  return _impl_.payload_.account_profit_;
}
inline ::t4proto::v1::account::AccountProfit* ServerMessage::mutable_account_profit() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::account::AccountProfit* _msg = _internal_mutable_account_profit();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.account_profit)
  return _msg;
}

// .t4proto.v1.account.AccountPositionProfit account_position_profit = 207;
inline bool ServerMessage::has_account_position_profit() const {
  return payload_case() == kAccountPositionProfit;
}
inline bool ServerMessage::_internal_has_account_position_profit() const {
  return payload_case() == kAccountPositionProfit;
}
inline void ServerMessage::set_has_account_position_profit() {
  _impl_._oneof_case_[0] = kAccountPositionProfit;
}
inline ::t4proto::v1::account::AccountPositionProfit* ServerMessage::release_account_position_profit() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.account_position_profit)
  if (payload_case() == kAccountPositionProfit) {
    clear_has_payload();
    auto* temp = _impl_.payload_.account_position_profit_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.account_position_profit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::account::AccountPositionProfit& ServerMessage::_internal_account_position_profit() const {
  return payload_case() == kAccountPositionProfit ? *_impl_.payload_.account_position_profit_ : reinterpret_cast<::t4proto::v1::account::AccountPositionProfit&>(::t4proto::v1::account::_AccountPositionProfit_default_instance_);
}
inline const ::t4proto::v1::account::AccountPositionProfit& ServerMessage::account_position_profit() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.account_position_profit)
  return _internal_account_position_profit();
}
inline ::t4proto::v1::account::AccountPositionProfit* ServerMessage::unsafe_arena_release_account_position_profit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.account_position_profit)
  if (payload_case() == kAccountPositionProfit) {
    clear_has_payload();
    auto* temp = _impl_.payload_.account_position_profit_;
    _impl_.payload_.account_position_profit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_account_position_profit(::t4proto::v1::account::AccountPositionProfit* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_account_position_profit();
    _impl_.payload_.account_position_profit_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.account_position_profit)
}
inline ::t4proto::v1::account::AccountPositionProfit* ServerMessage::_internal_mutable_account_position_profit() {
  if (payload_case() != kAccountPositionProfit) {
    clear_payload();
    set_has_account_position_profit();
    _impl_.payload_.account_position_profit_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::account::AccountPositionProfit>(GetArena());
  }
  return _impl_.payload_.account_position_profit_;
}
inline ::t4proto::v1::account::AccountPositionProfit* ServerMessage::mutable_account_position_profit() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::account::AccountPositionProfit* _msg = _internal_mutable_account_position_profit();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.account_position_profit)
  return _msg;
}

// .t4proto.v1.orderrouting.OrderUpdate order_update = 300;
inline bool ServerMessage::has_order_update() const {
  return payload_case() == kOrderUpdate;
}
inline bool ServerMessage::_internal_has_order_update() const {
  return payload_case() == kOrderUpdate;
}
inline void ServerMessage::set_has_order_update() {
  _impl_._oneof_case_[0] = kOrderUpdate;
}
inline ::t4proto::v1::orderrouting::OrderUpdate* ServerMessage::release_order_update() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.order_update)
  if (payload_case() == kOrderUpdate) {
    clear_has_payload();
    auto* temp = _impl_.payload_.order_update_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.order_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::OrderUpdate& ServerMessage::_internal_order_update() const {
  return payload_case() == kOrderUpdate ? *_impl_.payload_.order_update_ : reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdate&>(::t4proto::v1::orderrouting::_OrderUpdate_default_instance_);
}
inline const ::t4proto::v1::orderrouting::OrderUpdate& ServerMessage::order_update() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.order_update)
  return _internal_order_update();
}
inline ::t4proto::v1::orderrouting::OrderUpdate* ServerMessage::unsafe_arena_release_order_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.order_update)
  if (payload_case() == kOrderUpdate) {
    clear_has_payload();
    auto* temp = _impl_.payload_.order_update_;
    _impl_.payload_.order_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_order_update(::t4proto::v1::orderrouting::OrderUpdate* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_order_update();
    _impl_.payload_.order_update_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.order_update)
}
inline ::t4proto::v1::orderrouting::OrderUpdate* ServerMessage::_internal_mutable_order_update() {
  if (payload_case() != kOrderUpdate) {
    clear_payload();
    set_has_order_update();
    _impl_.payload_.order_update_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::orderrouting::OrderUpdate>(GetArena());
  }
  return _impl_.payload_.order_update_;
}
inline ::t4proto::v1::orderrouting::OrderUpdate* ServerMessage::mutable_order_update() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::orderrouting::OrderUpdate* _msg = _internal_mutable_order_update();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.order_update)
  return _msg;
}

// .t4proto.v1.orderrouting.OrderUpdateMulti order_update_multi = 301;
inline bool ServerMessage::has_order_update_multi() const {
  return payload_case() == kOrderUpdateMulti;
}
inline bool ServerMessage::_internal_has_order_update_multi() const {
  return payload_case() == kOrderUpdateMulti;
}
inline void ServerMessage::set_has_order_update_multi() {
  _impl_._oneof_case_[0] = kOrderUpdateMulti;
}
inline ::t4proto::v1::orderrouting::OrderUpdateMulti* ServerMessage::release_order_update_multi() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.order_update_multi)
  if (payload_case() == kOrderUpdateMulti) {
    clear_has_payload();
    auto* temp = _impl_.payload_.order_update_multi_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.order_update_multi_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::OrderUpdateMulti& ServerMessage::_internal_order_update_multi() const {
  return payload_case() == kOrderUpdateMulti ? *_impl_.payload_.order_update_multi_ : reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdateMulti&>(::t4proto::v1::orderrouting::_OrderUpdateMulti_default_instance_);
}
inline const ::t4proto::v1::orderrouting::OrderUpdateMulti& ServerMessage::order_update_multi() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.order_update_multi)
  return _internal_order_update_multi();
}
inline ::t4proto::v1::orderrouting::OrderUpdateMulti* ServerMessage::unsafe_arena_release_order_update_multi() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.order_update_multi)
  if (payload_case() == kOrderUpdateMulti) {
    clear_has_payload();
    auto* temp = _impl_.payload_.order_update_multi_;
    _impl_.payload_.order_update_multi_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_order_update_multi(::t4proto::v1::orderrouting::OrderUpdateMulti* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_order_update_multi();
    _impl_.payload_.order_update_multi_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.order_update_multi)
}
inline ::t4proto::v1::orderrouting::OrderUpdateMulti* ServerMessage::_internal_mutable_order_update_multi() {
  if (payload_case() != kOrderUpdateMulti) {
    clear_payload();
    set_has_order_update_multi();
    _impl_.payload_.order_update_multi_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::orderrouting::OrderUpdateMulti>(GetArena());
  }
  return _impl_.payload_.order_update_multi_;
}
inline ::t4proto::v1::orderrouting::OrderUpdateMulti* ServerMessage::mutable_order_update_multi() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::orderrouting::OrderUpdateMulti* _msg = _internal_mutable_order_update_multi();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.order_update_multi)
  return _msg;
}

// .t4proto.v1.orderrouting.OrderUpdateFailed order_update_failed = 302;
inline bool ServerMessage::has_order_update_failed() const {
  return payload_case() == kOrderUpdateFailed;
}
inline bool ServerMessage::_internal_has_order_update_failed() const {
  return payload_case() == kOrderUpdateFailed;
}
inline void ServerMessage::set_has_order_update_failed() {
  _impl_._oneof_case_[0] = kOrderUpdateFailed;
}
inline ::t4proto::v1::orderrouting::OrderUpdateFailed* ServerMessage::release_order_update_failed() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.order_update_failed)
  if (payload_case() == kOrderUpdateFailed) {
    clear_has_payload();
    auto* temp = _impl_.payload_.order_update_failed_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.order_update_failed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::OrderUpdateFailed& ServerMessage::_internal_order_update_failed() const {
  return payload_case() == kOrderUpdateFailed ? *_impl_.payload_.order_update_failed_ : reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdateFailed&>(::t4proto::v1::orderrouting::_OrderUpdateFailed_default_instance_);
}
inline const ::t4proto::v1::orderrouting::OrderUpdateFailed& ServerMessage::order_update_failed() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.order_update_failed)
  return _internal_order_update_failed();
}
inline ::t4proto::v1::orderrouting::OrderUpdateFailed* ServerMessage::unsafe_arena_release_order_update_failed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.order_update_failed)
  if (payload_case() == kOrderUpdateFailed) {
    clear_has_payload();
    auto* temp = _impl_.payload_.order_update_failed_;
    _impl_.payload_.order_update_failed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_order_update_failed(::t4proto::v1::orderrouting::OrderUpdateFailed* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_order_update_failed();
    _impl_.payload_.order_update_failed_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.order_update_failed)
}
inline ::t4proto::v1::orderrouting::OrderUpdateFailed* ServerMessage::_internal_mutable_order_update_failed() {
  if (payload_case() != kOrderUpdateFailed) {
    clear_payload();
    set_has_order_update_failed();
    _impl_.payload_.order_update_failed_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::orderrouting::OrderUpdateFailed>(GetArena());
  }
  return _impl_.payload_.order_update_failed_;
}
inline ::t4proto::v1::orderrouting::OrderUpdateFailed* ServerMessage::mutable_order_update_failed() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::orderrouting::OrderUpdateFailed* _msg = _internal_mutable_order_update_failed();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.order_update_failed)
  return _msg;
}

// .t4proto.v1.orderrouting.OrderUpdateStatus order_update_status = 303;
inline bool ServerMessage::has_order_update_status() const {
  return payload_case() == kOrderUpdateStatus;
}
inline bool ServerMessage::_internal_has_order_update_status() const {
  return payload_case() == kOrderUpdateStatus;
}
inline void ServerMessage::set_has_order_update_status() {
  _impl_._oneof_case_[0] = kOrderUpdateStatus;
}
inline ::t4proto::v1::orderrouting::OrderUpdateStatus* ServerMessage::release_order_update_status() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.order_update_status)
  if (payload_case() == kOrderUpdateStatus) {
    clear_has_payload();
    auto* temp = _impl_.payload_.order_update_status_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.order_update_status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::OrderUpdateStatus& ServerMessage::_internal_order_update_status() const {
  return payload_case() == kOrderUpdateStatus ? *_impl_.payload_.order_update_status_ : reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdateStatus&>(::t4proto::v1::orderrouting::_OrderUpdateStatus_default_instance_);
}
inline const ::t4proto::v1::orderrouting::OrderUpdateStatus& ServerMessage::order_update_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.order_update_status)
  return _internal_order_update_status();
}
inline ::t4proto::v1::orderrouting::OrderUpdateStatus* ServerMessage::unsafe_arena_release_order_update_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.order_update_status)
  if (payload_case() == kOrderUpdateStatus) {
    clear_has_payload();
    auto* temp = _impl_.payload_.order_update_status_;
    _impl_.payload_.order_update_status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_order_update_status(::t4proto::v1::orderrouting::OrderUpdateStatus* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_order_update_status();
    _impl_.payload_.order_update_status_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.order_update_status)
}
inline ::t4proto::v1::orderrouting::OrderUpdateStatus* ServerMessage::_internal_mutable_order_update_status() {
  if (payload_case() != kOrderUpdateStatus) {
    clear_payload();
    set_has_order_update_status();
    _impl_.payload_.order_update_status_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::orderrouting::OrderUpdateStatus>(GetArena());
  }
  return _impl_.payload_.order_update_status_;
}
inline ::t4proto::v1::orderrouting::OrderUpdateStatus* ServerMessage::mutable_order_update_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::orderrouting::OrderUpdateStatus* _msg = _internal_mutable_order_update_status();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.order_update_status)
  return _msg;
}

// .t4proto.v1.orderrouting.OrderUpdateTrade order_update_trade = 304;
inline bool ServerMessage::has_order_update_trade() const {
  return payload_case() == kOrderUpdateTrade;
}
inline bool ServerMessage::_internal_has_order_update_trade() const {
  return payload_case() == kOrderUpdateTrade;
}
inline void ServerMessage::set_has_order_update_trade() {
  _impl_._oneof_case_[0] = kOrderUpdateTrade;
}
inline ::t4proto::v1::orderrouting::OrderUpdateTrade* ServerMessage::release_order_update_trade() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.order_update_trade)
  if (payload_case() == kOrderUpdateTrade) {
    clear_has_payload();
    auto* temp = _impl_.payload_.order_update_trade_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.order_update_trade_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::OrderUpdateTrade& ServerMessage::_internal_order_update_trade() const {
  return payload_case() == kOrderUpdateTrade ? *_impl_.payload_.order_update_trade_ : reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdateTrade&>(::t4proto::v1::orderrouting::_OrderUpdateTrade_default_instance_);
}
inline const ::t4proto::v1::orderrouting::OrderUpdateTrade& ServerMessage::order_update_trade() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.order_update_trade)
  return _internal_order_update_trade();
}
inline ::t4proto::v1::orderrouting::OrderUpdateTrade* ServerMessage::unsafe_arena_release_order_update_trade() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.order_update_trade)
  if (payload_case() == kOrderUpdateTrade) {
    clear_has_payload();
    auto* temp = _impl_.payload_.order_update_trade_;
    _impl_.payload_.order_update_trade_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_order_update_trade(::t4proto::v1::orderrouting::OrderUpdateTrade* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_order_update_trade();
    _impl_.payload_.order_update_trade_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.order_update_trade)
}
inline ::t4proto::v1::orderrouting::OrderUpdateTrade* ServerMessage::_internal_mutable_order_update_trade() {
  if (payload_case() != kOrderUpdateTrade) {
    clear_payload();
    set_has_order_update_trade();
    _impl_.payload_.order_update_trade_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::orderrouting::OrderUpdateTrade>(GetArena());
  }
  return _impl_.payload_.order_update_trade_;
}
inline ::t4proto::v1::orderrouting::OrderUpdateTrade* ServerMessage::mutable_order_update_trade() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::orderrouting::OrderUpdateTrade* _msg = _internal_mutable_order_update_trade();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.order_update_trade)
  return _msg;
}

// .t4proto.v1.orderrouting.OrderUpdateTradeLeg order_update_trade_leg = 305;
inline bool ServerMessage::has_order_update_trade_leg() const {
  return payload_case() == kOrderUpdateTradeLeg;
}
inline bool ServerMessage::_internal_has_order_update_trade_leg() const {
  return payload_case() == kOrderUpdateTradeLeg;
}
inline void ServerMessage::set_has_order_update_trade_leg() {
  _impl_._oneof_case_[0] = kOrderUpdateTradeLeg;
}
inline ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* ServerMessage::release_order_update_trade_leg() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.order_update_trade_leg)
  if (payload_case() == kOrderUpdateTradeLeg) {
    clear_has_payload();
    auto* temp = _impl_.payload_.order_update_trade_leg_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.order_update_trade_leg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::OrderUpdateTradeLeg& ServerMessage::_internal_order_update_trade_leg() const {
  return payload_case() == kOrderUpdateTradeLeg ? *_impl_.payload_.order_update_trade_leg_ : reinterpret_cast<::t4proto::v1::orderrouting::OrderUpdateTradeLeg&>(::t4proto::v1::orderrouting::_OrderUpdateTradeLeg_default_instance_);
}
inline const ::t4proto::v1::orderrouting::OrderUpdateTradeLeg& ServerMessage::order_update_trade_leg() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.order_update_trade_leg)
  return _internal_order_update_trade_leg();
}
inline ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* ServerMessage::unsafe_arena_release_order_update_trade_leg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.order_update_trade_leg)
  if (payload_case() == kOrderUpdateTradeLeg) {
    clear_has_payload();
    auto* temp = _impl_.payload_.order_update_trade_leg_;
    _impl_.payload_.order_update_trade_leg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_order_update_trade_leg(::t4proto::v1::orderrouting::OrderUpdateTradeLeg* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_order_update_trade_leg();
    _impl_.payload_.order_update_trade_leg_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.order_update_trade_leg)
}
inline ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* ServerMessage::_internal_mutable_order_update_trade_leg() {
  if (payload_case() != kOrderUpdateTradeLeg) {
    clear_payload();
    set_has_order_update_trade_leg();
    _impl_.payload_.order_update_trade_leg_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::orderrouting::OrderUpdateTradeLeg>(GetArena());
  }
  return _impl_.payload_.order_update_trade_leg_;
}
inline ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* ServerMessage::mutable_order_update_trade_leg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* _msg = _internal_mutable_order_update_trade_leg();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.order_update_trade_leg)
  return _msg;
}

// .t4proto.v1.orderrouting.CreateUDSResponse create_uds_response = 340;
inline bool ServerMessage::has_create_uds_response() const {
  return payload_case() == kCreateUdsResponse;
}
inline bool ServerMessage::_internal_has_create_uds_response() const {
  return payload_case() == kCreateUdsResponse;
}
inline void ServerMessage::set_has_create_uds_response() {
  _impl_._oneof_case_[0] = kCreateUdsResponse;
}
inline ::t4proto::v1::orderrouting::CreateUDSResponse* ServerMessage::release_create_uds_response() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.create_uds_response)
  if (payload_case() == kCreateUdsResponse) {
    clear_has_payload();
    auto* temp = _impl_.payload_.create_uds_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.create_uds_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::CreateUDSResponse& ServerMessage::_internal_create_uds_response() const {
  return payload_case() == kCreateUdsResponse ? *_impl_.payload_.create_uds_response_ : reinterpret_cast<::t4proto::v1::orderrouting::CreateUDSResponse&>(::t4proto::v1::orderrouting::_CreateUDSResponse_default_instance_);
}
inline const ::t4proto::v1::orderrouting::CreateUDSResponse& ServerMessage::create_uds_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.create_uds_response)
  return _internal_create_uds_response();
}
inline ::t4proto::v1::orderrouting::CreateUDSResponse* ServerMessage::unsafe_arena_release_create_uds_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.create_uds_response)
  if (payload_case() == kCreateUdsResponse) {
    clear_has_payload();
    auto* temp = _impl_.payload_.create_uds_response_;
    _impl_.payload_.create_uds_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_create_uds_response(::t4proto::v1::orderrouting::CreateUDSResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_create_uds_response();
    _impl_.payload_.create_uds_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.create_uds_response)
}
inline ::t4proto::v1::orderrouting::CreateUDSResponse* ServerMessage::_internal_mutable_create_uds_response() {
  if (payload_case() != kCreateUdsResponse) {
    clear_payload();
    set_has_create_uds_response();
    _impl_.payload_.create_uds_response_ =
        ::google::protobuf::Message::DefaultConstruct<::t4proto::v1::orderrouting::CreateUDSResponse>(GetArena());
  }
  return _impl_.payload_.create_uds_response_;
}
inline ::t4proto::v1::orderrouting::CreateUDSResponse* ServerMessage::mutable_create_uds_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::t4proto::v1::orderrouting::CreateUDSResponse* _msg = _internal_mutable_create_uds_response();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.create_uds_response)
  return _msg;
}

inline bool ServerMessage::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void ServerMessage::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline ServerMessage::PayloadCase ServerMessage::payload_case() const {
  return ServerMessage::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Heartbeat

// int64 timestamp = 1;
inline void Heartbeat::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t Heartbeat::timestamp() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.Heartbeat.timestamp)
  return _internal_timestamp();
}
inline void Heartbeat::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:t4proto.v1.service.Heartbeat.timestamp)
}
inline ::int64_t Heartbeat::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_;
}
inline void Heartbeat::_internal_set_timestamp(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace service
}  // namespace v1
}  // namespace t4proto


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // t4_2fv1_2fservice_2eproto_2epb_2eh
