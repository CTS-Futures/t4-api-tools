// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: t4/v1/common/enums.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_t4_2fv1_2fcommon_2fenums_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_t4_2fv1_2fcommon_2fenums_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4022000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4022002 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_t4_2fv1_2fcommon_2fenums_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_t4_2fv1_2fcommon_2fenums_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_t4_2fv1_2fcommon_2fenums_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

namespace t4proto {
namespace v1 {
namespace common {
enum LoginResult : int {
  LOGIN_RESULT_SUCCESS = 0,
  LOGIN_RESULT_FAILED = 1,
  LOGIN_RESULT_APPLICATION_NOT_VALID = 2,
  LOGIN_RESULT_FIRM_NOT_ALLOWED = 3,
  LOGIN_RESULT_USER_NOT_ALLOWED = 4,
  LOGIN_RESULT_INCORRECT_VERSION = 5,
  LOGIN_RESULT_LOGGED_IN_ELSEWHERE = 6,
  LOGIN_RESULT_LOGOUT = 7,
  LOGIN_RESULT_UNEXPECTED_DISCONNECT = 8,
  LOGIN_RESULT_UNAUTHORIZED = 9,
  LOGIN_RESULT_UNEXPECTED_ERROR = 10,
  LOGIN_RESULT_ROLE_NOT_SUPPORTED = 11,
  LOGIN_RESULT_API_MESSAGE_BACKLOG = 12,
  LOGIN_RESULT_SERVER_MESSAGE_BACKLOG = 13,
  LOGIN_RESULT_PASSWORD_EXPIRED = 14,
  LOGIN_RESULT_PASSWORD_CHANGE_FAILED = 16,
  LOGIN_RESULT_PASSWORD_ALREADY_USED = 17,
  LOGIN_RESULT_LOCKED_OUT = 18,
  LOGIN_RESULT_ADDITIONAL_USERS_NOT_ALLOWED = 19,
  LOGIN_RESULT_MARKET_DATA_NOT_SETUP = 20,
  LOGIN_RESULT_TWO_FACTOR_NOT_SETUP = 21,
  LOGIN_RESULT_TWO_FACTOR_FAILED = 22,
  LOGIN_RESULT_FIX_SESSION_ERROR = 23,
  LOGIN_RESULT_TWO_FACTOR_REQUIRED = 24,
  LOGIN_RESULT_USER_EXISTS = 25,
  LOGIN_RESULT_UNKNOWN = -1,
  LoginResult_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  LoginResult_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool LoginResult_IsValid(int value);
constexpr LoginResult LoginResult_MIN = static_cast<LoginResult>(-1);
constexpr LoginResult LoginResult_MAX = static_cast<LoginResult>(25);
constexpr int LoginResult_ARRAYSIZE = 25 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
LoginResult_descriptor();
template <typename T>
const std::string& LoginResult_Name(T value) {
  static_assert(std::is_same<T, LoginResult>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LoginResult_Name().");
  return LoginResult_Name(static_cast<LoginResult>(value));
}
template <>
inline const std::string& LoginResult_Name(LoginResult value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<LoginResult_descriptor,
                                                 -1, 25>(
      static_cast<int>(value));
}
inline bool LoginResult_Parse(absl::string_view name, LoginResult* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LoginResult>(
      LoginResult_descriptor(), name, value);
}
enum PriceFormat : int {
  PRICE_FORMAT_DECIMAL = 0,
  PRICE_FORMAT_REAL = 1,
  PRICE_FORMAT_CLEARING_DECIMAL = 2,
  PriceFormat_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PriceFormat_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PriceFormat_IsValid(int value);
constexpr PriceFormat PriceFormat_MIN = static_cast<PriceFormat>(0);
constexpr PriceFormat PriceFormat_MAX = static_cast<PriceFormat>(2);
constexpr int PriceFormat_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
PriceFormat_descriptor();
template <typename T>
const std::string& PriceFormat_Name(T value) {
  static_assert(std::is_same<T, PriceFormat>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PriceFormat_Name().");
  return PriceFormat_Name(static_cast<PriceFormat>(value));
}
template <>
inline const std::string& PriceFormat_Name(PriceFormat value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<PriceFormat_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool PriceFormat_Parse(absl::string_view name, PriceFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PriceFormat>(
      PriceFormat_descriptor(), name, value);
}
enum AccountMode : int {
  ACCOUNT_MODE_BY_MARKET = 0,
  ACCOUNT_MODE_BY_CONTRACT = 1,
  ACCOUNT_MODE_BY_ACCOUNT = 2,
  ACCOUNT_MODE_BY_ACCOUNT_DAY = 3,
  ACCOUNT_MODE_BY_PORTFOLIO = 4,
  ACCOUNT_MODE_T500 = 5,
  ACCOUNT_MODE_T500_DEMO = 6,
  ACCOUNT_MODE_AUTO_LIQ = 7,
  ACCOUNT_MODE_UNKNOWN = -1,
  AccountMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AccountMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AccountMode_IsValid(int value);
constexpr AccountMode AccountMode_MIN = static_cast<AccountMode>(-1);
constexpr AccountMode AccountMode_MAX = static_cast<AccountMode>(7);
constexpr int AccountMode_ARRAYSIZE = 7 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
AccountMode_descriptor();
template <typename T>
const std::string& AccountMode_Name(T value) {
  static_assert(std::is_same<T, AccountMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AccountMode_Name().");
  return AccountMode_Name(static_cast<AccountMode>(value));
}
template <>
inline const std::string& AccountMode_Name(AccountMode value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<AccountMode_descriptor,
                                                 -1, 7>(
      static_cast<int>(value));
}
inline bool AccountMode_Parse(absl::string_view name, AccountMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AccountMode>(
      AccountMode_descriptor(), name, value);
}
enum MarketMode : int {
  MARKET_MODE_UNDEFINED = 0,
  MARKET_MODE_PRE_OPEN = 1,
  MARKET_MODE_OPEN = 2,
  MARKET_MODE_RESTRICTED_OPEN = 3,
  MARKET_MODE_PRE_CLOSED = 4,
  MARKET_MODE_CLOSED = 5,
  MARKET_MODE_SUSPENDED = 6,
  MARKET_MODE_HALTED = 7,
  MARKET_MODE_FAILED = 8,
  MARKET_MODE_PRE_CROSS = 9,
  MARKET_MODE_CROSS = 10,
  MARKET_MODE_EXPIRED = 11,
  MARKET_MODE_REJECTED = 12,
  MARKET_MODE_UNAVAILABLE = 13,
  MARKET_MODE_NO_PERMISSION = 14,
  MarketMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MarketMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MarketMode_IsValid(int value);
constexpr MarketMode MarketMode_MIN = static_cast<MarketMode>(0);
constexpr MarketMode MarketMode_MAX = static_cast<MarketMode>(14);
constexpr int MarketMode_ARRAYSIZE = 14 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
MarketMode_descriptor();
template <typename T>
const std::string& MarketMode_Name(T value) {
  static_assert(std::is_same<T, MarketMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MarketMode_Name().");
  return MarketMode_Name(static_cast<MarketMode>(value));
}
template <>
inline const std::string& MarketMode_Name(MarketMode value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<MarketMode_descriptor,
                                                 0, 14>(
      static_cast<int>(value));
}
inline bool MarketMode_Parse(absl::string_view name, MarketMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MarketMode>(
      MarketMode_descriptor(), name, value);
}
enum DepthBuffer : int {
  DEPTH_BUFFER_NO_SUBSCRIPTION = 0,
  DEPTH_BUFFER_SLOW_TRADE = 1,
  DEPTH_BUFFER_SMART_TRADE = 2,
  DEPTH_BUFFER_SLOW_SMART = 3,
  DEPTH_BUFFER_SMART = 4,
  DEPTH_BUFFER_FAST_SMART = 5,
  DEPTH_BUFFER_ALL = 6,
  DEPTH_BUFFER_FAST_TRADE = 7,
  DEPTH_BUFFER_TRADE_ONLY = 8,
  DepthBuffer_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DepthBuffer_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DepthBuffer_IsValid(int value);
constexpr DepthBuffer DepthBuffer_MIN = static_cast<DepthBuffer>(0);
constexpr DepthBuffer DepthBuffer_MAX = static_cast<DepthBuffer>(8);
constexpr int DepthBuffer_ARRAYSIZE = 8 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
DepthBuffer_descriptor();
template <typename T>
const std::string& DepthBuffer_Name(T value) {
  static_assert(std::is_same<T, DepthBuffer>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DepthBuffer_Name().");
  return DepthBuffer_Name(static_cast<DepthBuffer>(value));
}
template <>
inline const std::string& DepthBuffer_Name(DepthBuffer value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<DepthBuffer_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool DepthBuffer_Parse(absl::string_view name, DepthBuffer* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DepthBuffer>(
      DepthBuffer_descriptor(), name, value);
}
enum DepthLevels : int {
  DEPTH_LEVELS_UNDEFINED = 0,
  DEPTH_LEVELS_BEST_ONLY = 1,
  DEPTH_LEVELS_NORMAL = 10,
  DEPTH_LEVELS_ALL = 255,
  DepthLevels_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DepthLevels_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DepthLevels_IsValid(int value);
constexpr DepthLevels DepthLevels_MIN = static_cast<DepthLevels>(0);
constexpr DepthLevels DepthLevels_MAX = static_cast<DepthLevels>(255);
constexpr int DepthLevels_ARRAYSIZE = 255 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
DepthLevels_descriptor();
template <typename T>
const std::string& DepthLevels_Name(T value) {
  static_assert(std::is_same<T, DepthLevels>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DepthLevels_Name().");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(DepthLevels_descriptor(), value);
}
inline bool DepthLevels_Parse(absl::string_view name, DepthLevels* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DepthLevels>(
      DepthLevels_descriptor(), name, value);
}
enum BidOffer : int {
  BID_OFFER_UNDEFINED = 0,
  BID_OFFER_BID = 1,
  BID_OFFER_OFFER = -1,
  BidOffer_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  BidOffer_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool BidOffer_IsValid(int value);
constexpr BidOffer BidOffer_MIN = static_cast<BidOffer>(-1);
constexpr BidOffer BidOffer_MAX = static_cast<BidOffer>(1);
constexpr int BidOffer_ARRAYSIZE = 1 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
BidOffer_descriptor();
template <typename T>
const std::string& BidOffer_Name(T value) {
  static_assert(std::is_same<T, BidOffer>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to BidOffer_Name().");
  return BidOffer_Name(static_cast<BidOffer>(value));
}
template <>
inline const std::string& BidOffer_Name(BidOffer value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<BidOffer_descriptor,
                                                 -1, 1>(
      static_cast<int>(value));
}
inline bool BidOffer_Parse(absl::string_view name, BidOffer* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BidOffer>(
      BidOffer_descriptor(), name, value);
}
enum MarketFlags2 : int {
  MARKET_FLAGS2_UNDEFINED = 0,
  MARKET_FLAGS2_FAST = 1,
  MARKET_FLAGS2_PRICE_LIMITS_ENABLED = 2,
  MARKET_FLAGS2_NO_CANCEL = 4,
  MARKET_FLAGS2_IMPLIED_OFF = 8,
  MARKET_FLAGS2_NEW_PRICE_INDICATION = 16,
  MARKET_FLAGS2_NOT_AVAILABLE_FOR_TRADING = 32,
  MARKET_FLAGS2_POST_CLOSE = 64,
  MARKET_FLAGS2_GROUP_SCHEDULE = 128,
  MARKET_FLAGS2_INSTRUMENT_ACTIVATION = 256,
  MARKET_FLAGS2_INSTRUMENT_EXPIRATION = 512,
  MARKET_FLAGS2_MARKET_EVENT = 1024,
  MARKET_FLAGS2_RECOVERY_IN_PROCESS = 2048,
  MARKET_FLAGS2_SURVEILLANCE_INTERVENTION = 4096,
  MarketFlags2_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MarketFlags2_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MarketFlags2_IsValid(int value);
constexpr MarketFlags2 MarketFlags2_MIN = static_cast<MarketFlags2>(0);
constexpr MarketFlags2 MarketFlags2_MAX = static_cast<MarketFlags2>(4096);
constexpr int MarketFlags2_ARRAYSIZE = 4096 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
MarketFlags2_descriptor();
template <typename T>
const std::string& MarketFlags2_Name(T value) {
  static_assert(std::is_same<T, MarketFlags2>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MarketFlags2_Name().");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(MarketFlags2_descriptor(), value);
}
inline bool MarketFlags2_Parse(absl::string_view name, MarketFlags2* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MarketFlags2>(
      MarketFlags2_descriptor(), name, value);
}
enum ContractType : int {
  CONTRACT_TYPE_UNKNOWN = 0,
  CONTRACT_TYPE_OPTION = 1,
  CONTRACT_TYPE_OPTION_CALL = 2,
  CONTRACT_TYPE_OPTION_PUT = 3,
  CONTRACT_TYPE_STOCK = 4,
  CONTRACT_TYPE_FUTURE = 5,
  CONTRACT_TYPE_INDEX = 6,
  CONTRACT_TYPE_SYNTHETIC = 7,
  CONTRACT_TYPE_BINARY_OPTION = 8,
  CONTRACT_TYPE_UDS = 9,
  CONTRACT_TYPE_FX_SPOT = 10,
  CONTRACT_TYPE_ANY = -1,
  ContractType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ContractType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ContractType_IsValid(int value);
constexpr ContractType ContractType_MIN = static_cast<ContractType>(-1);
constexpr ContractType ContractType_MAX = static_cast<ContractType>(10);
constexpr int ContractType_ARRAYSIZE = 10 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ContractType_descriptor();
template <typename T>
const std::string& ContractType_Name(T value) {
  static_assert(std::is_same<T, ContractType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ContractType_Name().");
  return ContractType_Name(static_cast<ContractType>(value));
}
template <>
inline const std::string& ContractType_Name(ContractType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ContractType_descriptor,
                                                 -1, 10>(
      static_cast<int>(value));
}
inline bool ContractType_Parse(absl::string_view name, ContractType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ContractType>(
      ContractType_descriptor(), name, value);
}
enum MarketDataType : int {
  MARKET_DATA_TYPE_NONE = 0,
  MARKET_DATA_TYPE_TOB = 1,
  MARKET_DATA_TYPE_DEPTH = 2,
  MARKET_DATA_TYPE_E_MINI = 4,
  MARKET_DATA_TYPE_DELAYED = 8,
  MARKET_DATA_TYPE_NOT_SET = -1,
  MarketDataType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MarketDataType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MarketDataType_IsValid(int value);
constexpr MarketDataType MarketDataType_MIN = static_cast<MarketDataType>(-1);
constexpr MarketDataType MarketDataType_MAX = static_cast<MarketDataType>(8);
constexpr int MarketDataType_ARRAYSIZE = 8 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
MarketDataType_descriptor();
template <typename T>
const std::string& MarketDataType_Name(T value) {
  static_assert(std::is_same<T, MarketDataType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MarketDataType_Name().");
  return MarketDataType_Name(static_cast<MarketDataType>(value));
}
template <>
inline const std::string& MarketDataType_Name(MarketDataType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<MarketDataType_descriptor,
                                                 -1, 8>(
      static_cast<int>(value));
}
inline bool MarketDataType_Parse(absl::string_view name, MarketDataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MarketDataType>(
      MarketDataType_descriptor(), name, value);
}
enum StrategyType : int {
  STRATEGY_TYPE_NONE = 0,
  STRATEGY_TYPE_CALENDAR_SPREAD = 1,
  STRATEGY_TYPE_RT_CALENDAR_SPREAD = 2,
  STRATEGY_TYPE_INTER_CONTRACT_SPREAD = 3,
  STRATEGY_TYPE_BUTTERFLY = 4,
  STRATEGY_TYPE_CONDOR = 5,
  STRATEGY_TYPE_DOUBLE_BUTTERFLY = 6,
  STRATEGY_TYPE_HORIZONTAL = 7,
  STRATEGY_TYPE_BUNDLE = 8,
  STRATEGY_TYPE_MONTH_VS_PACK = 9,
  STRATEGY_TYPE_PACK = 10,
  STRATEGY_TYPE_PACK_SPREAD = 11,
  STRATEGY_TYPE_PACK_BUTTERFLY = 12,
  STRATEGY_TYPE_BUNDLE_SPREAD = 13,
  STRATEGY_TYPE_STRIP = 14,
  STRATEGY_TYPE_CRACK = 15,
  STRATEGY_TYPE_TREASURY_SPREAD = 16,
  STRATEGY_TYPE_CRUSH = 17,
  STRATEGY_TYPE_THREE_WAY = 19,
  STRATEGY_TYPE_THREE_WAY_STRADDLE_VS_CALL = 20,
  STRATEGY_TYPE_THREE_WAY_STRADDLE_VS_PUT = 21,
  STRATEGY_TYPE_BOX = 22,
  STRATEGY_TYPE_XMAS_TREE = 23,
  STRATEGY_TYPE_CONDITIONAL_CURVE = 24,
  STRATEGY_TYPE_DOUBLE = 25,
  STRATEGY_TYPE_HORIZONTAL_STRADDLE = 26,
  STRATEGY_TYPE_IRON_CONDOR = 27,
  STRATEGY_TYPE_RATIO_1X2 = 28,
  STRATEGY_TYPE_RATIO_1X3 = 29,
  STRATEGY_TYPE_RATIO_2X3 = 30,
  STRATEGY_TYPE_RISK_REVERSAL = 31,
  STRATEGY_TYPE_STRADDLE_STRIP = 32,
  STRATEGY_TYPE_STRADDLE = 33,
  STRATEGY_TYPE_STRANGLE = 34,
  STRATEGY_TYPE_VERTICAL = 35,
  STRATEGY_TYPE_JELLY_ROLL = 36,
  STRATEGY_TYPE_IRON_BUTTERFLY = 37,
  STRATEGY_TYPE_GUTS = 38,
  STRATEGY_TYPE_GENERIC = 39,
  STRATEGY_TYPE_DIAGONAL = 40,
  STRATEGY_TYPE_COVERED_THREE_WAY = 41,
  STRATEGY_TYPE_COVERED_THREE_WAY_STRADDLE_VS_CALL = 42,
  STRATEGY_TYPE_COVERED_THREE_WAY_STRADDLE_VS_PUT = 43,
  STRATEGY_TYPE_COVERED_BOX = 44,
  STRATEGY_TYPE_COVERED_XMAS_TREE = 45,
  STRATEGY_TYPE_COVERED_CONDITIONAL_CURVE = 46,
  STRATEGY_TYPE_COVERED_DOUBLE = 47,
  STRATEGY_TYPE_COVERED_HORIZONTAL_STRADDLE = 48,
  STRATEGY_TYPE_COVERED_IRON_CONDOR = 49,
  STRATEGY_TYPE_COVERED_RATIO_1X2 = 50,
  STRATEGY_TYPE_COVERED_RATIO_1X3 = 51,
  STRATEGY_TYPE_COVERED_RATIO_2X3 = 52,
  STRATEGY_TYPE_COVERED_RISK_REVERSAL = 53,
  STRATEGY_TYPE_COVERED_STRADDLE_STRIP = 54,
  STRATEGY_TYPE_COVERED_STRADDLE = 55,
  STRATEGY_TYPE_COVERED_STRANGLE = 56,
  STRATEGY_TYPE_COVERED_VERTICAL = 57,
  STRATEGY_TYPE_COVERED_JELLY_ROLL = 58,
  STRATEGY_TYPE_COVERED_IRON_BUTTERFLY = 59,
  STRATEGY_TYPE_COVERED_GUTS = 60,
  STRATEGY_TYPE_COVERED_GENERIC = 61,
  STRATEGY_TYPE_COVERED_DIAGONAL = 62,
  STRATEGY_TYPE_COVERED_BUTTERFLY = 63,
  STRATEGY_TYPE_COVERED_CONDOR = 64,
  STRATEGY_TYPE_COVERED_HORIZONTAL = 65,
  STRATEGY_TYPE_COVERED_STRIP = 66,
  STRATEGY_TYPE_COVERED_OPTION = 67,
  STRATEGY_TYPE_BALANCED_STRIP = 68,
  STRATEGY_TYPE_UNBALANCED_STRIP = 69,
  STRATEGY_TYPE_INTER_CONTRACT_STRIP = 70,
  STRATEGY_TYPE_INVOICE_SWAP = 71,
  STRATEGY_TYPE_INTEREST_RATE_SWAP = 72,
  STRATEGY_TYPE_AVERAGE_PRICE_STRIP = 73,
  STRATEGY_TYPE_TREASURY_TAIL = 74,
  STRATEGY_TYPE_AVERAGE_PRICE_STRIP_SPREAD = 75,
  STRATEGY_TYPE_INVOICE_SWAP_CALENDAR = 76,
  STRATEGY_TYPE_INVOICE_SWAP_SWITCHES = 77,
  STRATEGY_TYPE_VOLATILITY_QUOTED_OPTION = 78,
  STRATEGY_TYPE_FX_SPOT = 79,
  STRATEGY_TYPE_AVERAGE_PRICE_BUNDLE = 80,
  STRATEGY_TYPE_FIXED_PRICE_RATIO_SPREAD = 81,
  STRATEGY_TYPE_SA_CBOT_SOYBEAN_SPREAD = 82,
  STRATEGY_TYPE_BALANCED_STRIP_BUTTERFLY = 83,
  STRATEGY_TYPE_ANY = -1,
  StrategyType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  StrategyType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool StrategyType_IsValid(int value);
constexpr StrategyType StrategyType_MIN = static_cast<StrategyType>(-1);
constexpr StrategyType StrategyType_MAX = static_cast<StrategyType>(83);
constexpr int StrategyType_ARRAYSIZE = 83 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
StrategyType_descriptor();
template <typename T>
const std::string& StrategyType_Name(T value) {
  static_assert(std::is_same<T, StrategyType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to StrategyType_Name().");
  return StrategyType_Name(static_cast<StrategyType>(value));
}
template <>
inline const std::string& StrategyType_Name(StrategyType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<StrategyType_descriptor,
                                                 -1, 83>(
      static_cast<int>(value));
}
inline bool StrategyType_Parse(absl::string_view name, StrategyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StrategyType>(
      StrategyType_descriptor(), name, value);
}
enum ContractRiskStatus : int {
  CONTRACT_RISK_STATUS_NONE = 0,
  CONTRACT_RISK_STATUS_DAY_TRADING = 1,
  CONTRACT_RISK_STATUS_ALERTING = 2,
  CONTRACT_RISK_STATUS_LIQUIDATION = 3,
  CONTRACT_RISK_STATUS_LIQUIDATION_WAITING = 4,
  CONTRACT_RISK_STATUS_BLOCK_EXPIRATION_LIQUIDATION = 5,
  CONTRACT_RISK_STATUS_PRICE_LIMIT_LIQUIDATION = 6,
  ContractRiskStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ContractRiskStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ContractRiskStatus_IsValid(int value);
constexpr ContractRiskStatus ContractRiskStatus_MIN = static_cast<ContractRiskStatus>(0);
constexpr ContractRiskStatus ContractRiskStatus_MAX = static_cast<ContractRiskStatus>(6);
constexpr int ContractRiskStatus_ARRAYSIZE = 6 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ContractRiskStatus_descriptor();
template <typename T>
const std::string& ContractRiskStatus_Name(T value) {
  static_assert(std::is_same<T, ContractRiskStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ContractRiskStatus_Name().");
  return ContractRiskStatus_Name(static_cast<ContractRiskStatus>(value));
}
template <>
inline const std::string& ContractRiskStatus_Name(ContractRiskStatus value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ContractRiskStatus_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool ContractRiskStatus_Parse(absl::string_view name, ContractRiskStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ContractRiskStatus>(
      ContractRiskStatus_descriptor(), name, value);
}
enum AccountStatus : int {
  ACCOUNT_STATUS_UNKNOWN = 0,
  ACCOUNT_STATUS_BLOCKED = 1,
  ACCOUNT_STATUS_OK = 2,
  ACCOUNT_STATUS_UNRESTRICTED = 3,
  ACCOUNT_STATUS_DELETED = 4,
  ACCOUNT_STATUS_DISABLED = 5,
  ACCOUNT_STATUS_OUTSIDE_ACTIVE_TIME = 6,
  ACCOUNT_STATUS_NOT_ACCESSIBLE = 7,
  ACCOUNT_STATUS_PIT_TRADE_ONLY = 8,
  ACCOUNT_STATUS_LOSS_LIMIT_EXCEEDED = 9,
  AccountStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AccountStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AccountStatus_IsValid(int value);
constexpr AccountStatus AccountStatus_MIN = static_cast<AccountStatus>(0);
constexpr AccountStatus AccountStatus_MAX = static_cast<AccountStatus>(9);
constexpr int AccountStatus_ARRAYSIZE = 9 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
AccountStatus_descriptor();
template <typename T>
const std::string& AccountStatus_Name(T value) {
  static_assert(std::is_same<T, AccountStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AccountStatus_Name().");
  return AccountStatus_Name(static_cast<AccountStatus>(value));
}
template <>
inline const std::string& AccountStatus_Name(AccountStatus value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<AccountStatus_descriptor,
                                                 0, 9>(
      static_cast<int>(value));
}
inline bool AccountStatus_Parse(absl::string_view name, AccountStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AccountStatus>(
      AccountStatus_descriptor(), name, value);
}
enum AccountEnabled : int {
  ACCOUNT_ENABLED_DISABLED = 0,
  ACCOUNT_ENABLED_ENABLED = 1,
  ACCOUNT_ENABLED_BACK_OFFICE_ONLY = 2,
  ACCOUNT_ENABLED_PIT_TRADE_ONLY = 3,
  AccountEnabled_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AccountEnabled_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AccountEnabled_IsValid(int value);
constexpr AccountEnabled AccountEnabled_MIN = static_cast<AccountEnabled>(0);
constexpr AccountEnabled AccountEnabled_MAX = static_cast<AccountEnabled>(3);
constexpr int AccountEnabled_ARRAYSIZE = 3 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
AccountEnabled_descriptor();
template <typename T>
const std::string& AccountEnabled_Name(T value) {
  static_assert(std::is_same<T, AccountEnabled>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AccountEnabled_Name().");
  return AccountEnabled_Name(static_cast<AccountEnabled>(value));
}
template <>
inline const std::string& AccountEnabled_Name(AccountEnabled value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<AccountEnabled_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool AccountEnabled_Parse(absl::string_view name, AccountEnabled* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AccountEnabled>(
      AccountEnabled_descriptor(), name, value);
}
enum AccountMarginType : int {
  ACCOUNT_MARGIN_TYPE_SPEC = 0,
  ACCOUNT_MARGIN_TYPE_HEDGE_OR_MEMBER = 1,
  ACCOUNT_MARGIN_TYPE_FIRM_OR_ACCOUNT = 2,
  AccountMarginType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AccountMarginType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AccountMarginType_IsValid(int value);
constexpr AccountMarginType AccountMarginType_MIN = static_cast<AccountMarginType>(0);
constexpr AccountMarginType AccountMarginType_MAX = static_cast<AccountMarginType>(2);
constexpr int AccountMarginType_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
AccountMarginType_descriptor();
template <typename T>
const std::string& AccountMarginType_Name(T value) {
  static_assert(std::is_same<T, AccountMarginType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AccountMarginType_Name().");
  return AccountMarginType_Name(static_cast<AccountMarginType>(value));
}
template <>
inline const std::string& AccountMarginType_Name(AccountMarginType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<AccountMarginType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool AccountMarginType_Parse(absl::string_view name, AccountMarginType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AccountMarginType>(
      AccountMarginType_descriptor(), name, value);
}
enum OrderChange : int {
  ORDER_CHANGE_NONE = 0,
  ORDER_CHANGE_FAILED = 1,
  ORDER_CHANGE_SUBMISSION_RISK_SUCCESS = 2,
  ORDER_CHANGE_SUBMISSION_RISK_REJECTED = 3,
  ORDER_CHANGE_SUBMISSION_SENT = 4,
  ORDER_CHANGE_SUBMISSION_FAILED = 5,
  ORDER_CHANGE_SUBMISSION_SUCCESS = 6,
  ORDER_CHANGE_SUBMISSION_REJECTED = 7,
  ORDER_CHANGE_REVISION_RISK_SUCCESS = 8,
  ORDER_CHANGE_REVISION_RISK_FAILED = 9,
  ORDER_CHANGE_REVISION_SENT = 10,
  ORDER_CHANGE_REVISION_FAILED = 11,
  ORDER_CHANGE_REVISION_SUCCESS = 12,
  ORDER_CHANGE_REVISION_REJECTED = 13,
  ORDER_CHANGE_PULL_RISK_SUCCESS = 14,
  ORDER_CHANGE_PULL_RISK_FAILED = 15,
  ORDER_CHANGE_PULL_SENT = 16,
  ORDER_CHANGE_PULL_FAILED = 17,
  ORDER_CHANGE_PULL_SUCCESS = 18,
  ORDER_CHANGE_PULL_REJECTED = 19,
  ORDER_CHANGE_TRADE = 20,
  ORDER_CHANGE_TRADE_COMPLETED = 21,
  ORDER_CHANGE_TRADE_BUSTED = 22,
  ORDER_CHANGE_HANDOVER = 23,
  ORDER_CHANGE_STATUS_REQUEST_RISK_SUCCESS = 24,
  ORDER_CHANGE_STATUS_REQUEST_RISK_FAILED = 25,
  ORDER_CHANGE_STATUS_REQUEST_SENT = 26,
  ORDER_CHANGE_STATUS_REQUEST_FAILED = 27,
  ORDER_CHANGE_STATUS_REQUEST_SUCCESS = 28,
  ORDER_CHANGE_STATUS_REQUEST_REJECTED = 29,
  ORDER_CHANGE_ROLLOVER = 30,
  ORDER_CHANGE_TAG_SUCCESS = 31,
  ORDER_CHANGE_TAG_FAILED = 32,
  ORDER_CHANGE_ADD_PIT_TRADE_SUCCESS = 33,
  ORDER_CHANGE_ADD_PIT_TRADE_FAILED = 34,
  ORDER_CHANGE_ADD_PIT_TRADE_REJECTED = 35,
  OrderChange_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  OrderChange_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool OrderChange_IsValid(int value);
constexpr OrderChange OrderChange_MIN = static_cast<OrderChange>(0);
constexpr OrderChange OrderChange_MAX = static_cast<OrderChange>(35);
constexpr int OrderChange_ARRAYSIZE = 35 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
OrderChange_descriptor();
template <typename T>
const std::string& OrderChange_Name(T value) {
  static_assert(std::is_same<T, OrderChange>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OrderChange_Name().");
  return OrderChange_Name(static_cast<OrderChange>(value));
}
template <>
inline const std::string& OrderChange_Name(OrderChange value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<OrderChange_descriptor,
                                                 0, 35>(
      static_cast<int>(value));
}
inline bool OrderChange_Parse(absl::string_view name, OrderChange* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OrderChange>(
      OrderChange_descriptor(), name, value);
}
enum OrderStatus : int {
  ORDER_STATUS_NONE = 0,
  ORDER_STATUS_WORKING = 1,
  ORDER_STATUS_FINISHED = 2,
  ORDER_STATUS_REJECTED = 3,
  ORDER_STATUS_HELD = 4,
  ORDER_STATUS_NO_CHANGE = 5,
  OrderStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  OrderStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool OrderStatus_IsValid(int value);
constexpr OrderStatus OrderStatus_MIN = static_cast<OrderStatus>(0);
constexpr OrderStatus OrderStatus_MAX = static_cast<OrderStatus>(5);
constexpr int OrderStatus_ARRAYSIZE = 5 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
OrderStatus_descriptor();
template <typename T>
const std::string& OrderStatus_Name(T value) {
  static_assert(std::is_same<T, OrderStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OrderStatus_Name().");
  return OrderStatus_Name(static_cast<OrderStatus>(value));
}
template <>
inline const std::string& OrderStatus_Name(OrderStatus value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<OrderStatus_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool OrderStatus_Parse(absl::string_view name, OrderStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OrderStatus>(
      OrderStatus_descriptor(), name, value);
}
enum ResponsePending : int {
  RESPONSE_PENDING_NONE = 0,
  RESPONSE_PENDING_SUBMISSION = 1,
  RESPONSE_PENDING_REVISION = 2,
  RESPONSE_PENDING_PULL = 3,
  RESPONSE_PENDING_STATUS = 4,
  RESPONSE_PENDING_NO_CHANGE = 5,
  ResponsePending_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ResponsePending_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ResponsePending_IsValid(int value);
constexpr ResponsePending ResponsePending_MIN = static_cast<ResponsePending>(0);
constexpr ResponsePending ResponsePending_MAX = static_cast<ResponsePending>(5);
constexpr int ResponsePending_ARRAYSIZE = 5 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ResponsePending_descriptor();
template <typename T>
const std::string& ResponsePending_Name(T value) {
  static_assert(std::is_same<T, ResponsePending>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ResponsePending_Name().");
  return ResponsePending_Name(static_cast<ResponsePending>(value));
}
template <>
inline const std::string& ResponsePending_Name(ResponsePending value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ResponsePending_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool ResponsePending_Parse(absl::string_view name, ResponsePending* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResponsePending>(
      ResponsePending_descriptor(), name, value);
}
enum ActivationType : int {
  ACTIVATION_TYPE_IMMEDIATE = 0,
  ACTIVATION_TYPE_HOLD = 1,
  ACTIVATION_TYPE_TRIGGERED = 2,
  ACTIVATION_TYPE_AT_OR_AFTER_TIME = 3,
  ACTIVATION_TYPE_AT_OR_ABOVE_TRADE_TICKS = 4,
  ACTIVATION_TYPE_AT_OR_BELOW_TRADE_TICKS = 5,
  ACTIVATION_TYPE_ON_MARKET_MODE = 6,
  ACTIVATION_TYPE_TRIGGERED_AT_OR_AFTER_TIME = 7,
  ACTIVATION_TYPE_TRIGGERED_AT_OR_ABOVE_TRADE_TICKS = 8,
  ACTIVATION_TYPE_TRIGGERED_AT_OR_BELOW_TRADE_TICKS = 9,
  ACTIVATION_TYPE_TRIGGERED_ON_MARKET_MODE = 10,
  ACTIVATION_TYPE_QUEUE = 11,
  ACTIVATION_TYPE_TRIGGERED_QUEUE = 12,
  ACTIVATION_TYPE_PIT_FILLED_QUEUE = 13,
  ACTIVATION_TYPE_AT_OR_ABOVE_TICKS = 14,
  ACTIVATION_TYPE_AT_OR_BELOW_TICKS = 15,
  ACTIVATION_TYPE_TRIGGERED_AT_OR_ABOVE_TICKS = 16,
  ACTIVATION_TYPE_TRIGGERED_AT_OR_BELOW_TICKS = 17,
  ACTIVATION_TYPE_MARKET_ON_CLOSE = 18,
  ACTIVATION_TYPE_UNDEFINED = -1,
  ActivationType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ActivationType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ActivationType_IsValid(int value);
constexpr ActivationType ActivationType_MIN = static_cast<ActivationType>(-1);
constexpr ActivationType ActivationType_MAX = static_cast<ActivationType>(18);
constexpr int ActivationType_ARRAYSIZE = 18 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ActivationType_descriptor();
template <typename T>
const std::string& ActivationType_Name(T value) {
  static_assert(std::is_same<T, ActivationType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ActivationType_Name().");
  return ActivationType_Name(static_cast<ActivationType>(value));
}
template <>
inline const std::string& ActivationType_Name(ActivationType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ActivationType_descriptor,
                                                 -1, 18>(
      static_cast<int>(value));
}
inline bool ActivationType_Parse(absl::string_view name, ActivationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ActivationType>(
      ActivationType_descriptor(), name, value);
}
enum PriceType : int {
  PRICE_TYPE_MARKET = 0,
  PRICE_TYPE_LIMIT = 1,
  PRICE_TYPE_STOP_MARKET = 2,
  PRICE_TYPE_STOP_LIMIT = 3,
  PRICE_TYPE_OVERNIGHT_POSITION = 4,
  PRICE_TYPE_PIT = 5,
  PRICE_TYPE_MARKET_IF_TOUCHED = 6,
  PRICE_TYPE_STOP_SAME_LIMIT = 7,
  PRICE_TYPE_JOIN = 8,
  PRICE_TYPE_HIT = 9,
  PRICE_TYPE_BACK_OFFICE_POSITION = 10,
  PRICE_TYPE_SYNTHETIC_MARKET = 11,
  PRICE_TYPE_SYNTHETIC_LIMIT = 12,
  PRICE_TYPE_SYNTHETIC_STOP_MARKET = 13,
  PRICE_TYPE_SYNTHETIC_STOP_LIMIT = 14,
  PRICE_TYPE_RFQ = 15,
  PRICE_TYPE_FLATTEN = 16,
  PRICE_TYPE_IMPORT = 17,
  PRICE_TYPE_OPTIONS_SETTLEMENT = 18,
  PRICE_TYPE_UNDEFINED = -1,
  PriceType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PriceType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PriceType_IsValid(int value);
constexpr PriceType PriceType_MIN = static_cast<PriceType>(-1);
constexpr PriceType PriceType_MAX = static_cast<PriceType>(18);
constexpr int PriceType_ARRAYSIZE = 18 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
PriceType_descriptor();
template <typename T>
const std::string& PriceType_Name(T value) {
  static_assert(std::is_same<T, PriceType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PriceType_Name().");
  return PriceType_Name(static_cast<PriceType>(value));
}
template <>
inline const std::string& PriceType_Name(PriceType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<PriceType_descriptor,
                                                 -1, 18>(
      static_cast<int>(value));
}
inline bool PriceType_Parse(absl::string_view name, PriceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PriceType>(
      PriceType_descriptor(), name, value);
}
enum TimeType : int {
  TIME_TYPE_NORMAL = 0,
  TIME_TYPE_IMMEDIATE_AND_CANCEL = 1,
  TIME_TYPE_GOOD_TILL_CANCELLED = 2,
  TIME_TYPE_COMPLETE_VOLUME = 3,
  TIME_TYPE_MARKET_ON_OPEN = 4,
  TIME_TYPE_MARKET_ON_CLOSE = 5,
  TIME_TYPE_UNDEFINED = -1,
  TimeType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TimeType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TimeType_IsValid(int value);
constexpr TimeType TimeType_MIN = static_cast<TimeType>(-1);
constexpr TimeType TimeType_MAX = static_cast<TimeType>(5);
constexpr int TimeType_ARRAYSIZE = 5 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
TimeType_descriptor();
template <typename T>
const std::string& TimeType_Name(T value) {
  static_assert(std::is_same<T, TimeType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TimeType_Name().");
  return TimeType_Name(static_cast<TimeType>(value));
}
template <>
inline const std::string& TimeType_Name(TimeType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<TimeType_descriptor,
                                                 -1, 5>(
      static_cast<int>(value));
}
inline bool TimeType_Parse(absl::string_view name, TimeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TimeType>(
      TimeType_descriptor(), name, value);
}
enum ApplicationType : int {
  APPLICATION_TYPE_MANUAL = 0,
  APPLICATION_TYPE_ATS = 1,
  APPLICATION_TYPE_PROFESSIONAL = 2,
  APPLICATION_TYPE_NON_PROFESSIONAL = 3,
  APPLICATION_TYPE_TRADE_DESK = 4,
  APPLICATION_TYPE_WALLBOARD = 5,
  APPLICATION_TYPE_SUB_VENDOR = 6,
  APPLICATION_TYPE_ATS_DISPLAY = 7,
  APPLICATION_TYPE_FINANCIAL_PROFESSIONAL = 8,
  ApplicationType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ApplicationType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ApplicationType_IsValid(int value);
constexpr ApplicationType ApplicationType_MIN = static_cast<ApplicationType>(0);
constexpr ApplicationType ApplicationType_MAX = static_cast<ApplicationType>(8);
constexpr int ApplicationType_ARRAYSIZE = 8 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ApplicationType_descriptor();
template <typename T>
const std::string& ApplicationType_Name(T value) {
  static_assert(std::is_same<T, ApplicationType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ApplicationType_Name().");
  return ApplicationType_Name(static_cast<ApplicationType>(value));
}
template <>
inline const std::string& ApplicationType_Name(ApplicationType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ApplicationType_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool ApplicationType_Parse(absl::string_view name, ApplicationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ApplicationType>(
      ApplicationType_descriptor(), name, value);
}
enum BuySell : int {
  BUY_SELL_UNDEFINED = 0,
  BUY_SELL_BUY = 1,
  BUY_SELL_SELL = -1,
  BuySell_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  BuySell_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool BuySell_IsValid(int value);
constexpr BuySell BuySell_MIN = static_cast<BuySell>(-1);
constexpr BuySell BuySell_MAX = static_cast<BuySell>(1);
constexpr int BuySell_ARRAYSIZE = 1 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
BuySell_descriptor();
template <typename T>
const std::string& BuySell_Name(T value) {
  static_assert(std::is_same<T, BuySell>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to BuySell_Name().");
  return BuySell_Name(static_cast<BuySell>(value));
}
template <>
inline const std::string& BuySell_Name(BuySell value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<BuySell_descriptor,
                                                 -1, 1>(
      static_cast<int>(value));
}
inline bool BuySell_Parse(absl::string_view name, BuySell* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BuySell>(
      BuySell_descriptor(), name, value);
}
enum CTI : int {
  CTI_UNDEFINED = 0,
  CTI_MEMBER = 1,
  CTI_PROPRIETARY = 2,
  CTI_BROKER_MEMBER = 3,
  CTI_BROKER_CUSTOMER = 4,
  CTI_NONE = -1,
  CTI_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CTI_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CTI_IsValid(int value);
constexpr CTI CTI_MIN = static_cast<CTI>(-1);
constexpr CTI CTI_MAX = static_cast<CTI>(4);
constexpr int CTI_ARRAYSIZE = 4 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
CTI_descriptor();
template <typename T>
const std::string& CTI_Name(T value) {
  static_assert(std::is_same<T, CTI>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CTI_Name().");
  return CTI_Name(static_cast<CTI>(value));
}
template <>
inline const std::string& CTI_Name(CTI value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<CTI_descriptor,
                                                 -1, 4>(
      static_cast<int>(value));
}
inline bool CTI_Parse(absl::string_view name, CTI* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CTI>(
      CTI_descriptor(), name, value);
}
enum Origin : int {
  ORIGIN_UNDEFINED = 0,
  ORIGIN_CUSTOMER = 1,
  ORIGIN_NON_CUSTOMER = 2,
  ORIGIN_OTHER_MEMBERS = 3,
  ORIGIN_FLOOR_BROKERS = 4,
  ORIGIN_POSTING_NONE = 5,
  ORIGIN_POSTING_MANUAL = 6,
  ORIGIN_POSTING_AUTOMATIC = 7,
  ORIGIN_POSTING_GIVE_UP = 8,
  ORIGIN_POSTING_AUTO_AND_ACT_AUTHORISATION = 9,
  ORIGIN_POSTING_MANUAL_AND_ACT_AUTHORISATION = 10,
  ORIGIN_PRINCIPAL = 11,
  ORIGIN_MARKET_MAKER = 12,
  Origin_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Origin_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Origin_IsValid(int value);
constexpr Origin Origin_MIN = static_cast<Origin>(0);
constexpr Origin Origin_MAX = static_cast<Origin>(12);
constexpr int Origin_ARRAYSIZE = 12 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
Origin_descriptor();
template <typename T>
const std::string& Origin_Name(T value) {
  static_assert(std::is_same<T, Origin>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Origin_Name().");
  return Origin_Name(static_cast<Origin>(value));
}
template <>
inline const std::string& Origin_Name(Origin value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<Origin_descriptor,
                                                 0, 12>(
      static_cast<int>(value));
}
inline bool Origin_Parse(absl::string_view name, Origin* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Origin>(
      Origin_descriptor(), name, value);
}
enum AccountCode : int {
  ACCOUNT_CODE_UNDEFINED = 0,
  ACCOUNT_CODE_NONE = 1,
  ACCOUNT_CODE_GIVE_UP_TO_SINGLE_FIRM = 2,
  ACCOUNT_CODE_GIVE_UP_TO_MULTIPLE_FIRMS = 3,
  ACCOUNT_CODE_MARKET_MAKER = 4,
  ACCOUNT_CODE_AGENT_A1 = 5,
  ACCOUNT_CODE_GIVE_UP_G1 = 6,
  ACCOUNT_CODE_GIVE_UP_G2 = 7,
  ACCOUNT_CODE_MARKET_MAKER_M1 = 8,
  ACCOUNT_CODE_MARKET_MAKER_M2 = 9,
  ACCOUNT_CODE_PROPRIETARY_P1 = 10,
  ACCOUNT_CODE_PROPRIETARY_P2 = 11,
  ACCOUNT_CODE_SEGREGATED = 12,
  ACCOUNT_CODE_NON_SEGREGATED = 13,
  ACCOUNT_CODE_HOUSE = 14,
  ACCOUNT_CODE_LOCAL = 15,
  ACCOUNT_CODE_DEFAULT = 16,
  ACCOUNT_CODE_ALLOCATED = 17,
  ACCOUNT_CODE_SPLIT = 18,
  ACCOUNT_CODE_UNASSIGNED = 19,
  ACCOUNT_CODE_GAS_ASSOCIATE = 20,
  ACCOUNT_CODE_CUSTOMER = 21,
  ACCOUNT_CODE_US_CUSTOMER_FUTURES = 22,
  ACCOUNT_CODE_US_CUSTOMER_SWAPS = 23,
  ACCOUNT_CODE_US_CUSTOMER_FBOT = 24,
  ACCOUNT_CODE_FIRM = 25,
  ACCOUNT_CODE_MEMBER_CUSTOMER_SEGREGATED_ACCOUNT = 26,
  ACCOUNT_CODE_MEMBER_HOUSE_ACCOUNT = 27,
  ACCOUNT_CODE_MEMBER_SIPC_PROTECTED_ACCOUNT = 28,
  ACCOUNT_CODE_USER_PROXY_FOR_TRADER_CUSTOMER_SEGREGATED_ACCOUNT = 29,
  ACCOUNT_CODE_USER_PROXY_FOR_TRADER_HOUSE_ACCOUNT = 30,
  ACCOUNT_CODE_USER_PROXY_FOR_TRADER_SIPC_PROTECTED_ACCOUNT = 31,
  ACCOUNT_CODE_NON_MEMBER_HOUSE_ACCOUNT = 32,
  ACCOUNT_CODE_NON_MEMBER_SIPC_PROTECTED_ACCOUNT = 33,
  ACCOUNT_CODE_CUSTOMER_FLOOR_BROKER_WORKSTATION = 34,
  ACCOUNT_CODE_AGENT_A2 = 35,
  ACCOUNT_CODE_AGENT_A3 = 36,
  ACCOUNT_CODE_AGENT_A4 = 37,
  ACCOUNT_CODE_AGENT_A5 = 38,
  ACCOUNT_CODE_AGENT_A6 = 39,
  ACCOUNT_CODE_AGENT_A7 = 40,
  ACCOUNT_CODE_AGENT_A8 = 41,
  ACCOUNT_CODE_AGENT_A9 = 42,
  ACCOUNT_CODE_CLIENT_SEGREGATED_E = 43,
  ACCOUNT_CODE_CLIENT_SEGREGATED_K = 44,
  ACCOUNT_CODE_CLIENT_SEGREGATED_R = 45,
  ACCOUNT_CODE_SEGREGATED_T = 46,
  ACCOUNT_CODE_INDIRECT_CLEARING_GROSS_ISOC_CASS = 47,
  ACCOUNT_CODE_INDIRECT_CLEARING_GROSS_ISOC_TTFCA = 48,
  ACCOUNT_CODE_INDIRECT_CLEARING_GROSS_CASS = 49,
  ACCOUNT_CODE_INDIRECT_CLEARING_GROSS_TTFCA = 50,
  ACCOUNT_CODE_INDIRECT_CLEARING_NET_CASS = 51,
  ACCOUNT_CODE_INDIRECT_CLEARING_NETS_TTFCA = 52,
  ACCOUNT_CODE_RO = 53,
  ACCOUNT_CODE_LIQUIDITY_PROVIDER = 54,
  ACCOUNT_CODE_RELATED_PARTY = 55,
  ACCOUNT_CODE_STRUCTURED_PRODUCT_MARKET_MAKER = 56,
  ACCOUNT_CODE_OMEGA_CLIENT = 57,
  ACCOUNT_CODE_CERES_CLIENT = 58,
  AccountCode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AccountCode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AccountCode_IsValid(int value);
constexpr AccountCode AccountCode_MIN = static_cast<AccountCode>(0);
constexpr AccountCode AccountCode_MAX = static_cast<AccountCode>(58);
constexpr int AccountCode_ARRAYSIZE = 58 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
AccountCode_descriptor();
template <typename T>
const std::string& AccountCode_Name(T value) {
  static_assert(std::is_same<T, AccountCode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AccountCode_Name().");
  return AccountCode_Name(static_cast<AccountCode>(value));
}
template <>
inline const std::string& AccountCode_Name(AccountCode value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<AccountCode_descriptor,
                                                 0, 58>(
      static_cast<int>(value));
}
inline bool AccountCode_Parse(absl::string_view name, AccountCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AccountCode>(
      AccountCode_descriptor(), name, value);
}
enum OpenClose : int {
  OPEN_CLOSE_OPEN = 0,
  OPEN_CLOSE_CLOSE = 1,
  OPEN_CLOSE_UNDEFINED = -1,
  OpenClose_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  OpenClose_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool OpenClose_IsValid(int value);
constexpr OpenClose OpenClose_MIN = static_cast<OpenClose>(-1);
constexpr OpenClose OpenClose_MAX = static_cast<OpenClose>(1);
constexpr int OpenClose_ARRAYSIZE = 1 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
OpenClose_descriptor();
template <typename T>
const std::string& OpenClose_Name(T value) {
  static_assert(std::is_same<T, OpenClose>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OpenClose_Name().");
  return OpenClose_Name(static_cast<OpenClose>(value));
}
template <>
inline const std::string& OpenClose_Name(OpenClose value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<OpenClose_descriptor,
                                                 -1, 1>(
      static_cast<int>(value));
}
inline bool OpenClose_Parse(absl::string_view name, OpenClose* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OpenClose>(
      OpenClose_descriptor(), name, value);
}
enum CustOrderHandlingInstType : int {
  CUST_ORDER_HANDLING_INST_TYPE_NONE = 0,
  CUST_ORDER_HANDLING_INST_TYPE_DESK = 1,
  CUST_ORDER_HANDLING_INST_TYPE_ELECTRONIC = 2,
  CUST_ORDER_HANDLING_INST_TYPE_VENDOR_PROVIDED_PLATFORM = 3,
  CUST_ORDER_HANDLING_INST_TYPE_SPONSORED_ACCESS_VIA_API_OR_FIX = 4,
  CUST_ORDER_HANDLING_INST_TYPE_PREMIUM_ALGO_TRADING_PROVIDER = 5,
  CUST_ORDER_HANDLING_INST_TYPE_OTHER = 6,
  CustOrderHandlingInstType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CustOrderHandlingInstType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CustOrderHandlingInstType_IsValid(int value);
constexpr CustOrderHandlingInstType CustOrderHandlingInstType_MIN = static_cast<CustOrderHandlingInstType>(0);
constexpr CustOrderHandlingInstType CustOrderHandlingInstType_MAX = static_cast<CustOrderHandlingInstType>(6);
constexpr int CustOrderHandlingInstType_ARRAYSIZE = 6 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
CustOrderHandlingInstType_descriptor();
template <typename T>
const std::string& CustOrderHandlingInstType_Name(T value) {
  static_assert(std::is_same<T, CustOrderHandlingInstType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CustOrderHandlingInstType_Name().");
  return CustOrderHandlingInstType_Name(static_cast<CustOrderHandlingInstType>(value));
}
template <>
inline const std::string& CustOrderHandlingInstType_Name(CustOrderHandlingInstType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<CustOrderHandlingInstType_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool CustOrderHandlingInstType_Parse(absl::string_view name, CustOrderHandlingInstType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CustOrderHandlingInstType>(
      CustOrderHandlingInstType_descriptor(), name, value);
}
enum AvgPriceIndicatorType : int {
  AVG_PRICE_INDICATOR_TYPE_NONE = 0,
  AVG_PRICE_INDICATOR_TYPE_AVERAGE_PRICE_GROUP = 1,
  AVG_PRICE_INDICATOR_TYPE_NOTIONAL_VALUE_AVERAGE = 2,
  AvgPriceIndicatorType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AvgPriceIndicatorType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AvgPriceIndicatorType_IsValid(int value);
constexpr AvgPriceIndicatorType AvgPriceIndicatorType_MIN = static_cast<AvgPriceIndicatorType>(0);
constexpr AvgPriceIndicatorType AvgPriceIndicatorType_MAX = static_cast<AvgPriceIndicatorType>(2);
constexpr int AvgPriceIndicatorType_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
AvgPriceIndicatorType_descriptor();
template <typename T>
const std::string& AvgPriceIndicatorType_Name(T value) {
  static_assert(std::is_same<T, AvgPriceIndicatorType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AvgPriceIndicatorType_Name().");
  return AvgPriceIndicatorType_Name(static_cast<AvgPriceIndicatorType>(value));
}
template <>
inline const std::string& AvgPriceIndicatorType_Name(AvgPriceIndicatorType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<AvgPriceIndicatorType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool AvgPriceIndicatorType_Parse(absl::string_view name, AvgPriceIndicatorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AvgPriceIndicatorType>(
      AvgPriceIndicatorType_descriptor(), name, value);
}
enum ClearingTradePriceType : int {
  CLEARING_TRADE_PRICE_TYPE_EXECUTION_PRICE = 0,
  CLEARING_TRADE_PRICE_TYPE_ALTERNATE_CLEARING_PRICE = 1,
  ClearingTradePriceType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ClearingTradePriceType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ClearingTradePriceType_IsValid(int value);
constexpr ClearingTradePriceType ClearingTradePriceType_MIN = static_cast<ClearingTradePriceType>(0);
constexpr ClearingTradePriceType ClearingTradePriceType_MAX = static_cast<ClearingTradePriceType>(1);
constexpr int ClearingTradePriceType_ARRAYSIZE = 1 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ClearingTradePriceType_descriptor();
template <typename T>
const std::string& ClearingTradePriceType_Name(T value) {
  static_assert(std::is_same<T, ClearingTradePriceType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ClearingTradePriceType_Name().");
  return ClearingTradePriceType_Name(static_cast<ClearingTradePriceType>(value));
}
template <>
inline const std::string& ClearingTradePriceType_Name(ClearingTradePriceType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ClearingTradePriceType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool ClearingTradePriceType_Parse(absl::string_view name, ClearingTradePriceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ClearingTradePriceType>(
      ClearingTradePriceType_descriptor(), name, value);
}
enum BillingFee : int {
  BILLING_FEE_UNDEFINED = 0,
  BILLING_FEE_CUSTOMER = 1,
  BILLING_FEE_EQUITY_MEMBER = 2,
  BILLING_FEE_FIRM_106HJ = 3,
  BILLING_FEE_LESSEE_106F_EMPLOYEE = 4,
  BILLING_FEE_CBOE_MEMBER = 5,
  BillingFee_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  BillingFee_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool BillingFee_IsValid(int value);
constexpr BillingFee BillingFee_MIN = static_cast<BillingFee>(0);
constexpr BillingFee BillingFee_MAX = static_cast<BillingFee>(5);
constexpr int BillingFee_ARRAYSIZE = 5 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
BillingFee_descriptor();
template <typename T>
const std::string& BillingFee_Name(T value) {
  static_assert(std::is_same<T, BillingFee>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to BillingFee_Name().");
  return BillingFee_Name(static_cast<BillingFee>(value));
}
template <>
inline const std::string& BillingFee_Name(BillingFee value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<BillingFee_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool BillingFee_Parse(absl::string_view name, BillingFee* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BillingFee>(
      BillingFee_descriptor(), name, value);
}
enum OrderLink : int {
  ORDER_LINK_NONE = 0,
  ORDER_LINK_OCO = 1,
  ORDER_LINK_AUTO_OCO = 2,
  ORDER_LINK_SPARK = 3,
  ORDER_LINK_CLIENT_SYNTHETIC = 4,
  ORDER_LINK_SPARK2 = 5,
  ORDER_LINK_CHAIN2 = 6,
  ORDER_LINK_AUTO_OCO_P = 7,
  ORDER_LINK_AUTO_OCO_M = 8,
  ORDER_LINK_AUTO_OCO_MP = 9,
  OrderLink_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  OrderLink_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool OrderLink_IsValid(int value);
constexpr OrderLink OrderLink_MIN = static_cast<OrderLink>(0);
constexpr OrderLink OrderLink_MAX = static_cast<OrderLink>(9);
constexpr int OrderLink_ARRAYSIZE = 9 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
OrderLink_descriptor();
template <typename T>
const std::string& OrderLink_Name(T value) {
  static_assert(std::is_same<T, OrderLink>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OrderLink_Name().");
  return OrderLink_Name(static_cast<OrderLink>(value));
}
template <>
inline const std::string& OrderLink_Name(OrderLink value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<OrderLink_descriptor,
                                                 0, 9>(
      static_cast<int>(value));
}
inline bool OrderLink_Parse(absl::string_view name, OrderLink* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OrderLink>(
      OrderLink_descriptor(), name, value);
}
enum PrimaryUserType : int {
  PRIMARY_USER_TYPE_PRIMARY = 0,
  PRIMARY_USER_TYPE_SECONDARY = 1,
  PRIMARY_USER_TYPE_SECONDARY_APPLIED = 2,
  PRIMARY_USER_TYPE_SECONDARY_NOT_APPLIED = 3,
  PrimaryUserType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PrimaryUserType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PrimaryUserType_IsValid(int value);
constexpr PrimaryUserType PrimaryUserType_MIN = static_cast<PrimaryUserType>(0);
constexpr PrimaryUserType PrimaryUserType_MAX = static_cast<PrimaryUserType>(3);
constexpr int PrimaryUserType_ARRAYSIZE = 3 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
PrimaryUserType_descriptor();
template <typename T>
const std::string& PrimaryUserType_Name(T value) {
  static_assert(std::is_same<T, PrimaryUserType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PrimaryUserType_Name().");
  return PrimaryUserType_Name(static_cast<PrimaryUserType>(value));
}
template <>
inline const std::string& PrimaryUserType_Name(PrimaryUserType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<PrimaryUserType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool PrimaryUserType_Parse(absl::string_view name, PrimaryUserType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PrimaryUserType>(
      PrimaryUserType_descriptor(), name, value);
}
enum MasterType : int {
  MASTER_TYPE_MASTER = 0,
  MASTER_TYPE_CHILD = 1,
  MasterType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MasterType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MasterType_IsValid(int value);
constexpr MasterType MasterType_MIN = static_cast<MasterType>(0);
constexpr MasterType MasterType_MAX = static_cast<MasterType>(1);
constexpr int MasterType_ARRAYSIZE = 1 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
MasterType_descriptor();
template <typename T>
const std::string& MasterType_Name(T value) {
  static_assert(std::is_same<T, MasterType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MasterType_Name().");
  return MasterType_Name(static_cast<MasterType>(value));
}
template <>
inline const std::string& MasterType_Name(MasterType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<MasterType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool MasterType_Parse(absl::string_view name, MasterType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MasterType>(
      MasterType_descriptor(), name, value);
}
enum OrderSource : int {
  ORDER_SOURCE_UNKNOWN = 0,
  ORDER_SOURCE_API = 1,
  ORDER_SOURCE_WEB_TRADER = 2,
  ORDER_SOURCE_MOBILE = 3,
  ORDER_SOURCE_DATA_IMPORT = 4,
  ORDER_SOURCE_ACCOUNT_HANDLER = 5,
  ORDER_SOURCE_STATIC_LADDER = 20,
  ORDER_SOURCE_SCROLLING_LADDER = 21,
  ORDER_SOURCE_CENTERED_LADDER = 22,
  ORDER_SOURCE_AUTO_RECENTERED_LADDER = 23,
  ORDER_SOURCE_DEPTH = 24,
  ORDER_SOURCE_QUOTEBOARD = 25,
  ORDER_SOURCE_OPTIONBOARD = 26,
  ORDER_SOURCE_ADV_OPTIONBOARD = 27,
  ORDER_SOURCE_ORDERBOOK = 28,
  ORDER_SOURCE_SPREAD_MATRIX = 29,
  ORDER_SOURCE_FIX_API = 30,
  ORDER_SOURCE_CLIENT_SPREADER = 31,
  ORDER_SOURCE_ANTS_OPTION_SHEET = 32,
  ORDER_SOURCE_ANTS_OPTION_STRATEGY_SOLVER = 33,
  ORDER_SOURCE_JAVA_API = 34,
  ORDER_SOURCE_ANTS_OPTION_STRATEGIES_WINDOW = 35,
  ORDER_SOURCE_CHART = 36,
  ORDER_SOURCE_STP = 37,
  ORDER_SOURCE_T4_ANDROID_SCROLLING_LADDER = 38,
  ORDER_SOURCE_T4_ANDROID_CENTERED_LADDER = 39,
  ORDER_SOURCE_T4_ANDROID_AUTO_RECENTERED_LADDER = 40,
  ORDER_SOURCE_T4_ANDROID_DEPTH = 41,
  ORDER_SOURCE_T4_ANDROID_QUOTEBOARD = 42,
  ORDER_SOURCE_T4_ANDROID_POSITIONS = 43,
  ORDER_SOURCE_T4_ANDROID_ORDERS = 44,
  ORDER_SOURCE_T4_ANDROID_CHART = 45,
  ORDER_SOURCE_MQ = 46,
  ORDER_SOURCE_IOS_API = 47,
  ORDER_SOURCE_T4_IOS_SCROLLING_LADDER = 48,
  ORDER_SOURCE_T4_IOS_CENTERED_LADDER = 49,
  ORDER_SOURCE_T4_IOS_AUTO_RECENTERED_LADDER = 50,
  ORDER_SOURCE_T4_IOS_DEPTH = 51,
  ORDER_SOURCE_T4_IOS_QUOTEBOARD = 52,
  ORDER_SOURCE_T4_IOS_POSITIONS = 53,
  ORDER_SOURCE_T4_IOS_ORDERS = 54,
  ORDER_SOURCE_T4_IOS_CHART = 55,
  ORDER_SOURCE_KEYBOARD = 56,
  ORDER_SOURCE_HTTP_API = 57,
  OrderSource_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  OrderSource_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool OrderSource_IsValid(int value);
constexpr OrderSource OrderSource_MIN = static_cast<OrderSource>(0);
constexpr OrderSource OrderSource_MAX = static_cast<OrderSource>(57);
constexpr int OrderSource_ARRAYSIZE = 57 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
OrderSource_descriptor();
template <typename T>
const std::string& OrderSource_Name(T value) {
  static_assert(std::is_same<T, OrderSource>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OrderSource_Name().");
  return OrderSource_Name(static_cast<OrderSource>(value));
}
template <>
inline const std::string& OrderSource_Name(OrderSource value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<OrderSource_descriptor,
                                                 0, 57>(
      static_cast<int>(value));
}
inline bool OrderSource_Parse(absl::string_view name, OrderSource* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OrderSource>(
      OrderSource_descriptor(), name, value);
}
enum OrderSourceMethod : int {
  ORDER_SOURCE_METHOD_UNKNOWN = 0,
  ORDER_SOURCE_METHOD_CLICK = 1,
  ORDER_SOURCE_METHOD_PROMPT = 2,
  ORDER_SOURCE_METHOD_PRICE_CONFIRM = 3,
  ORDER_SOURCE_METHOD_ORDER_TICKET = 4,
  ORDER_SOURCE_METHOD_KEY_ENTRY = 5,
  ORDER_SOURCE_METHOD_ORDER_LOAD_BAR = 6,
  ORDER_SOURCE_METHOD_CONTRACT_TICKET = 7,
  ORDER_SOURCE_METHOD_QUEUED_ORDER_TICKET = 8,
  ORDER_SOURCE_METHOD_CLEARING_HOUSE = 9,
  ORDER_SOURCE_METHOD_ELECTRONIC = 10,
  ORDER_SOURCE_METHOD_OFF_FACILITY_SWAP = 11,
  ORDER_SOURCE_METHOD_PIT = 12,
  ORDER_SOURCE_METHOD_REGISTERED_MARKET = 13,
  ORDER_SOURCE_METHOD_EX_PIT = 14,
  OrderSourceMethod_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  OrderSourceMethod_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool OrderSourceMethod_IsValid(int value);
constexpr OrderSourceMethod OrderSourceMethod_MIN = static_cast<OrderSourceMethod>(0);
constexpr OrderSourceMethod OrderSourceMethod_MAX = static_cast<OrderSourceMethod>(14);
constexpr int OrderSourceMethod_ARRAYSIZE = 14 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
OrderSourceMethod_descriptor();
template <typename T>
const std::string& OrderSourceMethod_Name(T value) {
  static_assert(std::is_same<T, OrderSourceMethod>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OrderSourceMethod_Name().");
  return OrderSourceMethod_Name(static_cast<OrderSourceMethod>(value));
}
template <>
inline const std::string& OrderSourceMethod_Name(OrderSourceMethod value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<OrderSourceMethod_descriptor,
                                                 0, 14>(
      static_cast<int>(value));
}
inline bool OrderSourceMethod_Parse(absl::string_view name, OrderSourceMethod* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OrderSourceMethod>(
      OrderSourceMethod_descriptor(), name, value);
}
enum AccountSubscribeType : int {
  ACCOUNT_SUBSCRIBE_TYPE_NONE = 0,
  ACCOUNT_SUBSCRIBE_TYPE_ALL_UPDATES = 2,
  AccountSubscribeType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AccountSubscribeType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AccountSubscribeType_IsValid(int value);
constexpr AccountSubscribeType AccountSubscribeType_MIN = static_cast<AccountSubscribeType>(0);
constexpr AccountSubscribeType AccountSubscribeType_MAX = static_cast<AccountSubscribeType>(2);
constexpr int AccountSubscribeType_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
AccountSubscribeType_descriptor();
template <typename T>
const std::string& AccountSubscribeType_Name(T value) {
  static_assert(std::is_same<T, AccountSubscribeType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AccountSubscribeType_Name().");
  return AccountSubscribeType_Name(static_cast<AccountSubscribeType>(value));
}
template <>
inline const std::string& AccountSubscribeType_Name(AccountSubscribeType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<AccountSubscribeType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool AccountSubscribeType_Parse(absl::string_view name, AccountSubscribeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AccountSubscribeType>(
      AccountSubscribeType_descriptor(), name, value);
}
enum UPLMode : int {
  UPL_MODE_NONE = 0,
  UPL_MODE_AVERAGE = 1,
  UPLMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UPLMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UPLMode_IsValid(int value);
constexpr UPLMode UPLMode_MIN = static_cast<UPLMode>(0);
constexpr UPLMode UPLMode_MAX = static_cast<UPLMode>(1);
constexpr int UPLMode_ARRAYSIZE = 1 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
UPLMode_descriptor();
template <typename T>
const std::string& UPLMode_Name(T value) {
  static_assert(std::is_same<T, UPLMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to UPLMode_Name().");
  return UPLMode_Name(static_cast<UPLMode>(value));
}
template <>
inline const std::string& UPLMode_Name(UPLMode value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<UPLMode_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool UPLMode_Parse(absl::string_view name, UPLMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UPLMode>(
      UPLMode_descriptor(), name, value);
}
enum UDSStatus : int {
  UDS_STATUS_UNKNOWN = 0,
  UDS_STATUS_Success = 1,
  UDS_STATUS_FAILED = 2,
  UDS_STATUS_ALREADY_EXISTS = 3,
  UDSStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UDSStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UDSStatus_IsValid(int value);
constexpr UDSStatus UDSStatus_MIN = static_cast<UDSStatus>(0);
constexpr UDSStatus UDSStatus_MAX = static_cast<UDSStatus>(3);
constexpr int UDSStatus_ARRAYSIZE = 3 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
UDSStatus_descriptor();
template <typename T>
const std::string& UDSStatus_Name(T value) {
  static_assert(std::is_same<T, UDSStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to UDSStatus_Name().");
  return UDSStatus_Name(static_cast<UDSStatus>(value));
}
template <>
inline const std::string& UDSStatus_Name(UDSStatus value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<UDSStatus_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool UDSStatus_Parse(absl::string_view name, UDSStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UDSStatus>(
      UDSStatus_descriptor(), name, value);
}

// ===================================================================



// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace common
}  // namespace v1
}  // namespace t4proto


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::t4proto::v1::common::LoginResult> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::LoginResult>() {
  return ::t4proto::v1::common::LoginResult_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::PriceFormat> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::PriceFormat>() {
  return ::t4proto::v1::common::PriceFormat_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::AccountMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::AccountMode>() {
  return ::t4proto::v1::common::AccountMode_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::MarketMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::MarketMode>() {
  return ::t4proto::v1::common::MarketMode_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::DepthBuffer> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::DepthBuffer>() {
  return ::t4proto::v1::common::DepthBuffer_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::DepthLevels> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::DepthLevels>() {
  return ::t4proto::v1::common::DepthLevels_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::BidOffer> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::BidOffer>() {
  return ::t4proto::v1::common::BidOffer_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::MarketFlags2> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::MarketFlags2>() {
  return ::t4proto::v1::common::MarketFlags2_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::ContractType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::ContractType>() {
  return ::t4proto::v1::common::ContractType_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::MarketDataType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::MarketDataType>() {
  return ::t4proto::v1::common::MarketDataType_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::StrategyType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::StrategyType>() {
  return ::t4proto::v1::common::StrategyType_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::ContractRiskStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::ContractRiskStatus>() {
  return ::t4proto::v1::common::ContractRiskStatus_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::AccountStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::AccountStatus>() {
  return ::t4proto::v1::common::AccountStatus_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::AccountEnabled> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::AccountEnabled>() {
  return ::t4proto::v1::common::AccountEnabled_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::AccountMarginType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::AccountMarginType>() {
  return ::t4proto::v1::common::AccountMarginType_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::OrderChange> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::OrderChange>() {
  return ::t4proto::v1::common::OrderChange_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::OrderStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::OrderStatus>() {
  return ::t4proto::v1::common::OrderStatus_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::ResponsePending> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::ResponsePending>() {
  return ::t4proto::v1::common::ResponsePending_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::ActivationType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::ActivationType>() {
  return ::t4proto::v1::common::ActivationType_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::PriceType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::PriceType>() {
  return ::t4proto::v1::common::PriceType_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::TimeType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::TimeType>() {
  return ::t4proto::v1::common::TimeType_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::ApplicationType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::ApplicationType>() {
  return ::t4proto::v1::common::ApplicationType_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::BuySell> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::BuySell>() {
  return ::t4proto::v1::common::BuySell_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::CTI> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::CTI>() {
  return ::t4proto::v1::common::CTI_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::Origin> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::Origin>() {
  return ::t4proto::v1::common::Origin_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::AccountCode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::AccountCode>() {
  return ::t4proto::v1::common::AccountCode_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::OpenClose> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::OpenClose>() {
  return ::t4proto::v1::common::OpenClose_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::CustOrderHandlingInstType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::CustOrderHandlingInstType>() {
  return ::t4proto::v1::common::CustOrderHandlingInstType_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::AvgPriceIndicatorType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::AvgPriceIndicatorType>() {
  return ::t4proto::v1::common::AvgPriceIndicatorType_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::ClearingTradePriceType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::ClearingTradePriceType>() {
  return ::t4proto::v1::common::ClearingTradePriceType_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::BillingFee> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::BillingFee>() {
  return ::t4proto::v1::common::BillingFee_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::OrderLink> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::OrderLink>() {
  return ::t4proto::v1::common::OrderLink_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::PrimaryUserType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::PrimaryUserType>() {
  return ::t4proto::v1::common::PrimaryUserType_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::MasterType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::MasterType>() {
  return ::t4proto::v1::common::MasterType_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::OrderSource> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::OrderSource>() {
  return ::t4proto::v1::common::OrderSource_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::OrderSourceMethod> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::OrderSourceMethod>() {
  return ::t4proto::v1::common::OrderSourceMethod_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::AccountSubscribeType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::AccountSubscribeType>() {
  return ::t4proto::v1::common::AccountSubscribeType_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::UPLMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::UPLMode>() {
  return ::t4proto::v1::common::UPLMode_descriptor();
}
template <>
struct is_proto_enum<::t4proto::v1::common::UDSStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::t4proto::v1::common::UDSStatus>() {
  return ::t4proto::v1::common::UDSStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_t4_2fv1_2fcommon_2fenums_2eproto_2epb_2eh
