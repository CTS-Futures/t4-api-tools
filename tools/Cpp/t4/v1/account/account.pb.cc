// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: t4/v1/account/account.proto

#include "t4/v1/account/account.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace t4proto {
namespace v1 {
namespace account {
PROTOBUF_CONSTEXPR AccountSubscribe::AccountSubscribe(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_id_)*/{}
  , /*decltype(_impl_.subscribe_)*/ 0

  , /*decltype(_impl_.subscribe_all_accounts_)*/ false

  , /*decltype(_impl_.upl_mode_)*/ 0
} {}
struct AccountSubscribeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccountSubscribeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccountSubscribeDefaultTypeInternal() {}
  union {
    AccountSubscribe _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccountSubscribeDefaultTypeInternal _AccountSubscribe_default_instance_;
PROTOBUF_CONSTEXPR AccountSubscribeResponse::AccountSubscribeResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.errors_)*/{}
  , /*decltype(_impl_.success_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AccountSubscribeResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccountSubscribeResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccountSubscribeResponseDefaultTypeInternal() {}
  union {
    AccountSubscribeResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccountSubscribeResponseDefaultTypeInternal _AccountSubscribeResponse_default_instance_;
PROTOBUF_CONSTEXPR AccountCurrency::AccountCurrency(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.currency_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.rate_)*/ 0

  , /*decltype(_impl_.import_factor_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AccountCurrencyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccountCurrencyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccountCurrencyDefaultTypeInternal() {}
  union {
    AccountCurrency _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccountCurrencyDefaultTypeInternal _AccountCurrency_default_instance_;
PROTOBUF_CONSTEXPR AccountPosition::AccountPosition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.exchange_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.contract_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.trade_date_)*/nullptr
  , /*decltype(_impl_.average_open_price_)*/nullptr
  , /*decltype(_impl_.total_open_price_)*/nullptr
  , /*decltype(_impl_.total_buy_fill_price_)*/nullptr
  , /*decltype(_impl_.total_sell_fill_price_)*/nullptr
  , /*decltype(_impl_.day_total_buy_fill_price_)*/nullptr
  , /*decltype(_impl_.day_total_sell_fill_price_)*/nullptr
  , /*decltype(_impl_.total_overnight_price_)*/nullptr
  , /*decltype(_impl_.margin_time_)*/nullptr
  , /*decltype(_impl_.alerting_time_)*/nullptr
  , /*decltype(_impl_.buys_)*/ 0

  , /*decltype(_impl_.sells_)*/ 0

  , /*decltype(_impl_.working_buys_)*/ 0

  , /*decltype(_impl_.working_sells_)*/ 0

  , /*decltype(_impl_.rpl_)*/ 0

  , /*decltype(_impl_.overnight_upl_)*/ 0

  , /*decltype(_impl_.margin_)*/ 0

  , /*decltype(_impl_.mp_)*/ 0

  , /*decltype(_impl_.currency_rate_)*/ 0

  , /*decltype(_impl_.overnight_position_)*/ 0

  , /*decltype(_impl_.total_open_volume_)*/ 0

  , /*decltype(_impl_.premium_)*/ 0

  , /*decltype(_impl_.fees_and_commissions_)*/ 0

  , /*decltype(_impl_.long_mp_)*/ 0

  , /*decltype(_impl_.short_mp_)*/ 0

  , /*decltype(_impl_.prev_margin_)*/ 0

  , /*decltype(_impl_.prev_rpl_)*/ 0

  , /*decltype(_impl_.prev_position_)*/ 0

  , /*decltype(_impl_.day_buys_)*/ 0

  , /*decltype(_impl_.prev_upl_)*/ 0

  , /*decltype(_impl_.day_sells_)*/ 0

  , /*decltype(_impl_.risk_status_)*/ 0

  , /*decltype(_impl_.alerting_margin_)*/ 0

  , /*decltype(_impl_.day_margin_)*/ 0

  , /*decltype(_impl_.full_margin_)*/ 0

  , /*decltype(_impl_.pre_trade_margin_)*/ 0
} {}
struct AccountPositionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccountPositionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccountPositionDefaultTypeInternal() {}
  union {
    AccountPosition _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccountPositionDefaultTypeInternal _AccountPosition_default_instance_;
PROTOBUF_CONSTEXPR AccountUpdate::AccountUpdate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.account_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.imported_net_liq_date_)*/nullptr
  , /*decltype(_impl_.prev_imported_net_liq_date_)*/nullptr
  , /*decltype(_impl_.margin_time_)*/nullptr
  , /*decltype(_impl_.alerting_time_)*/nullptr
  , /*decltype(_impl_.balance_)*/ 0

  , /*decltype(_impl_.rpl_)*/ 0

  , /*decltype(_impl_.overnight_upl_)*/ 0

  , /*decltype(_impl_.margin_)*/ 0

  , /*decltype(_impl_.day_margin_)*/ 0

  , /*decltype(_impl_.full_margin_)*/ 0

  , /*decltype(_impl_.base_margin_)*/ 0

  , /*decltype(_impl_.alerting_margin_)*/ 0

  , /*decltype(_impl_.pre_trade_margin_)*/ 0

  , /*decltype(_impl_.mp_)*/ 0

  , /*decltype(_impl_.premium_)*/ 0

  , /*decltype(_impl_.long_mp_)*/ 0

  , /*decltype(_impl_.short_mp_)*/ 0

  , /*decltype(_impl_.fees_and_commissions_)*/ 0

  , /*decltype(_impl_.prev_margin_)*/ 0

  , /*decltype(_impl_.imported_net_liq_)*/ 0

  , /*decltype(_impl_.prev_imported_net_liq_)*/ 0

  , /*decltype(_impl_.filled_delta_)*/ 0

  , /*decltype(_impl_.working_delta_)*/ 0

  , /*decltype(_impl_.status_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AccountUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccountUpdateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccountUpdateDefaultTypeInternal() {}
  union {
    AccountUpdate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccountUpdateDefaultTypeInternal _AccountUpdate_default_instance_;
PROTOBUF_CONSTEXPR AccountDetails::AccountDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.account_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.account_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.account_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.firm_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.active_time_start_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.active_time_stop_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.firm_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.display_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.risk_details_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.group_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.enabled_)*/ 0

  , /*decltype(_impl_.max_clip_size_)*/ 0

  , /*decltype(_impl_.deleted_)*/ false

  , /*decltype(_impl_.pre_trade_disabled_)*/ false

  , /*decltype(_impl_.position_rollover_)*/ false

  , /*decltype(_impl_.pl_rollover_)*/ false

  , /*decltype(_impl_.margin_pc_)*/ 0

  , /*decltype(_impl_.min_balance_)*/ 0

  , /*decltype(_impl_.loss_limit_)*/ 0

  , /*decltype(_impl_.loss_limit_pc_)*/ 0

  , /*decltype(_impl_.overnight_margin_pc_)*/ 0

  , /*decltype(_impl_.warning_threshold_pl_)*/ 0

  , /*decltype(_impl_.warning_threshold_loss_limit_)*/ 0

  , /*decltype(_impl_.warning_threshold_margin_)*/ 0

  , /*decltype(_impl_.mode_)*/ 0

  , /*decltype(_impl_.day_loss_limit_)*/ 0

  , /*decltype(_impl_.max_account_position_)*/ 0

  , /*decltype(_impl_.wide_market_)*/ 0

  , /*decltype(_impl_.order_routing_)*/ false

  , /*decltype(_impl_.use_pl_for_margin_)*/ false

  , /*decltype(_impl_.options_settlement_)*/ false

  , /*decltype(_impl_.use_premium_for_margin_)*/ false

  , /*decltype(_impl_.margin_type_)*/ 0

  , /*decltype(_impl_.price_banding_)*/ 0

  , /*decltype(_impl_.day_loss_limit_pc_)*/ 0

  , /*decltype(_impl_.warning_threshold_min_net_equity_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AccountDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccountDetailsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccountDetailsDefaultTypeInternal() {}
  union {
    AccountDetails _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccountDetailsDefaultTypeInternal _AccountDetails_default_instance_;
PROTOBUF_CONSTEXPR AccountSnapshotMessage::AccountSnapshotMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.payload_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct AccountSnapshotMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccountSnapshotMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccountSnapshotMessageDefaultTypeInternal() {}
  union {
    AccountSnapshotMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccountSnapshotMessageDefaultTypeInternal _AccountSnapshotMessage_default_instance_;
PROTOBUF_CONSTEXPR AccountSnapshot::AccountSnapshot(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.messages_)*/{}
  , /*decltype(_impl_.account_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.last_update_requested_)*/ ::int64_t{0}

  , /*decltype(_impl_.last_update_supplied_)*/ ::int64_t{0}

  , /*decltype(_impl_.status_)*/ 0

  , /*decltype(_impl_.due_to_connection_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AccountSnapshotDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccountSnapshotDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccountSnapshotDefaultTypeInternal() {}
  union {
    AccountSnapshot _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccountSnapshotDefaultTypeInternal _AccountSnapshot_default_instance_;
PROTOBUF_CONSTEXPR AccountProfit::AccountProfit(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.update_time_)*/nullptr
  , /*decltype(_impl_.upl_)*/ 0

  , /*decltype(_impl_.upl_trade_)*/ 0

  , /*decltype(_impl_.rpl_)*/ 0

  , /*decltype(_impl_.day_upl_)*/ 0

  , /*decltype(_impl_.day_upl_trade_)*/ 0

  , /*decltype(_impl_.day_rpl_)*/ 0

  , /*decltype(_impl_.warning_pl_)*/ 0

  , /*decltype(_impl_.warning_loss_limit_)*/ 0

  , /*decltype(_impl_.warning_margin_)*/ 0

  , /*decltype(_impl_.total_working_orders_)*/ 0

  , /*decltype(_impl_.total_working_volume_)*/ 0

  , /*decltype(_impl_.is_alerting_live_margin_)*/ false

  , /*decltype(_impl_.is_alerting_full_margin_)*/ false
} {}
struct AccountProfitDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccountProfitDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccountProfitDefaultTypeInternal() {}
  union {
    AccountProfit _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccountProfitDefaultTypeInternal _AccountProfit_default_instance_;
PROTOBUF_CONSTEXPR AccountPositionProfit::AccountPositionProfit(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.exchange_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.contract_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.update_time_)*/nullptr
  , /*decltype(_impl_.net_)*/ 0

  , /*decltype(_impl_.upl_)*/ 0

  , /*decltype(_impl_.upl_trade_)*/ 0

  , /*decltype(_impl_.rpl_)*/ 0

  , /*decltype(_impl_.upl_usd_)*/ 0

  , /*decltype(_impl_.upl_trade_usd_)*/ 0

  , /*decltype(_impl_.rpl_usd_)*/ 0

  , /*decltype(_impl_.day_net_)*/ 0

  , /*decltype(_impl_.day_rpl_)*/ 0

  , /*decltype(_impl_.day_rpl_usd_)*/ 0

  , /*decltype(_impl_.day_upl_)*/ 0

  , /*decltype(_impl_.day_upl_trade_)*/ 0

  , /*decltype(_impl_.day_upl_usd_)*/ 0

  , /*decltype(_impl_.day_upl_trade_usd_)*/ 0

  , /*decltype(_impl_.delayed_)*/ false

  , /*decltype(_impl_.is_options_)*/ false

  , /*decltype(_impl_.has_data_)*/ false

  , /*decltype(_impl_.is_implied_)*/ false
} {}
struct AccountPositionProfitDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccountPositionProfitDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccountPositionProfitDefaultTypeInternal() {}
  union {
    AccountPositionProfit _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccountPositionProfitDefaultTypeInternal _AccountPositionProfit_default_instance_;
}  // namespace account
}  // namespace v1
}  // namespace t4proto
static ::_pb::Metadata file_level_metadata_t4_2fv1_2faccount_2faccount_2eproto[10];
static constexpr const ::_pb::EnumDescriptor**
    file_level_enum_descriptors_t4_2fv1_2faccount_2faccount_2eproto = nullptr;
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_t4_2fv1_2faccount_2faccount_2eproto = nullptr;
const ::uint32_t TableStruct_t4_2fv1_2faccount_2faccount_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountSubscribe, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountSubscribe, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountSubscribe, _impl_.subscribe_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountSubscribe, _impl_.subscribe_all_accounts_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountSubscribe, _impl_.account_id_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountSubscribe, _impl_.upl_mode_),
    ~0u,
    ~0u,
    ~0u,
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountSubscribeResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountSubscribeResponse, _impl_.success_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountSubscribeResponse, _impl_.errors_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountCurrency, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountCurrency, _impl_.currency_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountCurrency, _impl_.rate_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountCurrency, _impl_.import_factor_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.account_id_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.exchange_id_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.contract_id_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.buys_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.sells_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.working_buys_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.working_sells_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.rpl_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.overnight_upl_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.margin_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.mp_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.overnight_position_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.currency_rate_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.trade_date_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.premium_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.total_open_volume_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.fees_and_commissions_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.long_mp_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.short_mp_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.prev_position_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.prev_margin_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.prev_rpl_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.prev_upl_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.day_buys_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.day_sells_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.average_open_price_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.total_open_price_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.total_buy_fill_price_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.total_sell_fill_price_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.day_total_buy_fill_price_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.day_total_sell_fill_price_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.total_overnight_price_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.risk_status_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.margin_time_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.alerting_margin_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.alerting_time_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.day_margin_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.full_margin_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPosition, _impl_.pre_trade_margin_),
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountUpdate, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountUpdate, _impl_.account_id_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountUpdate, _impl_.status_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountUpdate, _impl_.balance_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountUpdate, _impl_.rpl_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountUpdate, _impl_.overnight_upl_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountUpdate, _impl_.margin_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountUpdate, _impl_.day_margin_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountUpdate, _impl_.full_margin_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountUpdate, _impl_.base_margin_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountUpdate, _impl_.alerting_margin_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountUpdate, _impl_.pre_trade_margin_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountUpdate, _impl_.mp_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountUpdate, _impl_.premium_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountUpdate, _impl_.long_mp_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountUpdate, _impl_.short_mp_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountUpdate, _impl_.fees_and_commissions_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountUpdate, _impl_.prev_margin_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountUpdate, _impl_.imported_net_liq_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountUpdate, _impl_.imported_net_liq_date_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountUpdate, _impl_.prev_imported_net_liq_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountUpdate, _impl_.prev_imported_net_liq_date_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountUpdate, _impl_.filled_delta_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountUpdate, _impl_.working_delta_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountUpdate, _impl_.margin_time_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountUpdate, _impl_.alerting_time_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.account_id_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.account_name_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.account_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.enabled_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.deleted_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.max_clip_size_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.pre_trade_disabled_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.position_rollover_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.pl_rollover_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.firm_id_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.min_balance_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.margin_pc_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.loss_limit_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.loss_limit_pc_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.overnight_margin_pc_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.order_routing_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.active_time_start_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.active_time_stop_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.warning_threshold_pl_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.warning_threshold_loss_limit_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.warning_threshold_margin_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.firm_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.mode_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.max_account_position_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.day_loss_limit_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.display_name_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.wide_market_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.use_pl_for_margin_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.margin_type_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.risk_details_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.price_banding_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.day_loss_limit_pc_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.options_settlement_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.group_name_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.use_premium_for_margin_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountDetails, _impl_.warning_threshold_min_net_equity_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountSnapshotMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountSnapshotMessage, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountSnapshotMessage, _impl_.payload_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountSnapshot, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountSnapshot, _impl_.account_id_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountSnapshot, _impl_.last_update_requested_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountSnapshot, _impl_.last_update_supplied_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountSnapshot, _impl_.status_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountSnapshot, _impl_.due_to_connection_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountSnapshot, _impl_.messages_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountProfit, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountProfit, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountProfit, _impl_.account_id_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountProfit, _impl_.update_time_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountProfit, _impl_.upl_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountProfit, _impl_.upl_trade_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountProfit, _impl_.rpl_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountProfit, _impl_.day_upl_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountProfit, _impl_.day_upl_trade_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountProfit, _impl_.day_rpl_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountProfit, _impl_.warning_pl_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountProfit, _impl_.warning_loss_limit_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountProfit, _impl_.warning_margin_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountProfit, _impl_.total_working_orders_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountProfit, _impl_.total_working_volume_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountProfit, _impl_.is_alerting_live_margin_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountProfit, _impl_.is_alerting_full_margin_),
    ~0u,
    ~0u,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPositionProfit, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPositionProfit, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPositionProfit, _impl_.account_id_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPositionProfit, _impl_.exchange_id_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPositionProfit, _impl_.contract_id_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPositionProfit, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPositionProfit, _impl_.delayed_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPositionProfit, _impl_.update_time_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPositionProfit, _impl_.is_options_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPositionProfit, _impl_.has_data_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPositionProfit, _impl_.is_implied_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPositionProfit, _impl_.net_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPositionProfit, _impl_.upl_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPositionProfit, _impl_.upl_trade_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPositionProfit, _impl_.rpl_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPositionProfit, _impl_.upl_usd_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPositionProfit, _impl_.upl_trade_usd_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPositionProfit, _impl_.rpl_usd_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPositionProfit, _impl_.day_net_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPositionProfit, _impl_.day_rpl_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPositionProfit, _impl_.day_rpl_usd_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPositionProfit, _impl_.day_upl_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPositionProfit, _impl_.day_upl_trade_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPositionProfit, _impl_.day_upl_usd_),
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountPositionProfit, _impl_.day_upl_trade_usd_),
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, 12, -1, sizeof(::t4proto::v1::account::AccountSubscribe)},
        { 16, -1, -1, sizeof(::t4proto::v1::account::AccountSubscribeResponse)},
        { 26, -1, -1, sizeof(::t4proto::v1::account::AccountCurrency)},
        { 37, 85, -1, sizeof(::t4proto::v1::account::AccountPosition)},
        { 125, -1, -1, sizeof(::t4proto::v1::account::AccountUpdate)},
        { 158, -1, -1, sizeof(::t4proto::v1::account::AccountDetails)},
        { 202, -1, -1, sizeof(::t4proto::v1::account::AccountSnapshotMessage)},
        { 217, -1, -1, sizeof(::t4proto::v1::account::AccountSnapshot)},
        { 231, 254, -1, sizeof(::t4proto::v1::account::AccountProfit)},
        { 269, 300, -1, sizeof(::t4proto::v1::account::AccountPositionProfit)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::t4proto::v1::account::_AccountSubscribe_default_instance_._instance,
    &::t4proto::v1::account::_AccountSubscribeResponse_default_instance_._instance,
    &::t4proto::v1::account::_AccountCurrency_default_instance_._instance,
    &::t4proto::v1::account::_AccountPosition_default_instance_._instance,
    &::t4proto::v1::account::_AccountUpdate_default_instance_._instance,
    &::t4proto::v1::account::_AccountDetails_default_instance_._instance,
    &::t4proto::v1::account::_AccountSnapshotMessage_default_instance_._instance,
    &::t4proto::v1::account::_AccountSnapshot_default_instance_._instance,
    &::t4proto::v1::account::_AccountProfit_default_instance_._instance,
    &::t4proto::v1::account::_AccountPositionProfit_default_instance_._instance,
};
const char descriptor_table_protodef_t4_2fv1_2faccount_2faccount_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\033t4/v1/account/account.proto\022\022t4proto.v"
    "1.account\032\037google/protobuf/timestamp.pro"
    "to\032\030t4/v1/common/enums.proto\032\030t4/v1/comm"
    "on/price.proto\032\031t4/v1/market/market.prot"
    "o\032%t4/v1/orderrouting/orderrouting.proto"
    "\"\302\001\n\020AccountSubscribe\022:\n\tsubscribe\030\001 \001(\016"
    "2\'.t4proto.v1.common.AccountSubscribeTyp"
    "e\022\036\n\026subscribe_all_accounts\030\002 \001(\010\022\022\n\nacc"
    "ount_id\030\003 \003(\t\0221\n\010upl_mode\030\004 \001(\0162\032.t4prot"
    "o.v1.common.UPLModeH\000\210\001\001B\013\n\t_upl_mode\";\n"
    "\030AccountSubscribeResponse\022\017\n\007success\030\001 \001"
    "(\010\022\016\n\006errors\030\002 \003(\t\"H\n\017AccountCurrency\022\020\n"
    "\010currency\030\001 \001(\t\022\014\n\004rate\030\002 \001(\001\022\025\n\rimport_"
    "factor\030\003 \001(\001\"\221\013\n\017AccountPosition\022\022\n\nacco"
    "unt_id\030\001 \001(\t\022\023\n\013exchange_id\030\002 \001(\t\022\023\n\013con"
    "tract_id\030\003 \001(\t\022\021\n\tmarket_id\030\004 \001(\t\022\014\n\004buy"
    "s\030\005 \001(\005\022\r\n\005sells\030\006 \001(\005\022\024\n\014working_buys\030\007"
    " \001(\005\022\025\n\rworking_sells\030\010 \001(\005\022\013\n\003rpl\030\t \001(\001"
    "\022\025\n\rovernight_upl\030\n \001(\001\022\016\n\006margin\030\013 \001(\001\022"
    "\n\n\002mp\030\014 \001(\001\022\032\n\022overnight_position\030\r \001(\005\022"
    "\025\n\rcurrency_rate\030\016 \001(\001\022.\n\ntrade_date\030\017 \001"
    "(\0132\032.google.protobuf.Timestamp\022\017\n\007premiu"
    "m\030\020 \001(\001\022\031\n\021total_open_volume\030\021 \001(\005\022\034\n\024fe"
    "es_and_commissions\030\022 \001(\001\022\017\n\007long_mp\030\023 \001("
    "\001\022\020\n\010short_mp\030\024 \001(\001\022\025\n\rprev_position\030\025 \001"
    "(\005\022\023\n\013prev_margin\030\026 \001(\001\022\020\n\010prev_rpl\030\027 \001("
    "\001\022\020\n\010prev_upl\030\030 \001(\001\022\020\n\010day_buys\030\031 \001(\005\022\021\n"
    "\tday_sells\030\032 \001(\005\0229\n\022average_open_price\030\033"
    " \001(\0132\030.t4proto.v1.common.PriceH\000\210\001\001\0227\n\020t"
    "otal_open_price\030\034 \001(\0132\030.t4proto.v1.commo"
    "n.PriceH\001\210\001\001\022;\n\024total_buy_fill_price\030\035 \001"
    "(\0132\030.t4proto.v1.common.PriceH\002\210\001\001\022<\n\025tot"
    "al_sell_fill_price\030\036 \001(\0132\030.t4proto.v1.co"
    "mmon.PriceH\003\210\001\001\022\?\n\030day_total_buy_fill_pr"
    "ice\030\037 \001(\0132\030.t4proto.v1.common.PriceH\004\210\001\001"
    "\022@\n\031day_total_sell_fill_price\030  \001(\0132\030.t4"
    "proto.v1.common.PriceH\005\210\001\001\022<\n\025total_over"
    "night_price\030! \001(\0132\030.t4proto.v1.common.Pr"
    "iceH\006\210\001\001\022:\n\013risk_status\030\" \001(\0162%.t4proto."
    "v1.common.ContractRiskStatus\022/\n\013margin_t"
    "ime\030# \001(\0132\032.google.protobuf.Timestamp\022\027\n"
    "\017alerting_margin\030$ \001(\001\0221\n\ralerting_time\030"
    "% \001(\0132\032.google.protobuf.Timestamp\022\022\n\nday"
    "_margin\030& \001(\001\022\023\n\013full_margin\030\' \001(\001\022\030\n\020pr"
    "e_trade_margin\030( \001(\001B\025\n\023_average_open_pr"
    "iceB\023\n\021_total_open_priceB\027\n\025_total_buy_f"
    "ill_priceB\030\n\026_total_sell_fill_priceB\033\n\031_"
    "day_total_buy_fill_priceB\034\n\032_day_total_s"
    "ell_fill_priceB\030\n\026_total_overnight_price"
    "\"\303\005\n\rAccountUpdate\022\022\n\naccount_id\030\001 \001(\t\0220"
    "\n\006status\030\002 \001(\0162 .t4proto.v1.common.Accou"
    "ntStatus\022\017\n\007balance\030\003 \001(\001\022\013\n\003rpl\030\004 \001(\001\022\025"
    "\n\rovernight_upl\030\005 \001(\001\022\016\n\006margin\030\006 \001(\001\022\022\n"
    "\nday_margin\030\007 \001(\001\022\023\n\013full_margin\030\010 \001(\001\022\023"
    "\n\013base_margin\030\t \001(\001\022\027\n\017alerting_margin\030\n"
    " \001(\001\022\030\n\020pre_trade_margin\030\013 \001(\001\022\n\n\002mp\030\014 \001"
    "(\001\022\017\n\007premium\030\r \001(\001\022\017\n\007long_mp\030\016 \001(\001\022\020\n\010"
    "short_mp\030\017 \001(\001\022\034\n\024fees_and_commissions\030\020"
    " \001(\001\022\023\n\013prev_margin\030\021 \001(\001\022\030\n\020imported_ne"
    "t_liq\030\022 \001(\001\0229\n\025imported_net_liq_date\030\023 \001"
    "(\0132\032.google.protobuf.Timestamp\022\035\n\025prev_i"
    "mported_net_liq\030\024 \001(\001\022>\n\032prev_imported_n"
    "et_liq_date\030\025 \001(\0132\032.google.protobuf.Time"
    "stamp\022\024\n\014filled_delta\030\026 \001(\001\022\025\n\rworking_d"
    "elta\030\027 \001(\001\022/\n\013margin_time\030\030 \001(\0132\032.google"
    ".protobuf.Timestamp\0221\n\ralerting_time\030\031 \001"
    "(\0132\032.google.protobuf.Timestamp\"\333\007\n\016Accou"
    "ntDetails\022\022\n\naccount_id\030\001 \001(\t\022\024\n\014account"
    "_name\030\002 \001(\t\022\017\n\007account\030\003 \001(\t\0222\n\007enabled\030"
    "\004 \001(\0162!.t4proto.v1.common.AccountEnabled"
    "\022\017\n\007deleted\030\005 \001(\010\022\025\n\rmax_clip_size\030\006 \001(\005"
    "\022\032\n\022pre_trade_disabled\030\007 \001(\010\022\031\n\021position"
    "_rollover\030\010 \001(\010\022\023\n\013pl_rollover\030\t \001(\010\022\017\n\007"
    "firm_id\030\n \001(\t\022\023\n\013min_balance\030\013 \001(\001\022\021\n\tma"
    "rgin_pc\030\014 \001(\005\022\022\n\nloss_limit\030\r \001(\001\022\025\n\rlos"
    "s_limit_pc\030\016 \001(\005\022\033\n\023overnight_margin_pc\030"
    "\017 \001(\005\022\025\n\rorder_routing\030\020 \001(\010\022\031\n\021active_t"
    "ime_start\030\021 \001(\t\022\030\n\020active_time_stop\030\022 \001("
    "\t\022\034\n\024warning_threshold_pl\030\023 \001(\005\022$\n\034warni"
    "ng_threshold_loss_limit\030\024 \001(\005\022 \n\030warning"
    "_threshold_margin\030\025 \001(\005\022\014\n\004firm\030\026 \001(\t\022,\n"
    "\004mode\030\027 \001(\0162\036.t4proto.v1.common.AccountM"
    "ode\022\034\n\024max_account_position\030\030 \001(\005\022\026\n\016day"
    "_loss_limit\030\031 \001(\001\022\024\n\014display_name\030\032 \001(\t\022"
    "\023\n\013wide_market\030\033 \001(\005\022\031\n\021use_pl_for_margi"
    "n\030\034 \001(\010\0229\n\013margin_type\030\035 \001(\0162$.t4proto.v"
    "1.common.AccountMarginType\022\024\n\014risk_detai"
    "ls\030\036 \001(\t\022\025\n\rprice_banding\030\037 \001(\005\022\031\n\021day_l"
    "oss_limit_pc\030  \001(\005\022\032\n\022options_settlement"
    "\030! \001(\010\022\022\n\ngroup_name\030\" \001(\t\022\036\n\026use_premiu"
    "m_for_margin\030# \001(\010\022(\n warning_threshold_"
    "min_net_equity\030$ \001(\001\"\246\003\n\026AccountSnapshot"
    "Message\022\?\n\020account_position\030\003 \001(\0132#.t4pr"
    "oto.v1.account.AccountPositionH\000\022;\n\016acco"
    "unt_update\030\004 \001(\0132!.t4proto.v1.account.Ac"
    "countUpdateH\000\022=\n\017account_details\030\005 \001(\0132\""
    ".t4proto.v1.account.AccountDetailsH\000\022\?\n\020"
    "account_currency\030\006 \001(\0132#.t4proto.v1.acco"
    "unt.AccountCurrencyH\000\022:\n\016market_details\030"
    "\007 \001(\0132 .t4proto.v1.market.MarketDetailsH"
    "\000\022G\n\022order_update_multi\030\010 \001(\0132).t4proto."
    "v1.orderrouting.OrderUpdateMultiH\000B\t\n\007pa"
    "yload\"\355\001\n\017AccountSnapshot\022\022\n\naccount_id\030"
    "\001 \001(\t\022\035\n\025last_update_requested\030\002 \001(\003\022\034\n\024"
    "last_update_supplied\030\003 \001(\003\0220\n\006status\030\004 \001"
    "(\0162 .t4proto.v1.common.AccountStatus\022\031\n\021"
    "due_to_connection\030\005 \001(\010\022<\n\010messages\030\006 \003("
    "\0132*.t4proto.v1.account.AccountSnapshotMe"
    "ssage\"\254\005\n\rAccountProfit\022\022\n\naccount_id\030\001 "
    "\001(\t\022/\n\013update_time\030\002 \001(\0132\032.google.protob"
    "uf.Timestamp\022\020\n\003upl\030\003 \001(\001H\000\210\001\001\022\026\n\tupl_tr"
    "ade\030\004 \001(\001H\001\210\001\001\022\020\n\003rpl\030\005 \001(\001H\002\210\001\001\022\024\n\007day_"
    "upl\030\006 \001(\001H\003\210\001\001\022\032\n\rday_upl_trade\030\007 \001(\001H\004\210"
    "\001\001\022\024\n\007day_rpl\030\010 \001(\001H\005\210\001\001\022\027\n\nwarning_pl\030\t"
    " \001(\005H\006\210\001\001\022\037\n\022warning_loss_limit\030\n \001(\005H\007\210"
    "\001\001\022\033\n\016warning_margin\030\013 \001(\005H\010\210\001\001\022!\n\024total"
    "_working_orders\030\014 \001(\005H\t\210\001\001\022!\n\024total_work"
    "ing_volume\030\r \001(\005H\n\210\001\001\022$\n\027is_alerting_liv"
    "e_margin\030\016 \001(\010H\013\210\001\001\022$\n\027is_alerting_full_"
    "margin\030\017 \001(\010H\014\210\001\001B\006\n\004_uplB\014\n\n_upl_tradeB"
    "\006\n\004_rplB\n\n\010_day_uplB\020\n\016_day_upl_tradeB\n\n"
    "\010_day_rplB\r\n\013_warning_plB\025\n\023_warning_los"
    "s_limitB\021\n\017_warning_marginB\027\n\025_total_wor"
    "king_ordersB\027\n\025_total_working_volumeB\032\n\030"
    "_is_alerting_live_marginB\032\n\030_is_alerting"
    "_full_margin\"\350\005\n\025AccountPositionProfit\022\022"
    "\n\naccount_id\030\001 \001(\t\022\023\n\013exchange_id\030\002 \001(\t\022"
    "\023\n\013contract_id\030\003 \001(\t\022\021\n\tmarket_id\030\004 \001(\t\022"
    "\017\n\007delayed\030\005 \001(\010\022/\n\013update_time\030\006 \001(\0132\032."
    "google.protobuf.Timestamp\022\022\n\nis_options\030"
    "\007 \001(\010\022\020\n\010has_data\030\010 \001(\010\022\022\n\nis_implied\030\t "
    "\001(\010\022\020\n\003net\030\n \001(\001H\000\210\001\001\022\020\n\003upl\030\013 \001(\001H\001\210\001\001\022"
    "\026\n\tupl_trade\030\014 \001(\001H\002\210\001\001\022\020\n\003rpl\030\r \001(\001H\003\210\001"
    "\001\022\024\n\007upl_usd\030\016 \001(\001H\004\210\001\001\022\032\n\rupl_trade_usd"
    "\030\017 \001(\001H\005\210\001\001\022\024\n\007rpl_usd\030\020 \001(\001H\006\210\001\001\022\024\n\007day"
    "_net\030\021 \001(\001H\007\210\001\001\022\024\n\007day_rpl\030\022 \001(\001H\010\210\001\001\022\030\n"
    "\013day_rpl_usd\030\023 \001(\001H\t\210\001\001\022\024\n\007day_upl\030\024 \001(\001"
    "H\n\210\001\001\022\032\n\rday_upl_trade\030\025 \001(\001H\013\210\001\001\022\030\n\013day"
    "_upl_usd\030\026 \001(\001H\014\210\001\001\022\036\n\021day_upl_trade_usd"
    "\030\027 \001(\001H\r\210\001\001B\006\n\004_netB\006\n\004_uplB\014\n\n_upl_trad"
    "eB\006\n\004_rplB\n\n\010_upl_usdB\020\n\016_upl_trade_usdB"
    "\n\n\010_rpl_usdB\n\n\010_day_netB\n\n\010_day_rplB\016\n\014_"
    "day_rpl_usdB\n\n\010_day_uplB\020\n\016_day_upl_trad"
    "eB\016\n\014_day_upl_usdB\024\n\022_day_upl_trade_usdb"
    "\006proto3"
};
static const ::_pbi::DescriptorTable* const descriptor_table_t4_2fv1_2faccount_2faccount_2eproto_deps[5] =
    {
        &::descriptor_table_google_2fprotobuf_2ftimestamp_2eproto,
        &::descriptor_table_t4_2fv1_2fcommon_2fenums_2eproto,
        &::descriptor_table_t4_2fv1_2fcommon_2fprice_2eproto,
        &::descriptor_table_t4_2fv1_2fmarket_2fmarket_2eproto,
        &::descriptor_table_t4_2fv1_2forderrouting_2forderrouting_2eproto,
};
static ::absl::once_flag descriptor_table_t4_2fv1_2faccount_2faccount_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_t4_2fv1_2faccount_2faccount_2eproto = {
    false,
    false,
    5767,
    descriptor_table_protodef_t4_2fv1_2faccount_2faccount_2eproto,
    "t4/v1/account/account.proto",
    &descriptor_table_t4_2fv1_2faccount_2faccount_2eproto_once,
    descriptor_table_t4_2fv1_2faccount_2faccount_2eproto_deps,
    5,
    10,
    schemas,
    file_default_instances,
    TableStruct_t4_2fv1_2faccount_2faccount_2eproto::offsets,
    file_level_metadata_t4_2fv1_2faccount_2faccount_2eproto,
    file_level_enum_descriptors_t4_2fv1_2faccount_2faccount_2eproto,
    file_level_service_descriptors_t4_2fv1_2faccount_2faccount_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_t4_2fv1_2faccount_2faccount_2eproto_getter() {
  return &descriptor_table_t4_2fv1_2faccount_2faccount_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_t4_2fv1_2faccount_2faccount_2eproto(&descriptor_table_t4_2fv1_2faccount_2faccount_2eproto);
namespace t4proto {
namespace v1 {
namespace account {
// ===================================================================

class AccountSubscribe::_Internal {
 public:
  using HasBits = decltype(std::declval<AccountSubscribe>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AccountSubscribe, _impl_._has_bits_);
  static void set_has_upl_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

AccountSubscribe::AccountSubscribe(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:t4proto.v1.account.AccountSubscribe)
}
AccountSubscribe::AccountSubscribe(const AccountSubscribe& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AccountSubscribe* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){from._impl_.account_id_}
    , decltype(_impl_.subscribe_) {}

    , decltype(_impl_.subscribe_all_accounts_) {}

    , decltype(_impl_.upl_mode_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.subscribe_, &from._impl_.subscribe_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.upl_mode_) -
    reinterpret_cast<char*>(&_impl_.subscribe_)) + sizeof(_impl_.upl_mode_));
  // @@protoc_insertion_point(copy_constructor:t4proto.v1.account.AccountSubscribe)
}

inline void AccountSubscribe::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){arena}
    , decltype(_impl_.subscribe_) { 0 }

    , decltype(_impl_.subscribe_all_accounts_) { false }

    , decltype(_impl_.upl_mode_) { 0 }

  };
}

AccountSubscribe::~AccountSubscribe() {
  // @@protoc_insertion_point(destructor:t4proto.v1.account.AccountSubscribe)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AccountSubscribe::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.account_id_.~RepeatedPtrField();
}

void AccountSubscribe::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AccountSubscribe::Clear() {
// @@protoc_insertion_point(message_clear_start:t4proto.v1.account.AccountSubscribe)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.account_id_.Clear();
  ::memset(&_impl_.subscribe_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.subscribe_all_accounts_) -
      reinterpret_cast<char*>(&_impl_.subscribe_)) + sizeof(_impl_.subscribe_all_accounts_));
  _impl_.upl_mode_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AccountSubscribe::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .t4proto.v1.common.AccountSubscribeType subscribe = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_subscribe(static_cast<::t4proto::v1::common::AccountSubscribeType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool subscribe_all_accounts = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.subscribe_all_accounts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string account_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_account_id();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "t4proto.v1.account.AccountSubscribe.account_id"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .t4proto.v1.common.UPLMode upl_mode = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_upl_mode(static_cast<::t4proto::v1::common::UPLMode>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AccountSubscribe::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:t4proto.v1.account.AccountSubscribe)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .t4proto.v1.common.AccountSubscribeType subscribe = 1;
  if (this->_internal_subscribe() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_subscribe(), target);
  }

  // bool subscribe_all_accounts = 2;
  if (this->_internal_subscribe_all_accounts() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_subscribe_all_accounts(), target);
  }

  // repeated string account_id = 3;
  for (int i = 0, n = this->_internal_account_id_size(); i < n; ++i) {
    const auto& s = this->_internal_account_id(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "t4proto.v1.account.AccountSubscribe.account_id");
    target = stream->WriteString(3, s, target);
  }

  // optional .t4proto.v1.common.UPLMode upl_mode = 4;
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_upl_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:t4proto.v1.account.AccountSubscribe)
  return target;
}

::size_t AccountSubscribe::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:t4proto.v1.account.AccountSubscribe)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string account_id = 3;
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.account_id_.size());
  for (int i = 0, n = _impl_.account_id_.size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.account_id_.Get(i));
  }

  // .t4proto.v1.common.AccountSubscribeType subscribe = 1;
  if (this->_internal_subscribe() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_subscribe());
  }

  // bool subscribe_all_accounts = 2;
  if (this->_internal_subscribe_all_accounts() != 0) {
    total_size += 2;
  }

  // optional .t4proto.v1.common.UPLMode upl_mode = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_upl_mode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AccountSubscribe::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AccountSubscribe::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AccountSubscribe::GetClassData() const { return &_class_data_; }


void AccountSubscribe::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AccountSubscribe*>(&to_msg);
  auto& from = static_cast<const AccountSubscribe&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:t4proto.v1.account.AccountSubscribe)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.account_id_.MergeFrom(from._impl_.account_id_);
  if (from._internal_subscribe() != 0) {
    _this->_internal_set_subscribe(from._internal_subscribe());
  }
  if (from._internal_subscribe_all_accounts() != 0) {
    _this->_internal_set_subscribe_all_accounts(from._internal_subscribe_all_accounts());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_upl_mode(from._internal_upl_mode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AccountSubscribe::CopyFrom(const AccountSubscribe& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:t4proto.v1.account.AccountSubscribe)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountSubscribe::IsInitialized() const {
  return true;
}

void AccountSubscribe::InternalSwap(AccountSubscribe* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.account_id_.InternalSwap(&other->_impl_.account_id_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AccountSubscribe, _impl_.upl_mode_)
      + sizeof(AccountSubscribe::_impl_.upl_mode_)
      - PROTOBUF_FIELD_OFFSET(AccountSubscribe, _impl_.subscribe_)>(
          reinterpret_cast<char*>(&_impl_.subscribe_),
          reinterpret_cast<char*>(&other->_impl_.subscribe_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AccountSubscribe::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_t4_2fv1_2faccount_2faccount_2eproto_getter, &descriptor_table_t4_2fv1_2faccount_2faccount_2eproto_once,
      file_level_metadata_t4_2fv1_2faccount_2faccount_2eproto[0]);
}
// ===================================================================

class AccountSubscribeResponse::_Internal {
 public:
};

AccountSubscribeResponse::AccountSubscribeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:t4proto.v1.account.AccountSubscribeResponse)
}
AccountSubscribeResponse::AccountSubscribeResponse(const AccountSubscribeResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AccountSubscribeResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.errors_){from._impl_.errors_}
    , decltype(_impl_.success_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.success_ = from._impl_.success_;
  // @@protoc_insertion_point(copy_constructor:t4proto.v1.account.AccountSubscribeResponse)
}

inline void AccountSubscribeResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.errors_){arena}
    , decltype(_impl_.success_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AccountSubscribeResponse::~AccountSubscribeResponse() {
  // @@protoc_insertion_point(destructor:t4proto.v1.account.AccountSubscribeResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AccountSubscribeResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.errors_.~RepeatedPtrField();
}

void AccountSubscribeResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AccountSubscribeResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:t4proto.v1.account.AccountSubscribeResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.errors_.Clear();
  _impl_.success_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AccountSubscribeResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool success = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string errors = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_errors();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "t4proto.v1.account.AccountSubscribeResponse.errors"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AccountSubscribeResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:t4proto.v1.account.AccountSubscribeResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool success = 1;
  if (this->_internal_success() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_success(), target);
  }

  // repeated string errors = 2;
  for (int i = 0, n = this->_internal_errors_size(); i < n; ++i) {
    const auto& s = this->_internal_errors(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "t4proto.v1.account.AccountSubscribeResponse.errors");
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:t4proto.v1.account.AccountSubscribeResponse)
  return target;
}

::size_t AccountSubscribeResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:t4proto.v1.account.AccountSubscribeResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string errors = 2;
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.errors_.size());
  for (int i = 0, n = _impl_.errors_.size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.errors_.Get(i));
  }

  // bool success = 1;
  if (this->_internal_success() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AccountSubscribeResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AccountSubscribeResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AccountSubscribeResponse::GetClassData() const { return &_class_data_; }


void AccountSubscribeResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AccountSubscribeResponse*>(&to_msg);
  auto& from = static_cast<const AccountSubscribeResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:t4proto.v1.account.AccountSubscribeResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.errors_.MergeFrom(from._impl_.errors_);
  if (from._internal_success() != 0) {
    _this->_internal_set_success(from._internal_success());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AccountSubscribeResponse::CopyFrom(const AccountSubscribeResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:t4proto.v1.account.AccountSubscribeResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountSubscribeResponse::IsInitialized() const {
  return true;
}

void AccountSubscribeResponse::InternalSwap(AccountSubscribeResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.errors_.InternalSwap(&other->_impl_.errors_);

  swap(_impl_.success_, other->_impl_.success_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AccountSubscribeResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_t4_2fv1_2faccount_2faccount_2eproto_getter, &descriptor_table_t4_2fv1_2faccount_2faccount_2eproto_once,
      file_level_metadata_t4_2fv1_2faccount_2faccount_2eproto[1]);
}
// ===================================================================

class AccountCurrency::_Internal {
 public:
};

AccountCurrency::AccountCurrency(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:t4proto.v1.account.AccountCurrency)
}
AccountCurrency::AccountCurrency(const AccountCurrency& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AccountCurrency* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.currency_) {}

    , decltype(_impl_.rate_) {}

    , decltype(_impl_.import_factor_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.currency_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.currency_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_currency().empty()) {
    _this->_impl_.currency_.Set(from._internal_currency(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.rate_, &from._impl_.rate_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.import_factor_) -
    reinterpret_cast<char*>(&_impl_.rate_)) + sizeof(_impl_.import_factor_));
  // @@protoc_insertion_point(copy_constructor:t4proto.v1.account.AccountCurrency)
}

inline void AccountCurrency::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.currency_) {}

    , decltype(_impl_.rate_) { 0 }

    , decltype(_impl_.import_factor_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.currency_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.currency_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AccountCurrency::~AccountCurrency() {
  // @@protoc_insertion_point(destructor:t4proto.v1.account.AccountCurrency)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AccountCurrency::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.currency_.Destroy();
}

void AccountCurrency::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AccountCurrency::Clear() {
// @@protoc_insertion_point(message_clear_start:t4proto.v1.account.AccountCurrency)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.currency_.ClearToEmpty();
  ::memset(&_impl_.rate_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.import_factor_) -
      reinterpret_cast<char*>(&_impl_.rate_)) + sizeof(_impl_.import_factor_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AccountCurrency::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string currency = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_currency();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "t4proto.v1.account.AccountCurrency.currency"));
        } else {
          goto handle_unusual;
        }
        continue;
      // double rate = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _impl_.rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // double import_factor = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 25)) {
          _impl_.import_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AccountCurrency::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:t4proto.v1.account.AccountCurrency)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string currency = 1;
  if (!this->_internal_currency().empty()) {
    const std::string& _s = this->_internal_currency();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "t4proto.v1.account.AccountCurrency.currency");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // double rate = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_rate = this->_internal_rate();
  ::uint64_t raw_rate;
  memcpy(&raw_rate, &tmp_rate, sizeof(tmp_rate));
  if (raw_rate != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_rate(), target);
  }

  // double import_factor = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_import_factor = this->_internal_import_factor();
  ::uint64_t raw_import_factor;
  memcpy(&raw_import_factor, &tmp_import_factor, sizeof(tmp_import_factor));
  if (raw_import_factor != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_import_factor(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:t4proto.v1.account.AccountCurrency)
  return target;
}

::size_t AccountCurrency::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:t4proto.v1.account.AccountCurrency)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string currency = 1;
  if (!this->_internal_currency().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_currency());
  }

  // double rate = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_rate = this->_internal_rate();
  ::uint64_t raw_rate;
  memcpy(&raw_rate, &tmp_rate, sizeof(tmp_rate));
  if (raw_rate != 0) {
    total_size += 9;
  }

  // double import_factor = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_import_factor = this->_internal_import_factor();
  ::uint64_t raw_import_factor;
  memcpy(&raw_import_factor, &tmp_import_factor, sizeof(tmp_import_factor));
  if (raw_import_factor != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AccountCurrency::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AccountCurrency::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AccountCurrency::GetClassData() const { return &_class_data_; }


void AccountCurrency::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AccountCurrency*>(&to_msg);
  auto& from = static_cast<const AccountCurrency&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:t4proto.v1.account.AccountCurrency)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_currency().empty()) {
    _this->_internal_set_currency(from._internal_currency());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_rate = from._internal_rate();
  ::uint64_t raw_rate;
  memcpy(&raw_rate, &tmp_rate, sizeof(tmp_rate));
  if (raw_rate != 0) {
    _this->_internal_set_rate(from._internal_rate());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_import_factor = from._internal_import_factor();
  ::uint64_t raw_import_factor;
  memcpy(&raw_import_factor, &tmp_import_factor, sizeof(tmp_import_factor));
  if (raw_import_factor != 0) {
    _this->_internal_set_import_factor(from._internal_import_factor());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AccountCurrency::CopyFrom(const AccountCurrency& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:t4proto.v1.account.AccountCurrency)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountCurrency::IsInitialized() const {
  return true;
}

void AccountCurrency::InternalSwap(AccountCurrency* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.currency_, lhs_arena,
                                       &other->_impl_.currency_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AccountCurrency, _impl_.import_factor_)
      + sizeof(AccountCurrency::_impl_.import_factor_)
      - PROTOBUF_FIELD_OFFSET(AccountCurrency, _impl_.rate_)>(
          reinterpret_cast<char*>(&_impl_.rate_),
          reinterpret_cast<char*>(&other->_impl_.rate_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AccountCurrency::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_t4_2fv1_2faccount_2faccount_2eproto_getter, &descriptor_table_t4_2fv1_2faccount_2faccount_2eproto_once,
      file_level_metadata_t4_2fv1_2faccount_2faccount_2eproto[2]);
}
// ===================================================================

class AccountPosition::_Internal {
 public:
  using HasBits = decltype(std::declval<AccountPosition>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AccountPosition, _impl_._has_bits_);
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& trade_date(const AccountPosition* msg);
  static const ::t4proto::v1::common::Price& average_open_price(const AccountPosition* msg);
  static void set_has_average_open_price(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::t4proto::v1::common::Price& total_open_price(const AccountPosition* msg);
  static void set_has_total_open_price(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::t4proto::v1::common::Price& total_buy_fill_price(const AccountPosition* msg);
  static void set_has_total_buy_fill_price(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::t4proto::v1::common::Price& total_sell_fill_price(const AccountPosition* msg);
  static void set_has_total_sell_fill_price(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::t4proto::v1::common::Price& day_total_buy_fill_price(const AccountPosition* msg);
  static void set_has_day_total_buy_fill_price(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::t4proto::v1::common::Price& day_total_sell_fill_price(const AccountPosition* msg);
  static void set_has_day_total_sell_fill_price(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::t4proto::v1::common::Price& total_overnight_price(const AccountPosition* msg);
  static void set_has_total_overnight_price(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& margin_time(const AccountPosition* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& alerting_time(const AccountPosition* msg);
};

const ::PROTOBUF_NAMESPACE_ID::Timestamp&
AccountPosition::_Internal::trade_date(const AccountPosition* msg) {
  return *msg->_impl_.trade_date_;
}
const ::t4proto::v1::common::Price&
AccountPosition::_Internal::average_open_price(const AccountPosition* msg) {
  return *msg->_impl_.average_open_price_;
}
const ::t4proto::v1::common::Price&
AccountPosition::_Internal::total_open_price(const AccountPosition* msg) {
  return *msg->_impl_.total_open_price_;
}
const ::t4proto::v1::common::Price&
AccountPosition::_Internal::total_buy_fill_price(const AccountPosition* msg) {
  return *msg->_impl_.total_buy_fill_price_;
}
const ::t4proto::v1::common::Price&
AccountPosition::_Internal::total_sell_fill_price(const AccountPosition* msg) {
  return *msg->_impl_.total_sell_fill_price_;
}
const ::t4proto::v1::common::Price&
AccountPosition::_Internal::day_total_buy_fill_price(const AccountPosition* msg) {
  return *msg->_impl_.day_total_buy_fill_price_;
}
const ::t4proto::v1::common::Price&
AccountPosition::_Internal::day_total_sell_fill_price(const AccountPosition* msg) {
  return *msg->_impl_.day_total_sell_fill_price_;
}
const ::t4proto::v1::common::Price&
AccountPosition::_Internal::total_overnight_price(const AccountPosition* msg) {
  return *msg->_impl_.total_overnight_price_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
AccountPosition::_Internal::margin_time(const AccountPosition* msg) {
  return *msg->_impl_.margin_time_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
AccountPosition::_Internal::alerting_time(const AccountPosition* msg) {
  return *msg->_impl_.alerting_time_;
}
void AccountPosition::clear_trade_date() {
  if (GetArenaForAllocation() == nullptr && _impl_.trade_date_ != nullptr) {
    delete _impl_.trade_date_;
  }
  _impl_.trade_date_ = nullptr;
}
void AccountPosition::clear_average_open_price() {
  if (_impl_.average_open_price_ != nullptr) _impl_.average_open_price_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void AccountPosition::clear_total_open_price() {
  if (_impl_.total_open_price_ != nullptr) _impl_.total_open_price_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void AccountPosition::clear_total_buy_fill_price() {
  if (_impl_.total_buy_fill_price_ != nullptr) _impl_.total_buy_fill_price_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void AccountPosition::clear_total_sell_fill_price() {
  if (_impl_.total_sell_fill_price_ != nullptr) _impl_.total_sell_fill_price_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void AccountPosition::clear_day_total_buy_fill_price() {
  if (_impl_.day_total_buy_fill_price_ != nullptr) _impl_.day_total_buy_fill_price_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void AccountPosition::clear_day_total_sell_fill_price() {
  if (_impl_.day_total_sell_fill_price_ != nullptr) _impl_.day_total_sell_fill_price_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
void AccountPosition::clear_total_overnight_price() {
  if (_impl_.total_overnight_price_ != nullptr) _impl_.total_overnight_price_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
void AccountPosition::clear_margin_time() {
  if (GetArenaForAllocation() == nullptr && _impl_.margin_time_ != nullptr) {
    delete _impl_.margin_time_;
  }
  _impl_.margin_time_ = nullptr;
}
void AccountPosition::clear_alerting_time() {
  if (GetArenaForAllocation() == nullptr && _impl_.alerting_time_ != nullptr) {
    delete _impl_.alerting_time_;
  }
  _impl_.alerting_time_ = nullptr;
}
AccountPosition::AccountPosition(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:t4proto.v1.account.AccountPosition)
}
AccountPosition::AccountPosition(const AccountPosition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AccountPosition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_) {}

    , decltype(_impl_.exchange_id_) {}

    , decltype(_impl_.contract_id_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.trade_date_){nullptr}
    , decltype(_impl_.average_open_price_){nullptr}
    , decltype(_impl_.total_open_price_){nullptr}
    , decltype(_impl_.total_buy_fill_price_){nullptr}
    , decltype(_impl_.total_sell_fill_price_){nullptr}
    , decltype(_impl_.day_total_buy_fill_price_){nullptr}
    , decltype(_impl_.day_total_sell_fill_price_){nullptr}
    , decltype(_impl_.total_overnight_price_){nullptr}
    , decltype(_impl_.margin_time_){nullptr}
    , decltype(_impl_.alerting_time_){nullptr}
    , decltype(_impl_.buys_) {}

    , decltype(_impl_.sells_) {}

    , decltype(_impl_.working_buys_) {}

    , decltype(_impl_.working_sells_) {}

    , decltype(_impl_.rpl_) {}

    , decltype(_impl_.overnight_upl_) {}

    , decltype(_impl_.margin_) {}

    , decltype(_impl_.mp_) {}

    , decltype(_impl_.currency_rate_) {}

    , decltype(_impl_.overnight_position_) {}

    , decltype(_impl_.total_open_volume_) {}

    , decltype(_impl_.premium_) {}

    , decltype(_impl_.fees_and_commissions_) {}

    , decltype(_impl_.long_mp_) {}

    , decltype(_impl_.short_mp_) {}

    , decltype(_impl_.prev_margin_) {}

    , decltype(_impl_.prev_rpl_) {}

    , decltype(_impl_.prev_position_) {}

    , decltype(_impl_.day_buys_) {}

    , decltype(_impl_.prev_upl_) {}

    , decltype(_impl_.day_sells_) {}

    , decltype(_impl_.risk_status_) {}

    , decltype(_impl_.alerting_margin_) {}

    , decltype(_impl_.day_margin_) {}

    , decltype(_impl_.full_margin_) {}

    , decltype(_impl_.pre_trade_margin_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.account_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_account_id().empty()) {
    _this->_impl_.account_id_.Set(from._internal_account_id(), _this->GetArenaForAllocation());
  }
  _impl_.exchange_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.exchange_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_exchange_id().empty()) {
    _this->_impl_.exchange_id_.Set(from._internal_exchange_id(), _this->GetArenaForAllocation());
  }
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), _this->GetArenaForAllocation());
  }
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  if (from._internal_has_trade_date()) {
    _this->_impl_.trade_date_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.trade_date_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.average_open_price_ = new ::t4proto::v1::common::Price(*from._impl_.average_open_price_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.total_open_price_ = new ::t4proto::v1::common::Price(*from._impl_.total_open_price_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.total_buy_fill_price_ = new ::t4proto::v1::common::Price(*from._impl_.total_buy_fill_price_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.total_sell_fill_price_ = new ::t4proto::v1::common::Price(*from._impl_.total_sell_fill_price_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000010u) != 0) {
    _this->_impl_.day_total_buy_fill_price_ = new ::t4proto::v1::common::Price(*from._impl_.day_total_buy_fill_price_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000020u) != 0) {
    _this->_impl_.day_total_sell_fill_price_ = new ::t4proto::v1::common::Price(*from._impl_.day_total_sell_fill_price_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000040u) != 0) {
    _this->_impl_.total_overnight_price_ = new ::t4proto::v1::common::Price(*from._impl_.total_overnight_price_);
  }
  if (from._internal_has_margin_time()) {
    _this->_impl_.margin_time_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.margin_time_);
  }
  if (from._internal_has_alerting_time()) {
    _this->_impl_.alerting_time_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.alerting_time_);
  }
  ::memcpy(&_impl_.buys_, &from._impl_.buys_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.pre_trade_margin_) -
    reinterpret_cast<char*>(&_impl_.buys_)) + sizeof(_impl_.pre_trade_margin_));
  // @@protoc_insertion_point(copy_constructor:t4proto.v1.account.AccountPosition)
}

inline void AccountPosition::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_) {}

    , decltype(_impl_.exchange_id_) {}

    , decltype(_impl_.contract_id_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.trade_date_){nullptr}
    , decltype(_impl_.average_open_price_){nullptr}
    , decltype(_impl_.total_open_price_){nullptr}
    , decltype(_impl_.total_buy_fill_price_){nullptr}
    , decltype(_impl_.total_sell_fill_price_){nullptr}
    , decltype(_impl_.day_total_buy_fill_price_){nullptr}
    , decltype(_impl_.day_total_sell_fill_price_){nullptr}
    , decltype(_impl_.total_overnight_price_){nullptr}
    , decltype(_impl_.margin_time_){nullptr}
    , decltype(_impl_.alerting_time_){nullptr}
    , decltype(_impl_.buys_) { 0 }

    , decltype(_impl_.sells_) { 0 }

    , decltype(_impl_.working_buys_) { 0 }

    , decltype(_impl_.working_sells_) { 0 }

    , decltype(_impl_.rpl_) { 0 }

    , decltype(_impl_.overnight_upl_) { 0 }

    , decltype(_impl_.margin_) { 0 }

    , decltype(_impl_.mp_) { 0 }

    , decltype(_impl_.currency_rate_) { 0 }

    , decltype(_impl_.overnight_position_) { 0 }

    , decltype(_impl_.total_open_volume_) { 0 }

    , decltype(_impl_.premium_) { 0 }

    , decltype(_impl_.fees_and_commissions_) { 0 }

    , decltype(_impl_.long_mp_) { 0 }

    , decltype(_impl_.short_mp_) { 0 }

    , decltype(_impl_.prev_margin_) { 0 }

    , decltype(_impl_.prev_rpl_) { 0 }

    , decltype(_impl_.prev_position_) { 0 }

    , decltype(_impl_.day_buys_) { 0 }

    , decltype(_impl_.prev_upl_) { 0 }

    , decltype(_impl_.day_sells_) { 0 }

    , decltype(_impl_.risk_status_) { 0 }

    , decltype(_impl_.alerting_margin_) { 0 }

    , decltype(_impl_.day_margin_) { 0 }

    , decltype(_impl_.full_margin_) { 0 }

    , decltype(_impl_.pre_trade_margin_) { 0 }

  };
  _impl_.account_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.exchange_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.exchange_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AccountPosition::~AccountPosition() {
  // @@protoc_insertion_point(destructor:t4proto.v1.account.AccountPosition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AccountPosition::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.account_id_.Destroy();
  _impl_.exchange_id_.Destroy();
  _impl_.contract_id_.Destroy();
  _impl_.market_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.trade_date_;
  if (this != internal_default_instance()) delete _impl_.average_open_price_;
  if (this != internal_default_instance()) delete _impl_.total_open_price_;
  if (this != internal_default_instance()) delete _impl_.total_buy_fill_price_;
  if (this != internal_default_instance()) delete _impl_.total_sell_fill_price_;
  if (this != internal_default_instance()) delete _impl_.day_total_buy_fill_price_;
  if (this != internal_default_instance()) delete _impl_.day_total_sell_fill_price_;
  if (this != internal_default_instance()) delete _impl_.total_overnight_price_;
  if (this != internal_default_instance()) delete _impl_.margin_time_;
  if (this != internal_default_instance()) delete _impl_.alerting_time_;
}

void AccountPosition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AccountPosition::Clear() {
// @@protoc_insertion_point(message_clear_start:t4proto.v1.account.AccountPosition)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.account_id_.ClearToEmpty();
  _impl_.exchange_id_.ClearToEmpty();
  _impl_.contract_id_.ClearToEmpty();
  _impl_.market_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.trade_date_ != nullptr) {
    delete _impl_.trade_date_;
  }
  _impl_.trade_date_ = nullptr;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.average_open_price_ != nullptr);
      _impl_.average_open_price_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.total_open_price_ != nullptr);
      _impl_.total_open_price_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.total_buy_fill_price_ != nullptr);
      _impl_.total_buy_fill_price_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.total_sell_fill_price_ != nullptr);
      _impl_.total_sell_fill_price_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.day_total_buy_fill_price_ != nullptr);
      _impl_.day_total_buy_fill_price_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      ABSL_DCHECK(_impl_.day_total_sell_fill_price_ != nullptr);
      _impl_.day_total_sell_fill_price_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      ABSL_DCHECK(_impl_.total_overnight_price_ != nullptr);
      _impl_.total_overnight_price_->Clear();
    }
  }
  if (GetArenaForAllocation() == nullptr && _impl_.margin_time_ != nullptr) {
    delete _impl_.margin_time_;
  }
  _impl_.margin_time_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.alerting_time_ != nullptr) {
    delete _impl_.alerting_time_;
  }
  _impl_.alerting_time_ = nullptr;
  ::memset(&_impl_.buys_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.pre_trade_margin_) -
      reinterpret_cast<char*>(&_impl_.buys_)) + sizeof(_impl_.pre_trade_margin_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AccountPosition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_account_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "t4proto.v1.account.AccountPosition.account_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string exchange_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_exchange_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "t4proto.v1.account.AccountPosition.exchange_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string contract_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "t4proto.v1.account.AccountPosition.contract_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string market_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "t4proto.v1.account.AccountPosition.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 buys = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.buys_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 sells = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.sells_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 working_buys = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.working_buys_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 working_sells = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.working_sells_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // double rpl = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 73)) {
          _impl_.rpl_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // double overnight_upl = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 81)) {
          _impl_.overnight_upl_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // double margin = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 89)) {
          _impl_.margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // double mp = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 97)) {
          _impl_.mp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 overnight_position = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 104)) {
          _impl_.overnight_position_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // double currency_rate = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 113)) {
          _impl_.currency_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.Timestamp trade_date = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_trade_date(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // double premium = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 129)) {
          _impl_.premium_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 total_open_volume = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 136)) {
          _impl_.total_open_volume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // double fees_and_commissions = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 145)) {
          _impl_.fees_and_commissions_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // double long_mp = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 153)) {
          _impl_.long_mp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // double short_mp = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 161)) {
          _impl_.short_mp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 prev_position = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 168)) {
          _impl_.prev_position_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // double prev_margin = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 177)) {
          _impl_.prev_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // double prev_rpl = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 185)) {
          _impl_.prev_rpl_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // double prev_upl = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 193)) {
          _impl_.prev_upl_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 day_buys = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 200)) {
          _impl_.day_buys_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 day_sells = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 208)) {
          _impl_.day_sells_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .t4proto.v1.common.Price average_open_price = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_average_open_price(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .t4proto.v1.common.Price total_open_price = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_total_open_price(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .t4proto.v1.common.Price total_buy_fill_price = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_total_buy_fill_price(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .t4proto.v1.common.Price total_sell_fill_price = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_total_sell_fill_price(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .t4proto.v1.common.Price day_total_buy_fill_price = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_day_total_buy_fill_price(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .t4proto.v1.common.Price day_total_sell_fill_price = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_day_total_sell_fill_price(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .t4proto.v1.common.Price total_overnight_price = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_total_overnight_price(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .t4proto.v1.common.ContractRiskStatus risk_status = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_risk_status(static_cast<::t4proto::v1::common::ContractRiskStatus>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.Timestamp margin_time = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_margin_time(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // double alerting_margin = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 33)) {
          _impl_.alerting_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.Timestamp alerting_time = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_alerting_time(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // double day_margin = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 49)) {
          _impl_.day_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // double full_margin = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 57)) {
          _impl_.full_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // double pre_trade_margin = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 65)) {
          _impl_.pre_trade_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AccountPosition::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:t4proto.v1.account.AccountPosition)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string account_id = 1;
  if (!this->_internal_account_id().empty()) {
    const std::string& _s = this->_internal_account_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "t4proto.v1.account.AccountPosition.account_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string exchange_id = 2;
  if (!this->_internal_exchange_id().empty()) {
    const std::string& _s = this->_internal_exchange_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "t4proto.v1.account.AccountPosition.exchange_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string contract_id = 3;
  if (!this->_internal_contract_id().empty()) {
    const std::string& _s = this->_internal_contract_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "t4proto.v1.account.AccountPosition.contract_id");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string market_id = 4;
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "t4proto.v1.account.AccountPosition.market_id");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // int32 buys = 5;
  if (this->_internal_buys() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_buys(), target);
  }

  // int32 sells = 6;
  if (this->_internal_sells() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        6, this->_internal_sells(), target);
  }

  // int32 working_buys = 7;
  if (this->_internal_working_buys() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        7, this->_internal_working_buys(), target);
  }

  // int32 working_sells = 8;
  if (this->_internal_working_sells() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        8, this->_internal_working_sells(), target);
  }

  // double rpl = 9;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_rpl = this->_internal_rpl();
  ::uint64_t raw_rpl;
  memcpy(&raw_rpl, &tmp_rpl, sizeof(tmp_rpl));
  if (raw_rpl != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        9, this->_internal_rpl(), target);
  }

  // double overnight_upl = 10;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_overnight_upl = this->_internal_overnight_upl();
  ::uint64_t raw_overnight_upl;
  memcpy(&raw_overnight_upl, &tmp_overnight_upl, sizeof(tmp_overnight_upl));
  if (raw_overnight_upl != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        10, this->_internal_overnight_upl(), target);
  }

  // double margin = 11;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_margin = this->_internal_margin();
  ::uint64_t raw_margin;
  memcpy(&raw_margin, &tmp_margin, sizeof(tmp_margin));
  if (raw_margin != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        11, this->_internal_margin(), target);
  }

  // double mp = 12;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_mp = this->_internal_mp();
  ::uint64_t raw_mp;
  memcpy(&raw_mp, &tmp_mp, sizeof(tmp_mp));
  if (raw_mp != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        12, this->_internal_mp(), target);
  }

  // int32 overnight_position = 13;
  if (this->_internal_overnight_position() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        13, this->_internal_overnight_position(), target);
  }

  // double currency_rate = 14;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_currency_rate = this->_internal_currency_rate();
  ::uint64_t raw_currency_rate;
  memcpy(&raw_currency_rate, &tmp_currency_rate, sizeof(tmp_currency_rate));
  if (raw_currency_rate != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        14, this->_internal_currency_rate(), target);
  }

  // .google.protobuf.Timestamp trade_date = 15;
  if (this->_internal_has_trade_date()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::trade_date(this),
        _Internal::trade_date(this).GetCachedSize(), target, stream);
  }

  // double premium = 16;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_premium = this->_internal_premium();
  ::uint64_t raw_premium;
  memcpy(&raw_premium, &tmp_premium, sizeof(tmp_premium));
  if (raw_premium != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        16, this->_internal_premium(), target);
  }

  // int32 total_open_volume = 17;
  if (this->_internal_total_open_volume() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        17, this->_internal_total_open_volume(), target);
  }

  // double fees_and_commissions = 18;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_fees_and_commissions = this->_internal_fees_and_commissions();
  ::uint64_t raw_fees_and_commissions;
  memcpy(&raw_fees_and_commissions, &tmp_fees_and_commissions, sizeof(tmp_fees_and_commissions));
  if (raw_fees_and_commissions != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        18, this->_internal_fees_and_commissions(), target);
  }

  // double long_mp = 19;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_long_mp = this->_internal_long_mp();
  ::uint64_t raw_long_mp;
  memcpy(&raw_long_mp, &tmp_long_mp, sizeof(tmp_long_mp));
  if (raw_long_mp != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        19, this->_internal_long_mp(), target);
  }

  // double short_mp = 20;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_short_mp = this->_internal_short_mp();
  ::uint64_t raw_short_mp;
  memcpy(&raw_short_mp, &tmp_short_mp, sizeof(tmp_short_mp));
  if (raw_short_mp != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        20, this->_internal_short_mp(), target);
  }

  // int32 prev_position = 21;
  if (this->_internal_prev_position() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        21, this->_internal_prev_position(), target);
  }

  // double prev_margin = 22;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_prev_margin = this->_internal_prev_margin();
  ::uint64_t raw_prev_margin;
  memcpy(&raw_prev_margin, &tmp_prev_margin, sizeof(tmp_prev_margin));
  if (raw_prev_margin != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        22, this->_internal_prev_margin(), target);
  }

  // double prev_rpl = 23;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_prev_rpl = this->_internal_prev_rpl();
  ::uint64_t raw_prev_rpl;
  memcpy(&raw_prev_rpl, &tmp_prev_rpl, sizeof(tmp_prev_rpl));
  if (raw_prev_rpl != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        23, this->_internal_prev_rpl(), target);
  }

  // double prev_upl = 24;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_prev_upl = this->_internal_prev_upl();
  ::uint64_t raw_prev_upl;
  memcpy(&raw_prev_upl, &tmp_prev_upl, sizeof(tmp_prev_upl));
  if (raw_prev_upl != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        24, this->_internal_prev_upl(), target);
  }

  // int32 day_buys = 25;
  if (this->_internal_day_buys() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        25, this->_internal_day_buys(), target);
  }

  // int32 day_sells = 26;
  if (this->_internal_day_sells() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        26, this->_internal_day_sells(), target);
  }

  // optional .t4proto.v1.common.Price average_open_price = 27;
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(27, _Internal::average_open_price(this),
        _Internal::average_open_price(this).GetCachedSize(), target, stream);
  }

  // optional .t4proto.v1.common.Price total_open_price = 28;
  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(28, _Internal::total_open_price(this),
        _Internal::total_open_price(this).GetCachedSize(), target, stream);
  }

  // optional .t4proto.v1.common.Price total_buy_fill_price = 29;
  if ((_impl_._has_bits_[0] & 0x00000004u) != 0) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(29, _Internal::total_buy_fill_price(this),
        _Internal::total_buy_fill_price(this).GetCachedSize(), target, stream);
  }

  // optional .t4proto.v1.common.Price total_sell_fill_price = 30;
  if ((_impl_._has_bits_[0] & 0x00000008u) != 0) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(30, _Internal::total_sell_fill_price(this),
        _Internal::total_sell_fill_price(this).GetCachedSize(), target, stream);
  }

  // optional .t4proto.v1.common.Price day_total_buy_fill_price = 31;
  if ((_impl_._has_bits_[0] & 0x00000010u) != 0) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(31, _Internal::day_total_buy_fill_price(this),
        _Internal::day_total_buy_fill_price(this).GetCachedSize(), target, stream);
  }

  // optional .t4proto.v1.common.Price day_total_sell_fill_price = 32;
  if ((_impl_._has_bits_[0] & 0x00000020u) != 0) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(32, _Internal::day_total_sell_fill_price(this),
        _Internal::day_total_sell_fill_price(this).GetCachedSize(), target, stream);
  }

  // optional .t4proto.v1.common.Price total_overnight_price = 33;
  if ((_impl_._has_bits_[0] & 0x00000040u) != 0) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(33, _Internal::total_overnight_price(this),
        _Internal::total_overnight_price(this).GetCachedSize(), target, stream);
  }

  // .t4proto.v1.common.ContractRiskStatus risk_status = 34;
  if (this->_internal_risk_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        34, this->_internal_risk_status(), target);
  }

  // .google.protobuf.Timestamp margin_time = 35;
  if (this->_internal_has_margin_time()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(35, _Internal::margin_time(this),
        _Internal::margin_time(this).GetCachedSize(), target, stream);
  }

  // double alerting_margin = 36;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_alerting_margin = this->_internal_alerting_margin();
  ::uint64_t raw_alerting_margin;
  memcpy(&raw_alerting_margin, &tmp_alerting_margin, sizeof(tmp_alerting_margin));
  if (raw_alerting_margin != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        36, this->_internal_alerting_margin(), target);
  }

  // .google.protobuf.Timestamp alerting_time = 37;
  if (this->_internal_has_alerting_time()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(37, _Internal::alerting_time(this),
        _Internal::alerting_time(this).GetCachedSize(), target, stream);
  }

  // double day_margin = 38;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_day_margin = this->_internal_day_margin();
  ::uint64_t raw_day_margin;
  memcpy(&raw_day_margin, &tmp_day_margin, sizeof(tmp_day_margin));
  if (raw_day_margin != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        38, this->_internal_day_margin(), target);
  }

  // double full_margin = 39;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_full_margin = this->_internal_full_margin();
  ::uint64_t raw_full_margin;
  memcpy(&raw_full_margin, &tmp_full_margin, sizeof(tmp_full_margin));
  if (raw_full_margin != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        39, this->_internal_full_margin(), target);
  }

  // double pre_trade_margin = 40;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_pre_trade_margin = this->_internal_pre_trade_margin();
  ::uint64_t raw_pre_trade_margin;
  memcpy(&raw_pre_trade_margin, &tmp_pre_trade_margin, sizeof(tmp_pre_trade_margin));
  if (raw_pre_trade_margin != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        40, this->_internal_pre_trade_margin(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:t4proto.v1.account.AccountPosition)
  return target;
}

::size_t AccountPosition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:t4proto.v1.account.AccountPosition)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string account_id = 1;
  if (!this->_internal_account_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_account_id());
  }

  // string exchange_id = 2;
  if (!this->_internal_exchange_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_exchange_id());
  }

  // string contract_id = 3;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_contract_id());
  }

  // string market_id = 4;
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // .google.protobuf.Timestamp trade_date = 15;
  if (this->_internal_has_trade_date()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.trade_date_);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .t4proto.v1.common.Price average_open_price = 27;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.average_open_price_);
    }

    // optional .t4proto.v1.common.Price total_open_price = 28;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.total_open_price_);
    }

    // optional .t4proto.v1.common.Price total_buy_fill_price = 29;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.total_buy_fill_price_);
    }

    // optional .t4proto.v1.common.Price total_sell_fill_price = 30;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.total_sell_fill_price_);
    }

    // optional .t4proto.v1.common.Price day_total_buy_fill_price = 31;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.day_total_buy_fill_price_);
    }

    // optional .t4proto.v1.common.Price day_total_sell_fill_price = 32;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.day_total_sell_fill_price_);
    }

    // optional .t4proto.v1.common.Price total_overnight_price = 33;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.total_overnight_price_);
    }

  }
  // .google.protobuf.Timestamp margin_time = 35;
  if (this->_internal_has_margin_time()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.margin_time_);
  }

  // .google.protobuf.Timestamp alerting_time = 37;
  if (this->_internal_has_alerting_time()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.alerting_time_);
  }

  // int32 buys = 5;
  if (this->_internal_buys() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_buys());
  }

  // int32 sells = 6;
  if (this->_internal_sells() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_sells());
  }

  // int32 working_buys = 7;
  if (this->_internal_working_buys() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_working_buys());
  }

  // int32 working_sells = 8;
  if (this->_internal_working_sells() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_working_sells());
  }

  // double rpl = 9;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_rpl = this->_internal_rpl();
  ::uint64_t raw_rpl;
  memcpy(&raw_rpl, &tmp_rpl, sizeof(tmp_rpl));
  if (raw_rpl != 0) {
    total_size += 9;
  }

  // double overnight_upl = 10;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_overnight_upl = this->_internal_overnight_upl();
  ::uint64_t raw_overnight_upl;
  memcpy(&raw_overnight_upl, &tmp_overnight_upl, sizeof(tmp_overnight_upl));
  if (raw_overnight_upl != 0) {
    total_size += 9;
  }

  // double margin = 11;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_margin = this->_internal_margin();
  ::uint64_t raw_margin;
  memcpy(&raw_margin, &tmp_margin, sizeof(tmp_margin));
  if (raw_margin != 0) {
    total_size += 9;
  }

  // double mp = 12;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_mp = this->_internal_mp();
  ::uint64_t raw_mp;
  memcpy(&raw_mp, &tmp_mp, sizeof(tmp_mp));
  if (raw_mp != 0) {
    total_size += 9;
  }

  // double currency_rate = 14;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_currency_rate = this->_internal_currency_rate();
  ::uint64_t raw_currency_rate;
  memcpy(&raw_currency_rate, &tmp_currency_rate, sizeof(tmp_currency_rate));
  if (raw_currency_rate != 0) {
    total_size += 9;
  }

  // int32 overnight_position = 13;
  if (this->_internal_overnight_position() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_overnight_position());
  }

  // int32 total_open_volume = 17;
  if (this->_internal_total_open_volume() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_total_open_volume());
  }

  // double premium = 16;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_premium = this->_internal_premium();
  ::uint64_t raw_premium;
  memcpy(&raw_premium, &tmp_premium, sizeof(tmp_premium));
  if (raw_premium != 0) {
    total_size += 10;
  }

  // double fees_and_commissions = 18;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_fees_and_commissions = this->_internal_fees_and_commissions();
  ::uint64_t raw_fees_and_commissions;
  memcpy(&raw_fees_and_commissions, &tmp_fees_and_commissions, sizeof(tmp_fees_and_commissions));
  if (raw_fees_and_commissions != 0) {
    total_size += 10;
  }

  // double long_mp = 19;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_long_mp = this->_internal_long_mp();
  ::uint64_t raw_long_mp;
  memcpy(&raw_long_mp, &tmp_long_mp, sizeof(tmp_long_mp));
  if (raw_long_mp != 0) {
    total_size += 10;
  }

  // double short_mp = 20;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_short_mp = this->_internal_short_mp();
  ::uint64_t raw_short_mp;
  memcpy(&raw_short_mp, &tmp_short_mp, sizeof(tmp_short_mp));
  if (raw_short_mp != 0) {
    total_size += 10;
  }

  // double prev_margin = 22;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_prev_margin = this->_internal_prev_margin();
  ::uint64_t raw_prev_margin;
  memcpy(&raw_prev_margin, &tmp_prev_margin, sizeof(tmp_prev_margin));
  if (raw_prev_margin != 0) {
    total_size += 10;
  }

  // double prev_rpl = 23;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_prev_rpl = this->_internal_prev_rpl();
  ::uint64_t raw_prev_rpl;
  memcpy(&raw_prev_rpl, &tmp_prev_rpl, sizeof(tmp_prev_rpl));
  if (raw_prev_rpl != 0) {
    total_size += 10;
  }

  // int32 prev_position = 21;
  if (this->_internal_prev_position() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_prev_position());
  }

  // int32 day_buys = 25;
  if (this->_internal_day_buys() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_day_buys());
  }

  // double prev_upl = 24;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_prev_upl = this->_internal_prev_upl();
  ::uint64_t raw_prev_upl;
  memcpy(&raw_prev_upl, &tmp_prev_upl, sizeof(tmp_prev_upl));
  if (raw_prev_upl != 0) {
    total_size += 10;
  }

  // int32 day_sells = 26;
  if (this->_internal_day_sells() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_day_sells());
  }

  // .t4proto.v1.common.ContractRiskStatus risk_status = 34;
  if (this->_internal_risk_status() != 0) {
    total_size += 2 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_risk_status());
  }

  // double alerting_margin = 36;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_alerting_margin = this->_internal_alerting_margin();
  ::uint64_t raw_alerting_margin;
  memcpy(&raw_alerting_margin, &tmp_alerting_margin, sizeof(tmp_alerting_margin));
  if (raw_alerting_margin != 0) {
    total_size += 10;
  }

  // double day_margin = 38;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_day_margin = this->_internal_day_margin();
  ::uint64_t raw_day_margin;
  memcpy(&raw_day_margin, &tmp_day_margin, sizeof(tmp_day_margin));
  if (raw_day_margin != 0) {
    total_size += 10;
  }

  // double full_margin = 39;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_full_margin = this->_internal_full_margin();
  ::uint64_t raw_full_margin;
  memcpy(&raw_full_margin, &tmp_full_margin, sizeof(tmp_full_margin));
  if (raw_full_margin != 0) {
    total_size += 10;
  }

  // double pre_trade_margin = 40;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_pre_trade_margin = this->_internal_pre_trade_margin();
  ::uint64_t raw_pre_trade_margin;
  memcpy(&raw_pre_trade_margin, &tmp_pre_trade_margin, sizeof(tmp_pre_trade_margin));
  if (raw_pre_trade_margin != 0) {
    total_size += 10;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AccountPosition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AccountPosition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AccountPosition::GetClassData() const { return &_class_data_; }


void AccountPosition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AccountPosition*>(&to_msg);
  auto& from = static_cast<const AccountPosition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:t4proto.v1.account.AccountPosition)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_account_id().empty()) {
    _this->_internal_set_account_id(from._internal_account_id());
  }
  if (!from._internal_exchange_id().empty()) {
    _this->_internal_set_exchange_id(from._internal_exchange_id());
  }
  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (from._internal_has_trade_date()) {
    _this->_internal_mutable_trade_date()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_trade_date());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_average_open_price()->::t4proto::v1::common::Price::MergeFrom(
          from._internal_average_open_price());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_total_open_price()->::t4proto::v1::common::Price::MergeFrom(
          from._internal_total_open_price());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_total_buy_fill_price()->::t4proto::v1::common::Price::MergeFrom(
          from._internal_total_buy_fill_price());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_total_sell_fill_price()->::t4proto::v1::common::Price::MergeFrom(
          from._internal_total_sell_fill_price());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_day_total_buy_fill_price()->::t4proto::v1::common::Price::MergeFrom(
          from._internal_day_total_buy_fill_price());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_day_total_sell_fill_price()->::t4proto::v1::common::Price::MergeFrom(
          from._internal_day_total_sell_fill_price());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_total_overnight_price()->::t4proto::v1::common::Price::MergeFrom(
          from._internal_total_overnight_price());
    }
  }
  if (from._internal_has_margin_time()) {
    _this->_internal_mutable_margin_time()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_margin_time());
  }
  if (from._internal_has_alerting_time()) {
    _this->_internal_mutable_alerting_time()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_alerting_time());
  }
  if (from._internal_buys() != 0) {
    _this->_internal_set_buys(from._internal_buys());
  }
  if (from._internal_sells() != 0) {
    _this->_internal_set_sells(from._internal_sells());
  }
  if (from._internal_working_buys() != 0) {
    _this->_internal_set_working_buys(from._internal_working_buys());
  }
  if (from._internal_working_sells() != 0) {
    _this->_internal_set_working_sells(from._internal_working_sells());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_rpl = from._internal_rpl();
  ::uint64_t raw_rpl;
  memcpy(&raw_rpl, &tmp_rpl, sizeof(tmp_rpl));
  if (raw_rpl != 0) {
    _this->_internal_set_rpl(from._internal_rpl());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_overnight_upl = from._internal_overnight_upl();
  ::uint64_t raw_overnight_upl;
  memcpy(&raw_overnight_upl, &tmp_overnight_upl, sizeof(tmp_overnight_upl));
  if (raw_overnight_upl != 0) {
    _this->_internal_set_overnight_upl(from._internal_overnight_upl());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_margin = from._internal_margin();
  ::uint64_t raw_margin;
  memcpy(&raw_margin, &tmp_margin, sizeof(tmp_margin));
  if (raw_margin != 0) {
    _this->_internal_set_margin(from._internal_margin());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_mp = from._internal_mp();
  ::uint64_t raw_mp;
  memcpy(&raw_mp, &tmp_mp, sizeof(tmp_mp));
  if (raw_mp != 0) {
    _this->_internal_set_mp(from._internal_mp());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_currency_rate = from._internal_currency_rate();
  ::uint64_t raw_currency_rate;
  memcpy(&raw_currency_rate, &tmp_currency_rate, sizeof(tmp_currency_rate));
  if (raw_currency_rate != 0) {
    _this->_internal_set_currency_rate(from._internal_currency_rate());
  }
  if (from._internal_overnight_position() != 0) {
    _this->_internal_set_overnight_position(from._internal_overnight_position());
  }
  if (from._internal_total_open_volume() != 0) {
    _this->_internal_set_total_open_volume(from._internal_total_open_volume());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_premium = from._internal_premium();
  ::uint64_t raw_premium;
  memcpy(&raw_premium, &tmp_premium, sizeof(tmp_premium));
  if (raw_premium != 0) {
    _this->_internal_set_premium(from._internal_premium());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_fees_and_commissions = from._internal_fees_and_commissions();
  ::uint64_t raw_fees_and_commissions;
  memcpy(&raw_fees_and_commissions, &tmp_fees_and_commissions, sizeof(tmp_fees_and_commissions));
  if (raw_fees_and_commissions != 0) {
    _this->_internal_set_fees_and_commissions(from._internal_fees_and_commissions());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_long_mp = from._internal_long_mp();
  ::uint64_t raw_long_mp;
  memcpy(&raw_long_mp, &tmp_long_mp, sizeof(tmp_long_mp));
  if (raw_long_mp != 0) {
    _this->_internal_set_long_mp(from._internal_long_mp());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_short_mp = from._internal_short_mp();
  ::uint64_t raw_short_mp;
  memcpy(&raw_short_mp, &tmp_short_mp, sizeof(tmp_short_mp));
  if (raw_short_mp != 0) {
    _this->_internal_set_short_mp(from._internal_short_mp());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_prev_margin = from._internal_prev_margin();
  ::uint64_t raw_prev_margin;
  memcpy(&raw_prev_margin, &tmp_prev_margin, sizeof(tmp_prev_margin));
  if (raw_prev_margin != 0) {
    _this->_internal_set_prev_margin(from._internal_prev_margin());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_prev_rpl = from._internal_prev_rpl();
  ::uint64_t raw_prev_rpl;
  memcpy(&raw_prev_rpl, &tmp_prev_rpl, sizeof(tmp_prev_rpl));
  if (raw_prev_rpl != 0) {
    _this->_internal_set_prev_rpl(from._internal_prev_rpl());
  }
  if (from._internal_prev_position() != 0) {
    _this->_internal_set_prev_position(from._internal_prev_position());
  }
  if (from._internal_day_buys() != 0) {
    _this->_internal_set_day_buys(from._internal_day_buys());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_prev_upl = from._internal_prev_upl();
  ::uint64_t raw_prev_upl;
  memcpy(&raw_prev_upl, &tmp_prev_upl, sizeof(tmp_prev_upl));
  if (raw_prev_upl != 0) {
    _this->_internal_set_prev_upl(from._internal_prev_upl());
  }
  if (from._internal_day_sells() != 0) {
    _this->_internal_set_day_sells(from._internal_day_sells());
  }
  if (from._internal_risk_status() != 0) {
    _this->_internal_set_risk_status(from._internal_risk_status());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_alerting_margin = from._internal_alerting_margin();
  ::uint64_t raw_alerting_margin;
  memcpy(&raw_alerting_margin, &tmp_alerting_margin, sizeof(tmp_alerting_margin));
  if (raw_alerting_margin != 0) {
    _this->_internal_set_alerting_margin(from._internal_alerting_margin());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_day_margin = from._internal_day_margin();
  ::uint64_t raw_day_margin;
  memcpy(&raw_day_margin, &tmp_day_margin, sizeof(tmp_day_margin));
  if (raw_day_margin != 0) {
    _this->_internal_set_day_margin(from._internal_day_margin());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_full_margin = from._internal_full_margin();
  ::uint64_t raw_full_margin;
  memcpy(&raw_full_margin, &tmp_full_margin, sizeof(tmp_full_margin));
  if (raw_full_margin != 0) {
    _this->_internal_set_full_margin(from._internal_full_margin());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_pre_trade_margin = from._internal_pre_trade_margin();
  ::uint64_t raw_pre_trade_margin;
  memcpy(&raw_pre_trade_margin, &tmp_pre_trade_margin, sizeof(tmp_pre_trade_margin));
  if (raw_pre_trade_margin != 0) {
    _this->_internal_set_pre_trade_margin(from._internal_pre_trade_margin());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AccountPosition::CopyFrom(const AccountPosition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:t4proto.v1.account.AccountPosition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountPosition::IsInitialized() const {
  return true;
}

void AccountPosition::InternalSwap(AccountPosition* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.account_id_, lhs_arena,
                                       &other->_impl_.account_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.exchange_id_, lhs_arena,
                                       &other->_impl_.exchange_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.contract_id_, lhs_arena,
                                       &other->_impl_.contract_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AccountPosition, _impl_.pre_trade_margin_)
      + sizeof(AccountPosition::_impl_.pre_trade_margin_)
      - PROTOBUF_FIELD_OFFSET(AccountPosition, _impl_.trade_date_)>(
          reinterpret_cast<char*>(&_impl_.trade_date_),
          reinterpret_cast<char*>(&other->_impl_.trade_date_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AccountPosition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_t4_2fv1_2faccount_2faccount_2eproto_getter, &descriptor_table_t4_2fv1_2faccount_2faccount_2eproto_once,
      file_level_metadata_t4_2fv1_2faccount_2faccount_2eproto[3]);
}
// ===================================================================

class AccountUpdate::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& imported_net_liq_date(const AccountUpdate* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& prev_imported_net_liq_date(const AccountUpdate* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& margin_time(const AccountUpdate* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& alerting_time(const AccountUpdate* msg);
};

const ::PROTOBUF_NAMESPACE_ID::Timestamp&
AccountUpdate::_Internal::imported_net_liq_date(const AccountUpdate* msg) {
  return *msg->_impl_.imported_net_liq_date_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
AccountUpdate::_Internal::prev_imported_net_liq_date(const AccountUpdate* msg) {
  return *msg->_impl_.prev_imported_net_liq_date_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
AccountUpdate::_Internal::margin_time(const AccountUpdate* msg) {
  return *msg->_impl_.margin_time_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
AccountUpdate::_Internal::alerting_time(const AccountUpdate* msg) {
  return *msg->_impl_.alerting_time_;
}
void AccountUpdate::clear_imported_net_liq_date() {
  if (GetArenaForAllocation() == nullptr && _impl_.imported_net_liq_date_ != nullptr) {
    delete _impl_.imported_net_liq_date_;
  }
  _impl_.imported_net_liq_date_ = nullptr;
}
void AccountUpdate::clear_prev_imported_net_liq_date() {
  if (GetArenaForAllocation() == nullptr && _impl_.prev_imported_net_liq_date_ != nullptr) {
    delete _impl_.prev_imported_net_liq_date_;
  }
  _impl_.prev_imported_net_liq_date_ = nullptr;
}
void AccountUpdate::clear_margin_time() {
  if (GetArenaForAllocation() == nullptr && _impl_.margin_time_ != nullptr) {
    delete _impl_.margin_time_;
  }
  _impl_.margin_time_ = nullptr;
}
void AccountUpdate::clear_alerting_time() {
  if (GetArenaForAllocation() == nullptr && _impl_.alerting_time_ != nullptr) {
    delete _impl_.alerting_time_;
  }
  _impl_.alerting_time_ = nullptr;
}
AccountUpdate::AccountUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:t4proto.v1.account.AccountUpdate)
}
AccountUpdate::AccountUpdate(const AccountUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AccountUpdate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.account_id_) {}

    , decltype(_impl_.imported_net_liq_date_){nullptr}
    , decltype(_impl_.prev_imported_net_liq_date_){nullptr}
    , decltype(_impl_.margin_time_){nullptr}
    , decltype(_impl_.alerting_time_){nullptr}
    , decltype(_impl_.balance_) {}

    , decltype(_impl_.rpl_) {}

    , decltype(_impl_.overnight_upl_) {}

    , decltype(_impl_.margin_) {}

    , decltype(_impl_.day_margin_) {}

    , decltype(_impl_.full_margin_) {}

    , decltype(_impl_.base_margin_) {}

    , decltype(_impl_.alerting_margin_) {}

    , decltype(_impl_.pre_trade_margin_) {}

    , decltype(_impl_.mp_) {}

    , decltype(_impl_.premium_) {}

    , decltype(_impl_.long_mp_) {}

    , decltype(_impl_.short_mp_) {}

    , decltype(_impl_.fees_and_commissions_) {}

    , decltype(_impl_.prev_margin_) {}

    , decltype(_impl_.imported_net_liq_) {}

    , decltype(_impl_.prev_imported_net_liq_) {}

    , decltype(_impl_.filled_delta_) {}

    , decltype(_impl_.working_delta_) {}

    , decltype(_impl_.status_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.account_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_account_id().empty()) {
    _this->_impl_.account_id_.Set(from._internal_account_id(), _this->GetArenaForAllocation());
  }
  if (from._internal_has_imported_net_liq_date()) {
    _this->_impl_.imported_net_liq_date_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.imported_net_liq_date_);
  }
  if (from._internal_has_prev_imported_net_liq_date()) {
    _this->_impl_.prev_imported_net_liq_date_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.prev_imported_net_liq_date_);
  }
  if (from._internal_has_margin_time()) {
    _this->_impl_.margin_time_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.margin_time_);
  }
  if (from._internal_has_alerting_time()) {
    _this->_impl_.alerting_time_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.alerting_time_);
  }
  ::memcpy(&_impl_.balance_, &from._impl_.balance_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.status_) -
    reinterpret_cast<char*>(&_impl_.balance_)) + sizeof(_impl_.status_));
  // @@protoc_insertion_point(copy_constructor:t4proto.v1.account.AccountUpdate)
}

inline void AccountUpdate::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.account_id_) {}

    , decltype(_impl_.imported_net_liq_date_){nullptr}
    , decltype(_impl_.prev_imported_net_liq_date_){nullptr}
    , decltype(_impl_.margin_time_){nullptr}
    , decltype(_impl_.alerting_time_){nullptr}
    , decltype(_impl_.balance_) { 0 }

    , decltype(_impl_.rpl_) { 0 }

    , decltype(_impl_.overnight_upl_) { 0 }

    , decltype(_impl_.margin_) { 0 }

    , decltype(_impl_.day_margin_) { 0 }

    , decltype(_impl_.full_margin_) { 0 }

    , decltype(_impl_.base_margin_) { 0 }

    , decltype(_impl_.alerting_margin_) { 0 }

    , decltype(_impl_.pre_trade_margin_) { 0 }

    , decltype(_impl_.mp_) { 0 }

    , decltype(_impl_.premium_) { 0 }

    , decltype(_impl_.long_mp_) { 0 }

    , decltype(_impl_.short_mp_) { 0 }

    , decltype(_impl_.fees_and_commissions_) { 0 }

    , decltype(_impl_.prev_margin_) { 0 }

    , decltype(_impl_.imported_net_liq_) { 0 }

    , decltype(_impl_.prev_imported_net_liq_) { 0 }

    , decltype(_impl_.filled_delta_) { 0 }

    , decltype(_impl_.working_delta_) { 0 }

    , decltype(_impl_.status_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.account_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AccountUpdate::~AccountUpdate() {
  // @@protoc_insertion_point(destructor:t4proto.v1.account.AccountUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AccountUpdate::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.account_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.imported_net_liq_date_;
  if (this != internal_default_instance()) delete _impl_.prev_imported_net_liq_date_;
  if (this != internal_default_instance()) delete _impl_.margin_time_;
  if (this != internal_default_instance()) delete _impl_.alerting_time_;
}

void AccountUpdate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AccountUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:t4proto.v1.account.AccountUpdate)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.account_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.imported_net_liq_date_ != nullptr) {
    delete _impl_.imported_net_liq_date_;
  }
  _impl_.imported_net_liq_date_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.prev_imported_net_liq_date_ != nullptr) {
    delete _impl_.prev_imported_net_liq_date_;
  }
  _impl_.prev_imported_net_liq_date_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.margin_time_ != nullptr) {
    delete _impl_.margin_time_;
  }
  _impl_.margin_time_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.alerting_time_ != nullptr) {
    delete _impl_.alerting_time_;
  }
  _impl_.alerting_time_ = nullptr;
  ::memset(&_impl_.balance_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.status_) -
      reinterpret_cast<char*>(&_impl_.balance_)) + sizeof(_impl_.status_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AccountUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_account_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "t4proto.v1.account.AccountUpdate.account_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .t4proto.v1.common.AccountStatus status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_status(static_cast<::t4proto::v1::common::AccountStatus>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // double balance = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 25)) {
          _impl_.balance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // double rpl = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 33)) {
          _impl_.rpl_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // double overnight_upl = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 41)) {
          _impl_.overnight_upl_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // double margin = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 49)) {
          _impl_.margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // double day_margin = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 57)) {
          _impl_.day_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // double full_margin = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 65)) {
          _impl_.full_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // double base_margin = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 73)) {
          _impl_.base_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // double alerting_margin = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 81)) {
          _impl_.alerting_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // double pre_trade_margin = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 89)) {
          _impl_.pre_trade_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // double mp = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 97)) {
          _impl_.mp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // double premium = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 105)) {
          _impl_.premium_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // double long_mp = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 113)) {
          _impl_.long_mp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // double short_mp = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 121)) {
          _impl_.short_mp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // double fees_and_commissions = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 129)) {
          _impl_.fees_and_commissions_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // double prev_margin = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 137)) {
          _impl_.prev_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // double imported_net_liq = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 145)) {
          _impl_.imported_net_liq_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.Timestamp imported_net_liq_date = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_imported_net_liq_date(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // double prev_imported_net_liq = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 161)) {
          _impl_.prev_imported_net_liq_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.Timestamp prev_imported_net_liq_date = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_prev_imported_net_liq_date(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // double filled_delta = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 177)) {
          _impl_.filled_delta_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // double working_delta = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 185)) {
          _impl_.working_delta_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.Timestamp margin_time = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_margin_time(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.Timestamp alerting_time = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_alerting_time(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AccountUpdate::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:t4proto.v1.account.AccountUpdate)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string account_id = 1;
  if (!this->_internal_account_id().empty()) {
    const std::string& _s = this->_internal_account_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "t4proto.v1.account.AccountUpdate.account_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // .t4proto.v1.common.AccountStatus status = 2;
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_status(), target);
  }

  // double balance = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_balance = this->_internal_balance();
  ::uint64_t raw_balance;
  memcpy(&raw_balance, &tmp_balance, sizeof(tmp_balance));
  if (raw_balance != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_balance(), target);
  }

  // double rpl = 4;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_rpl = this->_internal_rpl();
  ::uint64_t raw_rpl;
  memcpy(&raw_rpl, &tmp_rpl, sizeof(tmp_rpl));
  if (raw_rpl != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_rpl(), target);
  }

  // double overnight_upl = 5;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_overnight_upl = this->_internal_overnight_upl();
  ::uint64_t raw_overnight_upl;
  memcpy(&raw_overnight_upl, &tmp_overnight_upl, sizeof(tmp_overnight_upl));
  if (raw_overnight_upl != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        5, this->_internal_overnight_upl(), target);
  }

  // double margin = 6;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_margin = this->_internal_margin();
  ::uint64_t raw_margin;
  memcpy(&raw_margin, &tmp_margin, sizeof(tmp_margin));
  if (raw_margin != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        6, this->_internal_margin(), target);
  }

  // double day_margin = 7;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_day_margin = this->_internal_day_margin();
  ::uint64_t raw_day_margin;
  memcpy(&raw_day_margin, &tmp_day_margin, sizeof(tmp_day_margin));
  if (raw_day_margin != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        7, this->_internal_day_margin(), target);
  }

  // double full_margin = 8;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_full_margin = this->_internal_full_margin();
  ::uint64_t raw_full_margin;
  memcpy(&raw_full_margin, &tmp_full_margin, sizeof(tmp_full_margin));
  if (raw_full_margin != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        8, this->_internal_full_margin(), target);
  }

  // double base_margin = 9;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_base_margin = this->_internal_base_margin();
  ::uint64_t raw_base_margin;
  memcpy(&raw_base_margin, &tmp_base_margin, sizeof(tmp_base_margin));
  if (raw_base_margin != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        9, this->_internal_base_margin(), target);
  }

  // double alerting_margin = 10;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_alerting_margin = this->_internal_alerting_margin();
  ::uint64_t raw_alerting_margin;
  memcpy(&raw_alerting_margin, &tmp_alerting_margin, sizeof(tmp_alerting_margin));
  if (raw_alerting_margin != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        10, this->_internal_alerting_margin(), target);
  }

  // double pre_trade_margin = 11;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_pre_trade_margin = this->_internal_pre_trade_margin();
  ::uint64_t raw_pre_trade_margin;
  memcpy(&raw_pre_trade_margin, &tmp_pre_trade_margin, sizeof(tmp_pre_trade_margin));
  if (raw_pre_trade_margin != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        11, this->_internal_pre_trade_margin(), target);
  }

  // double mp = 12;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_mp = this->_internal_mp();
  ::uint64_t raw_mp;
  memcpy(&raw_mp, &tmp_mp, sizeof(tmp_mp));
  if (raw_mp != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        12, this->_internal_mp(), target);
  }

  // double premium = 13;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_premium = this->_internal_premium();
  ::uint64_t raw_premium;
  memcpy(&raw_premium, &tmp_premium, sizeof(tmp_premium));
  if (raw_premium != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        13, this->_internal_premium(), target);
  }

  // double long_mp = 14;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_long_mp = this->_internal_long_mp();
  ::uint64_t raw_long_mp;
  memcpy(&raw_long_mp, &tmp_long_mp, sizeof(tmp_long_mp));
  if (raw_long_mp != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        14, this->_internal_long_mp(), target);
  }

  // double short_mp = 15;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_short_mp = this->_internal_short_mp();
  ::uint64_t raw_short_mp;
  memcpy(&raw_short_mp, &tmp_short_mp, sizeof(tmp_short_mp));
  if (raw_short_mp != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        15, this->_internal_short_mp(), target);
  }

  // double fees_and_commissions = 16;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_fees_and_commissions = this->_internal_fees_and_commissions();
  ::uint64_t raw_fees_and_commissions;
  memcpy(&raw_fees_and_commissions, &tmp_fees_and_commissions, sizeof(tmp_fees_and_commissions));
  if (raw_fees_and_commissions != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        16, this->_internal_fees_and_commissions(), target);
  }

  // double prev_margin = 17;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_prev_margin = this->_internal_prev_margin();
  ::uint64_t raw_prev_margin;
  memcpy(&raw_prev_margin, &tmp_prev_margin, sizeof(tmp_prev_margin));
  if (raw_prev_margin != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        17, this->_internal_prev_margin(), target);
  }

  // double imported_net_liq = 18;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_imported_net_liq = this->_internal_imported_net_liq();
  ::uint64_t raw_imported_net_liq;
  memcpy(&raw_imported_net_liq, &tmp_imported_net_liq, sizeof(tmp_imported_net_liq));
  if (raw_imported_net_liq != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        18, this->_internal_imported_net_liq(), target);
  }

  // .google.protobuf.Timestamp imported_net_liq_date = 19;
  if (this->_internal_has_imported_net_liq_date()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::imported_net_liq_date(this),
        _Internal::imported_net_liq_date(this).GetCachedSize(), target, stream);
  }

  // double prev_imported_net_liq = 20;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_prev_imported_net_liq = this->_internal_prev_imported_net_liq();
  ::uint64_t raw_prev_imported_net_liq;
  memcpy(&raw_prev_imported_net_liq, &tmp_prev_imported_net_liq, sizeof(tmp_prev_imported_net_liq));
  if (raw_prev_imported_net_liq != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        20, this->_internal_prev_imported_net_liq(), target);
  }

  // .google.protobuf.Timestamp prev_imported_net_liq_date = 21;
  if (this->_internal_has_prev_imported_net_liq_date()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, _Internal::prev_imported_net_liq_date(this),
        _Internal::prev_imported_net_liq_date(this).GetCachedSize(), target, stream);
  }

  // double filled_delta = 22;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_filled_delta = this->_internal_filled_delta();
  ::uint64_t raw_filled_delta;
  memcpy(&raw_filled_delta, &tmp_filled_delta, sizeof(tmp_filled_delta));
  if (raw_filled_delta != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        22, this->_internal_filled_delta(), target);
  }

  // double working_delta = 23;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_working_delta = this->_internal_working_delta();
  ::uint64_t raw_working_delta;
  memcpy(&raw_working_delta, &tmp_working_delta, sizeof(tmp_working_delta));
  if (raw_working_delta != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        23, this->_internal_working_delta(), target);
  }

  // .google.protobuf.Timestamp margin_time = 24;
  if (this->_internal_has_margin_time()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(24, _Internal::margin_time(this),
        _Internal::margin_time(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Timestamp alerting_time = 25;
  if (this->_internal_has_alerting_time()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(25, _Internal::alerting_time(this),
        _Internal::alerting_time(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:t4proto.v1.account.AccountUpdate)
  return target;
}

::size_t AccountUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:t4proto.v1.account.AccountUpdate)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string account_id = 1;
  if (!this->_internal_account_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_account_id());
  }

  // .google.protobuf.Timestamp imported_net_liq_date = 19;
  if (this->_internal_has_imported_net_liq_date()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.imported_net_liq_date_);
  }

  // .google.protobuf.Timestamp prev_imported_net_liq_date = 21;
  if (this->_internal_has_prev_imported_net_liq_date()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.prev_imported_net_liq_date_);
  }

  // .google.protobuf.Timestamp margin_time = 24;
  if (this->_internal_has_margin_time()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.margin_time_);
  }

  // .google.protobuf.Timestamp alerting_time = 25;
  if (this->_internal_has_alerting_time()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.alerting_time_);
  }

  // double balance = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_balance = this->_internal_balance();
  ::uint64_t raw_balance;
  memcpy(&raw_balance, &tmp_balance, sizeof(tmp_balance));
  if (raw_balance != 0) {
    total_size += 9;
  }

  // double rpl = 4;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_rpl = this->_internal_rpl();
  ::uint64_t raw_rpl;
  memcpy(&raw_rpl, &tmp_rpl, sizeof(tmp_rpl));
  if (raw_rpl != 0) {
    total_size += 9;
  }

  // double overnight_upl = 5;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_overnight_upl = this->_internal_overnight_upl();
  ::uint64_t raw_overnight_upl;
  memcpy(&raw_overnight_upl, &tmp_overnight_upl, sizeof(tmp_overnight_upl));
  if (raw_overnight_upl != 0) {
    total_size += 9;
  }

  // double margin = 6;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_margin = this->_internal_margin();
  ::uint64_t raw_margin;
  memcpy(&raw_margin, &tmp_margin, sizeof(tmp_margin));
  if (raw_margin != 0) {
    total_size += 9;
  }

  // double day_margin = 7;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_day_margin = this->_internal_day_margin();
  ::uint64_t raw_day_margin;
  memcpy(&raw_day_margin, &tmp_day_margin, sizeof(tmp_day_margin));
  if (raw_day_margin != 0) {
    total_size += 9;
  }

  // double full_margin = 8;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_full_margin = this->_internal_full_margin();
  ::uint64_t raw_full_margin;
  memcpy(&raw_full_margin, &tmp_full_margin, sizeof(tmp_full_margin));
  if (raw_full_margin != 0) {
    total_size += 9;
  }

  // double base_margin = 9;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_base_margin = this->_internal_base_margin();
  ::uint64_t raw_base_margin;
  memcpy(&raw_base_margin, &tmp_base_margin, sizeof(tmp_base_margin));
  if (raw_base_margin != 0) {
    total_size += 9;
  }

  // double alerting_margin = 10;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_alerting_margin = this->_internal_alerting_margin();
  ::uint64_t raw_alerting_margin;
  memcpy(&raw_alerting_margin, &tmp_alerting_margin, sizeof(tmp_alerting_margin));
  if (raw_alerting_margin != 0) {
    total_size += 9;
  }

  // double pre_trade_margin = 11;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_pre_trade_margin = this->_internal_pre_trade_margin();
  ::uint64_t raw_pre_trade_margin;
  memcpy(&raw_pre_trade_margin, &tmp_pre_trade_margin, sizeof(tmp_pre_trade_margin));
  if (raw_pre_trade_margin != 0) {
    total_size += 9;
  }

  // double mp = 12;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_mp = this->_internal_mp();
  ::uint64_t raw_mp;
  memcpy(&raw_mp, &tmp_mp, sizeof(tmp_mp));
  if (raw_mp != 0) {
    total_size += 9;
  }

  // double premium = 13;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_premium = this->_internal_premium();
  ::uint64_t raw_premium;
  memcpy(&raw_premium, &tmp_premium, sizeof(tmp_premium));
  if (raw_premium != 0) {
    total_size += 9;
  }

  // double long_mp = 14;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_long_mp = this->_internal_long_mp();
  ::uint64_t raw_long_mp;
  memcpy(&raw_long_mp, &tmp_long_mp, sizeof(tmp_long_mp));
  if (raw_long_mp != 0) {
    total_size += 9;
  }

  // double short_mp = 15;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_short_mp = this->_internal_short_mp();
  ::uint64_t raw_short_mp;
  memcpy(&raw_short_mp, &tmp_short_mp, sizeof(tmp_short_mp));
  if (raw_short_mp != 0) {
    total_size += 9;
  }

  // double fees_and_commissions = 16;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_fees_and_commissions = this->_internal_fees_and_commissions();
  ::uint64_t raw_fees_and_commissions;
  memcpy(&raw_fees_and_commissions, &tmp_fees_and_commissions, sizeof(tmp_fees_and_commissions));
  if (raw_fees_and_commissions != 0) {
    total_size += 10;
  }

  // double prev_margin = 17;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_prev_margin = this->_internal_prev_margin();
  ::uint64_t raw_prev_margin;
  memcpy(&raw_prev_margin, &tmp_prev_margin, sizeof(tmp_prev_margin));
  if (raw_prev_margin != 0) {
    total_size += 10;
  }

  // double imported_net_liq = 18;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_imported_net_liq = this->_internal_imported_net_liq();
  ::uint64_t raw_imported_net_liq;
  memcpy(&raw_imported_net_liq, &tmp_imported_net_liq, sizeof(tmp_imported_net_liq));
  if (raw_imported_net_liq != 0) {
    total_size += 10;
  }

  // double prev_imported_net_liq = 20;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_prev_imported_net_liq = this->_internal_prev_imported_net_liq();
  ::uint64_t raw_prev_imported_net_liq;
  memcpy(&raw_prev_imported_net_liq, &tmp_prev_imported_net_liq, sizeof(tmp_prev_imported_net_liq));
  if (raw_prev_imported_net_liq != 0) {
    total_size += 10;
  }

  // double filled_delta = 22;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_filled_delta = this->_internal_filled_delta();
  ::uint64_t raw_filled_delta;
  memcpy(&raw_filled_delta, &tmp_filled_delta, sizeof(tmp_filled_delta));
  if (raw_filled_delta != 0) {
    total_size += 10;
  }

  // double working_delta = 23;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_working_delta = this->_internal_working_delta();
  ::uint64_t raw_working_delta;
  memcpy(&raw_working_delta, &tmp_working_delta, sizeof(tmp_working_delta));
  if (raw_working_delta != 0) {
    total_size += 10;
  }

  // .t4proto.v1.common.AccountStatus status = 2;
  if (this->_internal_status() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AccountUpdate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AccountUpdate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AccountUpdate::GetClassData() const { return &_class_data_; }


void AccountUpdate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AccountUpdate*>(&to_msg);
  auto& from = static_cast<const AccountUpdate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:t4proto.v1.account.AccountUpdate)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_account_id().empty()) {
    _this->_internal_set_account_id(from._internal_account_id());
  }
  if (from._internal_has_imported_net_liq_date()) {
    _this->_internal_mutable_imported_net_liq_date()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_imported_net_liq_date());
  }
  if (from._internal_has_prev_imported_net_liq_date()) {
    _this->_internal_mutable_prev_imported_net_liq_date()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_prev_imported_net_liq_date());
  }
  if (from._internal_has_margin_time()) {
    _this->_internal_mutable_margin_time()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_margin_time());
  }
  if (from._internal_has_alerting_time()) {
    _this->_internal_mutable_alerting_time()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_alerting_time());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_balance = from._internal_balance();
  ::uint64_t raw_balance;
  memcpy(&raw_balance, &tmp_balance, sizeof(tmp_balance));
  if (raw_balance != 0) {
    _this->_internal_set_balance(from._internal_balance());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_rpl = from._internal_rpl();
  ::uint64_t raw_rpl;
  memcpy(&raw_rpl, &tmp_rpl, sizeof(tmp_rpl));
  if (raw_rpl != 0) {
    _this->_internal_set_rpl(from._internal_rpl());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_overnight_upl = from._internal_overnight_upl();
  ::uint64_t raw_overnight_upl;
  memcpy(&raw_overnight_upl, &tmp_overnight_upl, sizeof(tmp_overnight_upl));
  if (raw_overnight_upl != 0) {
    _this->_internal_set_overnight_upl(from._internal_overnight_upl());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_margin = from._internal_margin();
  ::uint64_t raw_margin;
  memcpy(&raw_margin, &tmp_margin, sizeof(tmp_margin));
  if (raw_margin != 0) {
    _this->_internal_set_margin(from._internal_margin());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_day_margin = from._internal_day_margin();
  ::uint64_t raw_day_margin;
  memcpy(&raw_day_margin, &tmp_day_margin, sizeof(tmp_day_margin));
  if (raw_day_margin != 0) {
    _this->_internal_set_day_margin(from._internal_day_margin());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_full_margin = from._internal_full_margin();
  ::uint64_t raw_full_margin;
  memcpy(&raw_full_margin, &tmp_full_margin, sizeof(tmp_full_margin));
  if (raw_full_margin != 0) {
    _this->_internal_set_full_margin(from._internal_full_margin());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_base_margin = from._internal_base_margin();
  ::uint64_t raw_base_margin;
  memcpy(&raw_base_margin, &tmp_base_margin, sizeof(tmp_base_margin));
  if (raw_base_margin != 0) {
    _this->_internal_set_base_margin(from._internal_base_margin());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_alerting_margin = from._internal_alerting_margin();
  ::uint64_t raw_alerting_margin;
  memcpy(&raw_alerting_margin, &tmp_alerting_margin, sizeof(tmp_alerting_margin));
  if (raw_alerting_margin != 0) {
    _this->_internal_set_alerting_margin(from._internal_alerting_margin());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_pre_trade_margin = from._internal_pre_trade_margin();
  ::uint64_t raw_pre_trade_margin;
  memcpy(&raw_pre_trade_margin, &tmp_pre_trade_margin, sizeof(tmp_pre_trade_margin));
  if (raw_pre_trade_margin != 0) {
    _this->_internal_set_pre_trade_margin(from._internal_pre_trade_margin());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_mp = from._internal_mp();
  ::uint64_t raw_mp;
  memcpy(&raw_mp, &tmp_mp, sizeof(tmp_mp));
  if (raw_mp != 0) {
    _this->_internal_set_mp(from._internal_mp());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_premium = from._internal_premium();
  ::uint64_t raw_premium;
  memcpy(&raw_premium, &tmp_premium, sizeof(tmp_premium));
  if (raw_premium != 0) {
    _this->_internal_set_premium(from._internal_premium());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_long_mp = from._internal_long_mp();
  ::uint64_t raw_long_mp;
  memcpy(&raw_long_mp, &tmp_long_mp, sizeof(tmp_long_mp));
  if (raw_long_mp != 0) {
    _this->_internal_set_long_mp(from._internal_long_mp());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_short_mp = from._internal_short_mp();
  ::uint64_t raw_short_mp;
  memcpy(&raw_short_mp, &tmp_short_mp, sizeof(tmp_short_mp));
  if (raw_short_mp != 0) {
    _this->_internal_set_short_mp(from._internal_short_mp());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_fees_and_commissions = from._internal_fees_and_commissions();
  ::uint64_t raw_fees_and_commissions;
  memcpy(&raw_fees_and_commissions, &tmp_fees_and_commissions, sizeof(tmp_fees_and_commissions));
  if (raw_fees_and_commissions != 0) {
    _this->_internal_set_fees_and_commissions(from._internal_fees_and_commissions());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_prev_margin = from._internal_prev_margin();
  ::uint64_t raw_prev_margin;
  memcpy(&raw_prev_margin, &tmp_prev_margin, sizeof(tmp_prev_margin));
  if (raw_prev_margin != 0) {
    _this->_internal_set_prev_margin(from._internal_prev_margin());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_imported_net_liq = from._internal_imported_net_liq();
  ::uint64_t raw_imported_net_liq;
  memcpy(&raw_imported_net_liq, &tmp_imported_net_liq, sizeof(tmp_imported_net_liq));
  if (raw_imported_net_liq != 0) {
    _this->_internal_set_imported_net_liq(from._internal_imported_net_liq());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_prev_imported_net_liq = from._internal_prev_imported_net_liq();
  ::uint64_t raw_prev_imported_net_liq;
  memcpy(&raw_prev_imported_net_liq, &tmp_prev_imported_net_liq, sizeof(tmp_prev_imported_net_liq));
  if (raw_prev_imported_net_liq != 0) {
    _this->_internal_set_prev_imported_net_liq(from._internal_prev_imported_net_liq());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_filled_delta = from._internal_filled_delta();
  ::uint64_t raw_filled_delta;
  memcpy(&raw_filled_delta, &tmp_filled_delta, sizeof(tmp_filled_delta));
  if (raw_filled_delta != 0) {
    _this->_internal_set_filled_delta(from._internal_filled_delta());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_working_delta = from._internal_working_delta();
  ::uint64_t raw_working_delta;
  memcpy(&raw_working_delta, &tmp_working_delta, sizeof(tmp_working_delta));
  if (raw_working_delta != 0) {
    _this->_internal_set_working_delta(from._internal_working_delta());
  }
  if (from._internal_status() != 0) {
    _this->_internal_set_status(from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AccountUpdate::CopyFrom(const AccountUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:t4proto.v1.account.AccountUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountUpdate::IsInitialized() const {
  return true;
}

void AccountUpdate::InternalSwap(AccountUpdate* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.account_id_, lhs_arena,
                                       &other->_impl_.account_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AccountUpdate, _impl_.status_)
      + sizeof(AccountUpdate::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(AccountUpdate, _impl_.imported_net_liq_date_)>(
          reinterpret_cast<char*>(&_impl_.imported_net_liq_date_),
          reinterpret_cast<char*>(&other->_impl_.imported_net_liq_date_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AccountUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_t4_2fv1_2faccount_2faccount_2eproto_getter, &descriptor_table_t4_2fv1_2faccount_2faccount_2eproto_once,
      file_level_metadata_t4_2fv1_2faccount_2faccount_2eproto[4]);
}
// ===================================================================

class AccountDetails::_Internal {
 public:
};

AccountDetails::AccountDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:t4proto.v1.account.AccountDetails)
}
AccountDetails::AccountDetails(const AccountDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AccountDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.account_id_) {}

    , decltype(_impl_.account_name_) {}

    , decltype(_impl_.account_) {}

    , decltype(_impl_.firm_id_) {}

    , decltype(_impl_.active_time_start_) {}

    , decltype(_impl_.active_time_stop_) {}

    , decltype(_impl_.firm_) {}

    , decltype(_impl_.display_name_) {}

    , decltype(_impl_.risk_details_) {}

    , decltype(_impl_.group_name_) {}

    , decltype(_impl_.enabled_) {}

    , decltype(_impl_.max_clip_size_) {}

    , decltype(_impl_.deleted_) {}

    , decltype(_impl_.pre_trade_disabled_) {}

    , decltype(_impl_.position_rollover_) {}

    , decltype(_impl_.pl_rollover_) {}

    , decltype(_impl_.margin_pc_) {}

    , decltype(_impl_.min_balance_) {}

    , decltype(_impl_.loss_limit_) {}

    , decltype(_impl_.loss_limit_pc_) {}

    , decltype(_impl_.overnight_margin_pc_) {}

    , decltype(_impl_.warning_threshold_pl_) {}

    , decltype(_impl_.warning_threshold_loss_limit_) {}

    , decltype(_impl_.warning_threshold_margin_) {}

    , decltype(_impl_.mode_) {}

    , decltype(_impl_.day_loss_limit_) {}

    , decltype(_impl_.max_account_position_) {}

    , decltype(_impl_.wide_market_) {}

    , decltype(_impl_.order_routing_) {}

    , decltype(_impl_.use_pl_for_margin_) {}

    , decltype(_impl_.options_settlement_) {}

    , decltype(_impl_.use_premium_for_margin_) {}

    , decltype(_impl_.margin_type_) {}

    , decltype(_impl_.price_banding_) {}

    , decltype(_impl_.day_loss_limit_pc_) {}

    , decltype(_impl_.warning_threshold_min_net_equity_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.account_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_account_id().empty()) {
    _this->_impl_.account_id_.Set(from._internal_account_id(), _this->GetArenaForAllocation());
  }
  _impl_.account_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_account_name().empty()) {
    _this->_impl_.account_name_.Set(from._internal_account_name(), _this->GetArenaForAllocation());
  }
  _impl_.account_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_account().empty()) {
    _this->_impl_.account_.Set(from._internal_account(), _this->GetArenaForAllocation());
  }
  _impl_.firm_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.firm_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_firm_id().empty()) {
    _this->_impl_.firm_id_.Set(from._internal_firm_id(), _this->GetArenaForAllocation());
  }
  _impl_.active_time_start_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.active_time_start_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_active_time_start().empty()) {
    _this->_impl_.active_time_start_.Set(from._internal_active_time_start(), _this->GetArenaForAllocation());
  }
  _impl_.active_time_stop_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.active_time_stop_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_active_time_stop().empty()) {
    _this->_impl_.active_time_stop_.Set(from._internal_active_time_stop(), _this->GetArenaForAllocation());
  }
  _impl_.firm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.firm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_firm().empty()) {
    _this->_impl_.firm_.Set(from._internal_firm(), _this->GetArenaForAllocation());
  }
  _impl_.display_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.display_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_display_name().empty()) {
    _this->_impl_.display_name_.Set(from._internal_display_name(), _this->GetArenaForAllocation());
  }
  _impl_.risk_details_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.risk_details_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_risk_details().empty()) {
    _this->_impl_.risk_details_.Set(from._internal_risk_details(), _this->GetArenaForAllocation());
  }
  _impl_.group_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.group_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_group_name().empty()) {
    _this->_impl_.group_name_.Set(from._internal_group_name(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.enabled_, &from._impl_.enabled_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.warning_threshold_min_net_equity_) -
    reinterpret_cast<char*>(&_impl_.enabled_)) + sizeof(_impl_.warning_threshold_min_net_equity_));
  // @@protoc_insertion_point(copy_constructor:t4proto.v1.account.AccountDetails)
}

inline void AccountDetails::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.account_id_) {}

    , decltype(_impl_.account_name_) {}

    , decltype(_impl_.account_) {}

    , decltype(_impl_.firm_id_) {}

    , decltype(_impl_.active_time_start_) {}

    , decltype(_impl_.active_time_stop_) {}

    , decltype(_impl_.firm_) {}

    , decltype(_impl_.display_name_) {}

    , decltype(_impl_.risk_details_) {}

    , decltype(_impl_.group_name_) {}

    , decltype(_impl_.enabled_) { 0 }

    , decltype(_impl_.max_clip_size_) { 0 }

    , decltype(_impl_.deleted_) { false }

    , decltype(_impl_.pre_trade_disabled_) { false }

    , decltype(_impl_.position_rollover_) { false }

    , decltype(_impl_.pl_rollover_) { false }

    , decltype(_impl_.margin_pc_) { 0 }

    , decltype(_impl_.min_balance_) { 0 }

    , decltype(_impl_.loss_limit_) { 0 }

    , decltype(_impl_.loss_limit_pc_) { 0 }

    , decltype(_impl_.overnight_margin_pc_) { 0 }

    , decltype(_impl_.warning_threshold_pl_) { 0 }

    , decltype(_impl_.warning_threshold_loss_limit_) { 0 }

    , decltype(_impl_.warning_threshold_margin_) { 0 }

    , decltype(_impl_.mode_) { 0 }

    , decltype(_impl_.day_loss_limit_) { 0 }

    , decltype(_impl_.max_account_position_) { 0 }

    , decltype(_impl_.wide_market_) { 0 }

    , decltype(_impl_.order_routing_) { false }

    , decltype(_impl_.use_pl_for_margin_) { false }

    , decltype(_impl_.options_settlement_) { false }

    , decltype(_impl_.use_premium_for_margin_) { false }

    , decltype(_impl_.margin_type_) { 0 }

    , decltype(_impl_.price_banding_) { 0 }

    , decltype(_impl_.day_loss_limit_pc_) { 0 }

    , decltype(_impl_.warning_threshold_min_net_equity_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.account_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.account_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.account_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.firm_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.firm_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.active_time_start_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.active_time_start_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.active_time_stop_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.active_time_stop_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.firm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.firm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.display_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.display_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.risk_details_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.risk_details_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.group_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.group_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AccountDetails::~AccountDetails() {
  // @@protoc_insertion_point(destructor:t4proto.v1.account.AccountDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AccountDetails::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.account_id_.Destroy();
  _impl_.account_name_.Destroy();
  _impl_.account_.Destroy();
  _impl_.firm_id_.Destroy();
  _impl_.active_time_start_.Destroy();
  _impl_.active_time_stop_.Destroy();
  _impl_.firm_.Destroy();
  _impl_.display_name_.Destroy();
  _impl_.risk_details_.Destroy();
  _impl_.group_name_.Destroy();
}

void AccountDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AccountDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:t4proto.v1.account.AccountDetails)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.account_id_.ClearToEmpty();
  _impl_.account_name_.ClearToEmpty();
  _impl_.account_.ClearToEmpty();
  _impl_.firm_id_.ClearToEmpty();
  _impl_.active_time_start_.ClearToEmpty();
  _impl_.active_time_stop_.ClearToEmpty();
  _impl_.firm_.ClearToEmpty();
  _impl_.display_name_.ClearToEmpty();
  _impl_.risk_details_.ClearToEmpty();
  _impl_.group_name_.ClearToEmpty();
  ::memset(&_impl_.enabled_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.warning_threshold_min_net_equity_) -
      reinterpret_cast<char*>(&_impl_.enabled_)) + sizeof(_impl_.warning_threshold_min_net_equity_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AccountDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_account_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "t4proto.v1.account.AccountDetails.account_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string account_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_account_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "t4proto.v1.account.AccountDetails.account_name"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string account = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_account();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "t4proto.v1.account.AccountDetails.account"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .t4proto.v1.common.AccountEnabled enabled = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_enabled(static_cast<::t4proto::v1::common::AccountEnabled>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool deleted = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.deleted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 max_clip_size = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.max_clip_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool pre_trade_disabled = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.pre_trade_disabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool position_rollover = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.position_rollover_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool pl_rollover = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _impl_.pl_rollover_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string firm_id = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_firm_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "t4proto.v1.account.AccountDetails.firm_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // double min_balance = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 89)) {
          _impl_.min_balance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 margin_pc = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 96)) {
          _impl_.margin_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // double loss_limit = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 105)) {
          _impl_.loss_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 loss_limit_pc = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
          _impl_.loss_limit_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 overnight_margin_pc = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 120)) {
          _impl_.overnight_margin_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool order_routing = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 128)) {
          _impl_.order_routing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string active_time_start = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 138)) {
          auto str = _internal_mutable_active_time_start();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "t4proto.v1.account.AccountDetails.active_time_start"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string active_time_stop = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 146)) {
          auto str = _internal_mutable_active_time_stop();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "t4proto.v1.account.AccountDetails.active_time_stop"));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 warning_threshold_pl = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 152)) {
          _impl_.warning_threshold_pl_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 warning_threshold_loss_limit = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 160)) {
          _impl_.warning_threshold_loss_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 warning_threshold_margin = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 168)) {
          _impl_.warning_threshold_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string firm = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 178)) {
          auto str = _internal_mutable_firm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "t4proto.v1.account.AccountDetails.firm"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .t4proto.v1.common.AccountMode mode = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 184)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_mode(static_cast<::t4proto::v1::common::AccountMode>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 max_account_position = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 192)) {
          _impl_.max_account_position_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // double day_loss_limit = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 201)) {
          _impl_.day_loss_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // string display_name = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 210)) {
          auto str = _internal_mutable_display_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "t4proto.v1.account.AccountDetails.display_name"));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 wide_market = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 216)) {
          _impl_.wide_market_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool use_pl_for_margin = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 224)) {
          _impl_.use_pl_for_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .t4proto.v1.common.AccountMarginType margin_type = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 232)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_margin_type(static_cast<::t4proto::v1::common::AccountMarginType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // string risk_details = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 242)) {
          auto str = _internal_mutable_risk_details();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "t4proto.v1.account.AccountDetails.risk_details"));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 price_banding = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 248)) {
          _impl_.price_banding_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 day_loss_limit_pc = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 0)) {
          _impl_.day_loss_limit_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool options_settlement = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.options_settlement_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string group_name = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_group_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "t4proto.v1.account.AccountDetails.group_name"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool use_premium_for_margin = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.use_premium_for_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // double warning_threshold_min_net_equity = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 33)) {
          _impl_.warning_threshold_min_net_equity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AccountDetails::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:t4proto.v1.account.AccountDetails)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string account_id = 1;
  if (!this->_internal_account_id().empty()) {
    const std::string& _s = this->_internal_account_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "t4proto.v1.account.AccountDetails.account_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string account_name = 2;
  if (!this->_internal_account_name().empty()) {
    const std::string& _s = this->_internal_account_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "t4proto.v1.account.AccountDetails.account_name");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string account = 3;
  if (!this->_internal_account().empty()) {
    const std::string& _s = this->_internal_account();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "t4proto.v1.account.AccountDetails.account");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // .t4proto.v1.common.AccountEnabled enabled = 4;
  if (this->_internal_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_enabled(), target);
  }

  // bool deleted = 5;
  if (this->_internal_deleted() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this->_internal_deleted(), target);
  }

  // int32 max_clip_size = 6;
  if (this->_internal_max_clip_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        6, this->_internal_max_clip_size(), target);
  }

  // bool pre_trade_disabled = 7;
  if (this->_internal_pre_trade_disabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        7, this->_internal_pre_trade_disabled(), target);
  }

  // bool position_rollover = 8;
  if (this->_internal_position_rollover() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this->_internal_position_rollover(), target);
  }

  // bool pl_rollover = 9;
  if (this->_internal_pl_rollover() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        9, this->_internal_pl_rollover(), target);
  }

  // string firm_id = 10;
  if (!this->_internal_firm_id().empty()) {
    const std::string& _s = this->_internal_firm_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "t4proto.v1.account.AccountDetails.firm_id");
    target = stream->WriteStringMaybeAliased(10, _s, target);
  }

  // double min_balance = 11;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_min_balance = this->_internal_min_balance();
  ::uint64_t raw_min_balance;
  memcpy(&raw_min_balance, &tmp_min_balance, sizeof(tmp_min_balance));
  if (raw_min_balance != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        11, this->_internal_min_balance(), target);
  }

  // int32 margin_pc = 12;
  if (this->_internal_margin_pc() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        12, this->_internal_margin_pc(), target);
  }

  // double loss_limit = 13;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_loss_limit = this->_internal_loss_limit();
  ::uint64_t raw_loss_limit;
  memcpy(&raw_loss_limit, &tmp_loss_limit, sizeof(tmp_loss_limit));
  if (raw_loss_limit != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        13, this->_internal_loss_limit(), target);
  }

  // int32 loss_limit_pc = 14;
  if (this->_internal_loss_limit_pc() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        14, this->_internal_loss_limit_pc(), target);
  }

  // int32 overnight_margin_pc = 15;
  if (this->_internal_overnight_margin_pc() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        15, this->_internal_overnight_margin_pc(), target);
  }

  // bool order_routing = 16;
  if (this->_internal_order_routing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        16, this->_internal_order_routing(), target);
  }

  // string active_time_start = 17;
  if (!this->_internal_active_time_start().empty()) {
    const std::string& _s = this->_internal_active_time_start();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "t4proto.v1.account.AccountDetails.active_time_start");
    target = stream->WriteStringMaybeAliased(17, _s, target);
  }

  // string active_time_stop = 18;
  if (!this->_internal_active_time_stop().empty()) {
    const std::string& _s = this->_internal_active_time_stop();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "t4proto.v1.account.AccountDetails.active_time_stop");
    target = stream->WriteStringMaybeAliased(18, _s, target);
  }

  // int32 warning_threshold_pl = 19;
  if (this->_internal_warning_threshold_pl() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        19, this->_internal_warning_threshold_pl(), target);
  }

  // int32 warning_threshold_loss_limit = 20;
  if (this->_internal_warning_threshold_loss_limit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        20, this->_internal_warning_threshold_loss_limit(), target);
  }

  // int32 warning_threshold_margin = 21;
  if (this->_internal_warning_threshold_margin() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        21, this->_internal_warning_threshold_margin(), target);
  }

  // string firm = 22;
  if (!this->_internal_firm().empty()) {
    const std::string& _s = this->_internal_firm();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "t4proto.v1.account.AccountDetails.firm");
    target = stream->WriteStringMaybeAliased(22, _s, target);
  }

  // .t4proto.v1.common.AccountMode mode = 23;
  if (this->_internal_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        23, this->_internal_mode(), target);
  }

  // int32 max_account_position = 24;
  if (this->_internal_max_account_position() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        24, this->_internal_max_account_position(), target);
  }

  // double day_loss_limit = 25;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_day_loss_limit = this->_internal_day_loss_limit();
  ::uint64_t raw_day_loss_limit;
  memcpy(&raw_day_loss_limit, &tmp_day_loss_limit, sizeof(tmp_day_loss_limit));
  if (raw_day_loss_limit != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        25, this->_internal_day_loss_limit(), target);
  }

  // string display_name = 26;
  if (!this->_internal_display_name().empty()) {
    const std::string& _s = this->_internal_display_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "t4proto.v1.account.AccountDetails.display_name");
    target = stream->WriteStringMaybeAliased(26, _s, target);
  }

  // int32 wide_market = 27;
  if (this->_internal_wide_market() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        27, this->_internal_wide_market(), target);
  }

  // bool use_pl_for_margin = 28;
  if (this->_internal_use_pl_for_margin() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        28, this->_internal_use_pl_for_margin(), target);
  }

  // .t4proto.v1.common.AccountMarginType margin_type = 29;
  if (this->_internal_margin_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        29, this->_internal_margin_type(), target);
  }

  // string risk_details = 30;
  if (!this->_internal_risk_details().empty()) {
    const std::string& _s = this->_internal_risk_details();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "t4proto.v1.account.AccountDetails.risk_details");
    target = stream->WriteStringMaybeAliased(30, _s, target);
  }

  // int32 price_banding = 31;
  if (this->_internal_price_banding() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        31, this->_internal_price_banding(), target);
  }

  // int32 day_loss_limit_pc = 32;
  if (this->_internal_day_loss_limit_pc() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        32, this->_internal_day_loss_limit_pc(), target);
  }

  // bool options_settlement = 33;
  if (this->_internal_options_settlement() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        33, this->_internal_options_settlement(), target);
  }

  // string group_name = 34;
  if (!this->_internal_group_name().empty()) {
    const std::string& _s = this->_internal_group_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "t4proto.v1.account.AccountDetails.group_name");
    target = stream->WriteStringMaybeAliased(34, _s, target);
  }

  // bool use_premium_for_margin = 35;
  if (this->_internal_use_premium_for_margin() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        35, this->_internal_use_premium_for_margin(), target);
  }

  // double warning_threshold_min_net_equity = 36;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_warning_threshold_min_net_equity = this->_internal_warning_threshold_min_net_equity();
  ::uint64_t raw_warning_threshold_min_net_equity;
  memcpy(&raw_warning_threshold_min_net_equity, &tmp_warning_threshold_min_net_equity, sizeof(tmp_warning_threshold_min_net_equity));
  if (raw_warning_threshold_min_net_equity != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        36, this->_internal_warning_threshold_min_net_equity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:t4proto.v1.account.AccountDetails)
  return target;
}

::size_t AccountDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:t4proto.v1.account.AccountDetails)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string account_id = 1;
  if (!this->_internal_account_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_account_id());
  }

  // string account_name = 2;
  if (!this->_internal_account_name().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_account_name());
  }

  // string account = 3;
  if (!this->_internal_account().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_account());
  }

  // string firm_id = 10;
  if (!this->_internal_firm_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_firm_id());
  }

  // string active_time_start = 17;
  if (!this->_internal_active_time_start().empty()) {
    total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_active_time_start());
  }

  // string active_time_stop = 18;
  if (!this->_internal_active_time_stop().empty()) {
    total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_active_time_stop());
  }

  // string firm = 22;
  if (!this->_internal_firm().empty()) {
    total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_firm());
  }

  // string display_name = 26;
  if (!this->_internal_display_name().empty()) {
    total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_display_name());
  }

  // string risk_details = 30;
  if (!this->_internal_risk_details().empty()) {
    total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_risk_details());
  }

  // string group_name = 34;
  if (!this->_internal_group_name().empty()) {
    total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_group_name());
  }

  // .t4proto.v1.common.AccountEnabled enabled = 4;
  if (this->_internal_enabled() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_enabled());
  }

  // int32 max_clip_size = 6;
  if (this->_internal_max_clip_size() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_max_clip_size());
  }

  // bool deleted = 5;
  if (this->_internal_deleted() != 0) {
    total_size += 2;
  }

  // bool pre_trade_disabled = 7;
  if (this->_internal_pre_trade_disabled() != 0) {
    total_size += 2;
  }

  // bool position_rollover = 8;
  if (this->_internal_position_rollover() != 0) {
    total_size += 2;
  }

  // bool pl_rollover = 9;
  if (this->_internal_pl_rollover() != 0) {
    total_size += 2;
  }

  // int32 margin_pc = 12;
  if (this->_internal_margin_pc() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_margin_pc());
  }

  // double min_balance = 11;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_min_balance = this->_internal_min_balance();
  ::uint64_t raw_min_balance;
  memcpy(&raw_min_balance, &tmp_min_balance, sizeof(tmp_min_balance));
  if (raw_min_balance != 0) {
    total_size += 9;
  }

  // double loss_limit = 13;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_loss_limit = this->_internal_loss_limit();
  ::uint64_t raw_loss_limit;
  memcpy(&raw_loss_limit, &tmp_loss_limit, sizeof(tmp_loss_limit));
  if (raw_loss_limit != 0) {
    total_size += 9;
  }

  // int32 loss_limit_pc = 14;
  if (this->_internal_loss_limit_pc() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_loss_limit_pc());
  }

  // int32 overnight_margin_pc = 15;
  if (this->_internal_overnight_margin_pc() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_overnight_margin_pc());
  }

  // int32 warning_threshold_pl = 19;
  if (this->_internal_warning_threshold_pl() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_warning_threshold_pl());
  }

  // int32 warning_threshold_loss_limit = 20;
  if (this->_internal_warning_threshold_loss_limit() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_warning_threshold_loss_limit());
  }

  // int32 warning_threshold_margin = 21;
  if (this->_internal_warning_threshold_margin() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_warning_threshold_margin());
  }

  // .t4proto.v1.common.AccountMode mode = 23;
  if (this->_internal_mode() != 0) {
    total_size += 2 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_mode());
  }

  // double day_loss_limit = 25;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_day_loss_limit = this->_internal_day_loss_limit();
  ::uint64_t raw_day_loss_limit;
  memcpy(&raw_day_loss_limit, &tmp_day_loss_limit, sizeof(tmp_day_loss_limit));
  if (raw_day_loss_limit != 0) {
    total_size += 10;
  }

  // int32 max_account_position = 24;
  if (this->_internal_max_account_position() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_max_account_position());
  }

  // int32 wide_market = 27;
  if (this->_internal_wide_market() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_wide_market());
  }

  // bool order_routing = 16;
  if (this->_internal_order_routing() != 0) {
    total_size += 3;
  }

  // bool use_pl_for_margin = 28;
  if (this->_internal_use_pl_for_margin() != 0) {
    total_size += 3;
  }

  // bool options_settlement = 33;
  if (this->_internal_options_settlement() != 0) {
    total_size += 3;
  }

  // bool use_premium_for_margin = 35;
  if (this->_internal_use_premium_for_margin() != 0) {
    total_size += 3;
  }

  // .t4proto.v1.common.AccountMarginType margin_type = 29;
  if (this->_internal_margin_type() != 0) {
    total_size += 2 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_margin_type());
  }

  // int32 price_banding = 31;
  if (this->_internal_price_banding() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_price_banding());
  }

  // int32 day_loss_limit_pc = 32;
  if (this->_internal_day_loss_limit_pc() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_day_loss_limit_pc());
  }

  // double warning_threshold_min_net_equity = 36;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_warning_threshold_min_net_equity = this->_internal_warning_threshold_min_net_equity();
  ::uint64_t raw_warning_threshold_min_net_equity;
  memcpy(&raw_warning_threshold_min_net_equity, &tmp_warning_threshold_min_net_equity, sizeof(tmp_warning_threshold_min_net_equity));
  if (raw_warning_threshold_min_net_equity != 0) {
    total_size += 10;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AccountDetails::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AccountDetails::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AccountDetails::GetClassData() const { return &_class_data_; }


void AccountDetails::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AccountDetails*>(&to_msg);
  auto& from = static_cast<const AccountDetails&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:t4proto.v1.account.AccountDetails)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_account_id().empty()) {
    _this->_internal_set_account_id(from._internal_account_id());
  }
  if (!from._internal_account_name().empty()) {
    _this->_internal_set_account_name(from._internal_account_name());
  }
  if (!from._internal_account().empty()) {
    _this->_internal_set_account(from._internal_account());
  }
  if (!from._internal_firm_id().empty()) {
    _this->_internal_set_firm_id(from._internal_firm_id());
  }
  if (!from._internal_active_time_start().empty()) {
    _this->_internal_set_active_time_start(from._internal_active_time_start());
  }
  if (!from._internal_active_time_stop().empty()) {
    _this->_internal_set_active_time_stop(from._internal_active_time_stop());
  }
  if (!from._internal_firm().empty()) {
    _this->_internal_set_firm(from._internal_firm());
  }
  if (!from._internal_display_name().empty()) {
    _this->_internal_set_display_name(from._internal_display_name());
  }
  if (!from._internal_risk_details().empty()) {
    _this->_internal_set_risk_details(from._internal_risk_details());
  }
  if (!from._internal_group_name().empty()) {
    _this->_internal_set_group_name(from._internal_group_name());
  }
  if (from._internal_enabled() != 0) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  if (from._internal_max_clip_size() != 0) {
    _this->_internal_set_max_clip_size(from._internal_max_clip_size());
  }
  if (from._internal_deleted() != 0) {
    _this->_internal_set_deleted(from._internal_deleted());
  }
  if (from._internal_pre_trade_disabled() != 0) {
    _this->_internal_set_pre_trade_disabled(from._internal_pre_trade_disabled());
  }
  if (from._internal_position_rollover() != 0) {
    _this->_internal_set_position_rollover(from._internal_position_rollover());
  }
  if (from._internal_pl_rollover() != 0) {
    _this->_internal_set_pl_rollover(from._internal_pl_rollover());
  }
  if (from._internal_margin_pc() != 0) {
    _this->_internal_set_margin_pc(from._internal_margin_pc());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_min_balance = from._internal_min_balance();
  ::uint64_t raw_min_balance;
  memcpy(&raw_min_balance, &tmp_min_balance, sizeof(tmp_min_balance));
  if (raw_min_balance != 0) {
    _this->_internal_set_min_balance(from._internal_min_balance());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_loss_limit = from._internal_loss_limit();
  ::uint64_t raw_loss_limit;
  memcpy(&raw_loss_limit, &tmp_loss_limit, sizeof(tmp_loss_limit));
  if (raw_loss_limit != 0) {
    _this->_internal_set_loss_limit(from._internal_loss_limit());
  }
  if (from._internal_loss_limit_pc() != 0) {
    _this->_internal_set_loss_limit_pc(from._internal_loss_limit_pc());
  }
  if (from._internal_overnight_margin_pc() != 0) {
    _this->_internal_set_overnight_margin_pc(from._internal_overnight_margin_pc());
  }
  if (from._internal_warning_threshold_pl() != 0) {
    _this->_internal_set_warning_threshold_pl(from._internal_warning_threshold_pl());
  }
  if (from._internal_warning_threshold_loss_limit() != 0) {
    _this->_internal_set_warning_threshold_loss_limit(from._internal_warning_threshold_loss_limit());
  }
  if (from._internal_warning_threshold_margin() != 0) {
    _this->_internal_set_warning_threshold_margin(from._internal_warning_threshold_margin());
  }
  if (from._internal_mode() != 0) {
    _this->_internal_set_mode(from._internal_mode());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_day_loss_limit = from._internal_day_loss_limit();
  ::uint64_t raw_day_loss_limit;
  memcpy(&raw_day_loss_limit, &tmp_day_loss_limit, sizeof(tmp_day_loss_limit));
  if (raw_day_loss_limit != 0) {
    _this->_internal_set_day_loss_limit(from._internal_day_loss_limit());
  }
  if (from._internal_max_account_position() != 0) {
    _this->_internal_set_max_account_position(from._internal_max_account_position());
  }
  if (from._internal_wide_market() != 0) {
    _this->_internal_set_wide_market(from._internal_wide_market());
  }
  if (from._internal_order_routing() != 0) {
    _this->_internal_set_order_routing(from._internal_order_routing());
  }
  if (from._internal_use_pl_for_margin() != 0) {
    _this->_internal_set_use_pl_for_margin(from._internal_use_pl_for_margin());
  }
  if (from._internal_options_settlement() != 0) {
    _this->_internal_set_options_settlement(from._internal_options_settlement());
  }
  if (from._internal_use_premium_for_margin() != 0) {
    _this->_internal_set_use_premium_for_margin(from._internal_use_premium_for_margin());
  }
  if (from._internal_margin_type() != 0) {
    _this->_internal_set_margin_type(from._internal_margin_type());
  }
  if (from._internal_price_banding() != 0) {
    _this->_internal_set_price_banding(from._internal_price_banding());
  }
  if (from._internal_day_loss_limit_pc() != 0) {
    _this->_internal_set_day_loss_limit_pc(from._internal_day_loss_limit_pc());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_warning_threshold_min_net_equity = from._internal_warning_threshold_min_net_equity();
  ::uint64_t raw_warning_threshold_min_net_equity;
  memcpy(&raw_warning_threshold_min_net_equity, &tmp_warning_threshold_min_net_equity, sizeof(tmp_warning_threshold_min_net_equity));
  if (raw_warning_threshold_min_net_equity != 0) {
    _this->_internal_set_warning_threshold_min_net_equity(from._internal_warning_threshold_min_net_equity());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AccountDetails::CopyFrom(const AccountDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:t4proto.v1.account.AccountDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountDetails::IsInitialized() const {
  return true;
}

void AccountDetails::InternalSwap(AccountDetails* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.account_id_, lhs_arena,
                                       &other->_impl_.account_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.account_name_, lhs_arena,
                                       &other->_impl_.account_name_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.account_, lhs_arena,
                                       &other->_impl_.account_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.firm_id_, lhs_arena,
                                       &other->_impl_.firm_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.active_time_start_, lhs_arena,
                                       &other->_impl_.active_time_start_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.active_time_stop_, lhs_arena,
                                       &other->_impl_.active_time_stop_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.firm_, lhs_arena,
                                       &other->_impl_.firm_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.display_name_, lhs_arena,
                                       &other->_impl_.display_name_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.risk_details_, lhs_arena,
                                       &other->_impl_.risk_details_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.group_name_, lhs_arena,
                                       &other->_impl_.group_name_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AccountDetails, _impl_.warning_threshold_min_net_equity_)
      + sizeof(AccountDetails::_impl_.warning_threshold_min_net_equity_)
      - PROTOBUF_FIELD_OFFSET(AccountDetails, _impl_.enabled_)>(
          reinterpret_cast<char*>(&_impl_.enabled_),
          reinterpret_cast<char*>(&other->_impl_.enabled_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AccountDetails::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_t4_2fv1_2faccount_2faccount_2eproto_getter, &descriptor_table_t4_2fv1_2faccount_2faccount_2eproto_once,
      file_level_metadata_t4_2fv1_2faccount_2faccount_2eproto[5]);
}
// ===================================================================

class AccountSnapshotMessage::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::t4proto::v1::account::AccountSnapshotMessage, _impl_._oneof_case_);
  static const ::t4proto::v1::account::AccountPosition& account_position(const AccountSnapshotMessage* msg);
  static const ::t4proto::v1::account::AccountUpdate& account_update(const AccountSnapshotMessage* msg);
  static const ::t4proto::v1::account::AccountDetails& account_details(const AccountSnapshotMessage* msg);
  static const ::t4proto::v1::account::AccountCurrency& account_currency(const AccountSnapshotMessage* msg);
  static const ::t4proto::v1::market::MarketDetails& market_details(const AccountSnapshotMessage* msg);
  static const ::t4proto::v1::orderrouting::OrderUpdateMulti& order_update_multi(const AccountSnapshotMessage* msg);
};

const ::t4proto::v1::account::AccountPosition&
AccountSnapshotMessage::_Internal::account_position(const AccountSnapshotMessage* msg) {
  return *msg->_impl_.payload_.account_position_;
}
const ::t4proto::v1::account::AccountUpdate&
AccountSnapshotMessage::_Internal::account_update(const AccountSnapshotMessage* msg) {
  return *msg->_impl_.payload_.account_update_;
}
const ::t4proto::v1::account::AccountDetails&
AccountSnapshotMessage::_Internal::account_details(const AccountSnapshotMessage* msg) {
  return *msg->_impl_.payload_.account_details_;
}
const ::t4proto::v1::account::AccountCurrency&
AccountSnapshotMessage::_Internal::account_currency(const AccountSnapshotMessage* msg) {
  return *msg->_impl_.payload_.account_currency_;
}
const ::t4proto::v1::market::MarketDetails&
AccountSnapshotMessage::_Internal::market_details(const AccountSnapshotMessage* msg) {
  return *msg->_impl_.payload_.market_details_;
}
const ::t4proto::v1::orderrouting::OrderUpdateMulti&
AccountSnapshotMessage::_Internal::order_update_multi(const AccountSnapshotMessage* msg) {
  return *msg->_impl_.payload_.order_update_multi_;
}
void AccountSnapshotMessage::set_allocated_account_position(::t4proto::v1::account::AccountPosition* account_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (account_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(account_position);
    if (message_arena != submessage_arena) {
      account_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account_position, submessage_arena);
    }
    set_has_account_position();
    _impl_.payload_.account_position_ = account_position;
  }
  // @@protoc_insertion_point(field_set_allocated:t4proto.v1.account.AccountSnapshotMessage.account_position)
}
void AccountSnapshotMessage::set_allocated_account_update(::t4proto::v1::account::AccountUpdate* account_update) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (account_update) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(account_update);
    if (message_arena != submessage_arena) {
      account_update = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account_update, submessage_arena);
    }
    set_has_account_update();
    _impl_.payload_.account_update_ = account_update;
  }
  // @@protoc_insertion_point(field_set_allocated:t4proto.v1.account.AccountSnapshotMessage.account_update)
}
void AccountSnapshotMessage::set_allocated_account_details(::t4proto::v1::account::AccountDetails* account_details) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (account_details) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(account_details);
    if (message_arena != submessage_arena) {
      account_details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account_details, submessage_arena);
    }
    set_has_account_details();
    _impl_.payload_.account_details_ = account_details;
  }
  // @@protoc_insertion_point(field_set_allocated:t4proto.v1.account.AccountSnapshotMessage.account_details)
}
void AccountSnapshotMessage::set_allocated_account_currency(::t4proto::v1::account::AccountCurrency* account_currency) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (account_currency) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(account_currency);
    if (message_arena != submessage_arena) {
      account_currency = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account_currency, submessage_arena);
    }
    set_has_account_currency();
    _impl_.payload_.account_currency_ = account_currency;
  }
  // @@protoc_insertion_point(field_set_allocated:t4proto.v1.account.AccountSnapshotMessage.account_currency)
}
void AccountSnapshotMessage::set_allocated_market_details(::t4proto::v1::market::MarketDetails* market_details) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (market_details) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(market_details));
    if (message_arena != submessage_arena) {
      market_details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market_details, submessage_arena);
    }
    set_has_market_details();
    _impl_.payload_.market_details_ = market_details;
  }
  // @@protoc_insertion_point(field_set_allocated:t4proto.v1.account.AccountSnapshotMessage.market_details)
}
void AccountSnapshotMessage::clear_market_details() {
  if (payload_case() == kMarketDetails) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.market_details_;
    }
    clear_has_payload();
  }
}
void AccountSnapshotMessage::set_allocated_order_update_multi(::t4proto::v1::orderrouting::OrderUpdateMulti* order_update_multi) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (order_update_multi) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(order_update_multi));
    if (message_arena != submessage_arena) {
      order_update_multi = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order_update_multi, submessage_arena);
    }
    set_has_order_update_multi();
    _impl_.payload_.order_update_multi_ = order_update_multi;
  }
  // @@protoc_insertion_point(field_set_allocated:t4proto.v1.account.AccountSnapshotMessage.order_update_multi)
}
void AccountSnapshotMessage::clear_order_update_multi() {
  if (payload_case() == kOrderUpdateMulti) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.order_update_multi_;
    }
    clear_has_payload();
  }
}
AccountSnapshotMessage::AccountSnapshotMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:t4proto.v1.account.AccountSnapshotMessage)
}
AccountSnapshotMessage::AccountSnapshotMessage(const AccountSnapshotMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AccountSnapshotMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.payload_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_payload();
  switch (from.payload_case()) {
    case kAccountPosition: {
      _this->_internal_mutable_account_position()->::t4proto::v1::account::AccountPosition::MergeFrom(
          from._internal_account_position());
      break;
    }
    case kAccountUpdate: {
      _this->_internal_mutable_account_update()->::t4proto::v1::account::AccountUpdate::MergeFrom(
          from._internal_account_update());
      break;
    }
    case kAccountDetails: {
      _this->_internal_mutable_account_details()->::t4proto::v1::account::AccountDetails::MergeFrom(
          from._internal_account_details());
      break;
    }
    case kAccountCurrency: {
      _this->_internal_mutable_account_currency()->::t4proto::v1::account::AccountCurrency::MergeFrom(
          from._internal_account_currency());
      break;
    }
    case kMarketDetails: {
      _this->_internal_mutable_market_details()->::t4proto::v1::market::MarketDetails::MergeFrom(
          from._internal_market_details());
      break;
    }
    case kOrderUpdateMulti: {
      _this->_internal_mutable_order_update_multi()->::t4proto::v1::orderrouting::OrderUpdateMulti::MergeFrom(
          from._internal_order_update_multi());
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:t4proto.v1.account.AccountSnapshotMessage)
}

inline void AccountSnapshotMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.payload_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_payload();
}

AccountSnapshotMessage::~AccountSnapshotMessage() {
  // @@protoc_insertion_point(destructor:t4proto.v1.account.AccountSnapshotMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AccountSnapshotMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_payload()) {
    clear_payload();
  }
}

void AccountSnapshotMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AccountSnapshotMessage::clear_payload() {
// @@protoc_insertion_point(one_of_clear_start:t4proto.v1.account.AccountSnapshotMessage)
  switch (payload_case()) {
    case kAccountPosition: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.account_position_;
      }
      break;
    }
    case kAccountUpdate: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.account_update_;
      }
      break;
    }
    case kAccountDetails: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.account_details_;
      }
      break;
    }
    case kAccountCurrency: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.account_currency_;
      }
      break;
    }
    case kMarketDetails: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.market_details_;
      }
      break;
    }
    case kOrderUpdateMulti: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.order_update_multi_;
      }
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}


void AccountSnapshotMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:t4proto.v1.account.AccountSnapshotMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_payload();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AccountSnapshotMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .t4proto.v1.account.AccountPosition account_position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_account_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .t4proto.v1.account.AccountUpdate account_update = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_account_update(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .t4proto.v1.account.AccountDetails account_details = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_account_details(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .t4proto.v1.account.AccountCurrency account_currency = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_account_currency(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .t4proto.v1.market.MarketDetails market_details = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_market_details(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .t4proto.v1.orderrouting.OrderUpdateMulti order_update_multi = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_order_update_multi(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AccountSnapshotMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:t4proto.v1.account.AccountSnapshotMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .t4proto.v1.account.AccountPosition account_position = 3;
  if (payload_case() == kAccountPosition) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::account_position(this),
        _Internal::account_position(this).GetCachedSize(), target, stream);
  }

  // .t4proto.v1.account.AccountUpdate account_update = 4;
  if (payload_case() == kAccountUpdate) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::account_update(this),
        _Internal::account_update(this).GetCachedSize(), target, stream);
  }

  // .t4proto.v1.account.AccountDetails account_details = 5;
  if (payload_case() == kAccountDetails) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::account_details(this),
        _Internal::account_details(this).GetCachedSize(), target, stream);
  }

  // .t4proto.v1.account.AccountCurrency account_currency = 6;
  if (payload_case() == kAccountCurrency) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::account_currency(this),
        _Internal::account_currency(this).GetCachedSize(), target, stream);
  }

  // .t4proto.v1.market.MarketDetails market_details = 7;
  if (payload_case() == kMarketDetails) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::market_details(this),
        _Internal::market_details(this).GetCachedSize(), target, stream);
  }

  // .t4proto.v1.orderrouting.OrderUpdateMulti order_update_multi = 8;
  if (payload_case() == kOrderUpdateMulti) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::order_update_multi(this),
        _Internal::order_update_multi(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:t4proto.v1.account.AccountSnapshotMessage)
  return target;
}

::size_t AccountSnapshotMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:t4proto.v1.account.AccountSnapshotMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (payload_case()) {
    // .t4proto.v1.account.AccountPosition account_position = 3;
    case kAccountPosition: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.account_position_);
      break;
    }
    // .t4proto.v1.account.AccountUpdate account_update = 4;
    case kAccountUpdate: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.account_update_);
      break;
    }
    // .t4proto.v1.account.AccountDetails account_details = 5;
    case kAccountDetails: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.account_details_);
      break;
    }
    // .t4proto.v1.account.AccountCurrency account_currency = 6;
    case kAccountCurrency: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.account_currency_);
      break;
    }
    // .t4proto.v1.market.MarketDetails market_details = 7;
    case kMarketDetails: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.market_details_);
      break;
    }
    // .t4proto.v1.orderrouting.OrderUpdateMulti order_update_multi = 8;
    case kOrderUpdateMulti: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.order_update_multi_);
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AccountSnapshotMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AccountSnapshotMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AccountSnapshotMessage::GetClassData() const { return &_class_data_; }


void AccountSnapshotMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AccountSnapshotMessage*>(&to_msg);
  auto& from = static_cast<const AccountSnapshotMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:t4proto.v1.account.AccountSnapshotMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.payload_case()) {
    case kAccountPosition: {
      _this->_internal_mutable_account_position()->::t4proto::v1::account::AccountPosition::MergeFrom(
          from._internal_account_position());
      break;
    }
    case kAccountUpdate: {
      _this->_internal_mutable_account_update()->::t4proto::v1::account::AccountUpdate::MergeFrom(
          from._internal_account_update());
      break;
    }
    case kAccountDetails: {
      _this->_internal_mutable_account_details()->::t4proto::v1::account::AccountDetails::MergeFrom(
          from._internal_account_details());
      break;
    }
    case kAccountCurrency: {
      _this->_internal_mutable_account_currency()->::t4proto::v1::account::AccountCurrency::MergeFrom(
          from._internal_account_currency());
      break;
    }
    case kMarketDetails: {
      _this->_internal_mutable_market_details()->::t4proto::v1::market::MarketDetails::MergeFrom(
          from._internal_market_details());
      break;
    }
    case kOrderUpdateMulti: {
      _this->_internal_mutable_order_update_multi()->::t4proto::v1::orderrouting::OrderUpdateMulti::MergeFrom(
          from._internal_order_update_multi());
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AccountSnapshotMessage::CopyFrom(const AccountSnapshotMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:t4proto.v1.account.AccountSnapshotMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountSnapshotMessage::IsInitialized() const {
  return true;
}

void AccountSnapshotMessage::InternalSwap(AccountSnapshotMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.payload_, other->_impl_.payload_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata AccountSnapshotMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_t4_2fv1_2faccount_2faccount_2eproto_getter, &descriptor_table_t4_2fv1_2faccount_2faccount_2eproto_once,
      file_level_metadata_t4_2fv1_2faccount_2faccount_2eproto[6]);
}
// ===================================================================

class AccountSnapshot::_Internal {
 public:
};

AccountSnapshot::AccountSnapshot(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:t4proto.v1.account.AccountSnapshot)
}
AccountSnapshot::AccountSnapshot(const AccountSnapshot& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AccountSnapshot* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.messages_){from._impl_.messages_}
    , decltype(_impl_.account_id_) {}

    , decltype(_impl_.last_update_requested_) {}

    , decltype(_impl_.last_update_supplied_) {}

    , decltype(_impl_.status_) {}

    , decltype(_impl_.due_to_connection_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.account_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_account_id().empty()) {
    _this->_impl_.account_id_.Set(from._internal_account_id(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.last_update_requested_, &from._impl_.last_update_requested_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.due_to_connection_) -
    reinterpret_cast<char*>(&_impl_.last_update_requested_)) + sizeof(_impl_.due_to_connection_));
  // @@protoc_insertion_point(copy_constructor:t4proto.v1.account.AccountSnapshot)
}

inline void AccountSnapshot::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.messages_){arena}
    , decltype(_impl_.account_id_) {}

    , decltype(_impl_.last_update_requested_) { ::int64_t{0} }

    , decltype(_impl_.last_update_supplied_) { ::int64_t{0} }

    , decltype(_impl_.status_) { 0 }

    , decltype(_impl_.due_to_connection_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.account_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AccountSnapshot::~AccountSnapshot() {
  // @@protoc_insertion_point(destructor:t4proto.v1.account.AccountSnapshot)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AccountSnapshot::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.messages_.~RepeatedPtrField();
  _impl_.account_id_.Destroy();
}

void AccountSnapshot::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AccountSnapshot::Clear() {
// @@protoc_insertion_point(message_clear_start:t4proto.v1.account.AccountSnapshot)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.messages_.Clear();
  _impl_.account_id_.ClearToEmpty();
  ::memset(&_impl_.last_update_requested_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.due_to_connection_) -
      reinterpret_cast<char*>(&_impl_.last_update_requested_)) + sizeof(_impl_.due_to_connection_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AccountSnapshot::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_account_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "t4proto.v1.account.AccountSnapshot.account_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 last_update_requested = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.last_update_requested_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 last_update_supplied = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.last_update_supplied_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .t4proto.v1.common.AccountStatus status = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_status(static_cast<::t4proto::v1::common::AccountStatus>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool due_to_connection = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.due_to_connection_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .t4proto.v1.account.AccountSnapshotMessage messages = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_messages(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AccountSnapshot::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:t4proto.v1.account.AccountSnapshot)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string account_id = 1;
  if (!this->_internal_account_id().empty()) {
    const std::string& _s = this->_internal_account_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "t4proto.v1.account.AccountSnapshot.account_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // int64 last_update_requested = 2;
  if (this->_internal_last_update_requested() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_last_update_requested(), target);
  }

  // int64 last_update_supplied = 3;
  if (this->_internal_last_update_supplied() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_last_update_supplied(), target);
  }

  // .t4proto.v1.common.AccountStatus status = 4;
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_status(), target);
  }

  // bool due_to_connection = 5;
  if (this->_internal_due_to_connection() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this->_internal_due_to_connection(), target);
  }

  // repeated .t4proto.v1.account.AccountSnapshotMessage messages = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_messages_size()); i < n; i++) {
    const auto& repfield = this->_internal_messages(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:t4proto.v1.account.AccountSnapshot)
  return target;
}

::size_t AccountSnapshot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:t4proto.v1.account.AccountSnapshot)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .t4proto.v1.account.AccountSnapshotMessage messages = 6;
  total_size += 1UL * this->_internal_messages_size();
  for (const auto& msg : this->_impl_.messages_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string account_id = 1;
  if (!this->_internal_account_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_account_id());
  }

  // int64 last_update_requested = 2;
  if (this->_internal_last_update_requested() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_last_update_requested());
  }

  // int64 last_update_supplied = 3;
  if (this->_internal_last_update_supplied() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_last_update_supplied());
  }

  // .t4proto.v1.common.AccountStatus status = 4;
  if (this->_internal_status() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
  }

  // bool due_to_connection = 5;
  if (this->_internal_due_to_connection() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AccountSnapshot::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AccountSnapshot::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AccountSnapshot::GetClassData() const { return &_class_data_; }


void AccountSnapshot::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AccountSnapshot*>(&to_msg);
  auto& from = static_cast<const AccountSnapshot&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:t4proto.v1.account.AccountSnapshot)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.messages_.MergeFrom(from._impl_.messages_);
  if (!from._internal_account_id().empty()) {
    _this->_internal_set_account_id(from._internal_account_id());
  }
  if (from._internal_last_update_requested() != 0) {
    _this->_internal_set_last_update_requested(from._internal_last_update_requested());
  }
  if (from._internal_last_update_supplied() != 0) {
    _this->_internal_set_last_update_supplied(from._internal_last_update_supplied());
  }
  if (from._internal_status() != 0) {
    _this->_internal_set_status(from._internal_status());
  }
  if (from._internal_due_to_connection() != 0) {
    _this->_internal_set_due_to_connection(from._internal_due_to_connection());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AccountSnapshot::CopyFrom(const AccountSnapshot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:t4proto.v1.account.AccountSnapshot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountSnapshot::IsInitialized() const {
  return true;
}

void AccountSnapshot::InternalSwap(AccountSnapshot* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.messages_.InternalSwap(&other->_impl_.messages_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.account_id_, lhs_arena,
                                       &other->_impl_.account_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AccountSnapshot, _impl_.due_to_connection_)
      + sizeof(AccountSnapshot::_impl_.due_to_connection_)
      - PROTOBUF_FIELD_OFFSET(AccountSnapshot, _impl_.last_update_requested_)>(
          reinterpret_cast<char*>(&_impl_.last_update_requested_),
          reinterpret_cast<char*>(&other->_impl_.last_update_requested_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AccountSnapshot::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_t4_2fv1_2faccount_2faccount_2eproto_getter, &descriptor_table_t4_2fv1_2faccount_2faccount_2eproto_once,
      file_level_metadata_t4_2fv1_2faccount_2faccount_2eproto[7]);
}
// ===================================================================

class AccountProfit::_Internal {
 public:
  using HasBits = decltype(std::declval<AccountProfit>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AccountProfit, _impl_._has_bits_);
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& update_time(const AccountProfit* msg);
  static void set_has_upl(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_upl_trade(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rpl(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_day_upl(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_day_upl_trade(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_day_rpl(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_warning_pl(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_warning_loss_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_warning_margin(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_total_working_orders(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_total_working_volume(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_is_alerting_live_margin(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_is_alerting_full_margin(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
};

const ::PROTOBUF_NAMESPACE_ID::Timestamp&
AccountProfit::_Internal::update_time(const AccountProfit* msg) {
  return *msg->_impl_.update_time_;
}
void AccountProfit::clear_update_time() {
  if (GetArenaForAllocation() == nullptr && _impl_.update_time_ != nullptr) {
    delete _impl_.update_time_;
  }
  _impl_.update_time_ = nullptr;
}
AccountProfit::AccountProfit(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:t4proto.v1.account.AccountProfit)
}
AccountProfit::AccountProfit(const AccountProfit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AccountProfit* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_) {}

    , decltype(_impl_.update_time_){nullptr}
    , decltype(_impl_.upl_) {}

    , decltype(_impl_.upl_trade_) {}

    , decltype(_impl_.rpl_) {}

    , decltype(_impl_.day_upl_) {}

    , decltype(_impl_.day_upl_trade_) {}

    , decltype(_impl_.day_rpl_) {}

    , decltype(_impl_.warning_pl_) {}

    , decltype(_impl_.warning_loss_limit_) {}

    , decltype(_impl_.warning_margin_) {}

    , decltype(_impl_.total_working_orders_) {}

    , decltype(_impl_.total_working_volume_) {}

    , decltype(_impl_.is_alerting_live_margin_) {}

    , decltype(_impl_.is_alerting_full_margin_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.account_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_account_id().empty()) {
    _this->_impl_.account_id_.Set(from._internal_account_id(), _this->GetArenaForAllocation());
  }
  if (from._internal_has_update_time()) {
    _this->_impl_.update_time_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.update_time_);
  }
  ::memcpy(&_impl_.upl_, &from._impl_.upl_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.is_alerting_full_margin_) -
    reinterpret_cast<char*>(&_impl_.upl_)) + sizeof(_impl_.is_alerting_full_margin_));
  // @@protoc_insertion_point(copy_constructor:t4proto.v1.account.AccountProfit)
}

inline void AccountProfit::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_) {}

    , decltype(_impl_.update_time_){nullptr}
    , decltype(_impl_.upl_) { 0 }

    , decltype(_impl_.upl_trade_) { 0 }

    , decltype(_impl_.rpl_) { 0 }

    , decltype(_impl_.day_upl_) { 0 }

    , decltype(_impl_.day_upl_trade_) { 0 }

    , decltype(_impl_.day_rpl_) { 0 }

    , decltype(_impl_.warning_pl_) { 0 }

    , decltype(_impl_.warning_loss_limit_) { 0 }

    , decltype(_impl_.warning_margin_) { 0 }

    , decltype(_impl_.total_working_orders_) { 0 }

    , decltype(_impl_.total_working_volume_) { 0 }

    , decltype(_impl_.is_alerting_live_margin_) { false }

    , decltype(_impl_.is_alerting_full_margin_) { false }

  };
  _impl_.account_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AccountProfit::~AccountProfit() {
  // @@protoc_insertion_point(destructor:t4proto.v1.account.AccountProfit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AccountProfit::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.account_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.update_time_;
}

void AccountProfit::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AccountProfit::Clear() {
// @@protoc_insertion_point(message_clear_start:t4proto.v1.account.AccountProfit)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.account_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.update_time_ != nullptr) {
    delete _impl_.update_time_;
  }
  _impl_.update_time_ = nullptr;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.upl_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.warning_loss_limit_) -
        reinterpret_cast<char*>(&_impl_.upl_)) + sizeof(_impl_.warning_loss_limit_));
  }
  if (cached_has_bits & 0x00001f00u) {
    ::memset(&_impl_.warning_margin_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.is_alerting_full_margin_) -
        reinterpret_cast<char*>(&_impl_.warning_margin_)) + sizeof(_impl_.is_alerting_full_margin_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AccountProfit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_account_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "t4proto.v1.account.AccountProfit.account_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.Timestamp update_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_update_time(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double upl = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 25)) {
          _Internal::set_has_upl(&has_bits);
          _impl_.upl_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double upl_trade = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 33)) {
          _Internal::set_has_upl_trade(&has_bits);
          _impl_.upl_trade_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double rpl = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 41)) {
          _Internal::set_has_rpl(&has_bits);
          _impl_.rpl_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double day_upl = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 49)) {
          _Internal::set_has_day_upl(&has_bits);
          _impl_.day_upl_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double day_upl_trade = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 57)) {
          _Internal::set_has_day_upl_trade(&has_bits);
          _impl_.day_upl_trade_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double day_rpl = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 65)) {
          _Internal::set_has_day_rpl(&has_bits);
          _impl_.day_rpl_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 warning_pl = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _Internal::set_has_warning_pl(&has_bits);
          _impl_.warning_pl_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 warning_loss_limit = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _Internal::set_has_warning_loss_limit(&has_bits);
          _impl_.warning_loss_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 warning_margin = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
          _Internal::set_has_warning_margin(&has_bits);
          _impl_.warning_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 total_working_orders = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 96)) {
          _Internal::set_has_total_working_orders(&has_bits);
          _impl_.total_working_orders_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 total_working_volume = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 104)) {
          _Internal::set_has_total_working_volume(&has_bits);
          _impl_.total_working_volume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool is_alerting_live_margin = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
          _Internal::set_has_is_alerting_live_margin(&has_bits);
          _impl_.is_alerting_live_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool is_alerting_full_margin = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 120)) {
          _Internal::set_has_is_alerting_full_margin(&has_bits);
          _impl_.is_alerting_full_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AccountProfit::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:t4proto.v1.account.AccountProfit)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string account_id = 1;
  if (!this->_internal_account_id().empty()) {
    const std::string& _s = this->_internal_account_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "t4proto.v1.account.AccountProfit.account_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // .google.protobuf.Timestamp update_time = 2;
  if (this->_internal_has_update_time()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::update_time(this),
        _Internal::update_time(this).GetCachedSize(), target, stream);
  }

  // optional double upl = 3;
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_upl(), target);
  }

  // optional double upl_trade = 4;
  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_upl_trade(), target);
  }

  // optional double rpl = 5;
  if ((_impl_._has_bits_[0] & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        5, this->_internal_rpl(), target);
  }

  // optional double day_upl = 6;
  if ((_impl_._has_bits_[0] & 0x00000008u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        6, this->_internal_day_upl(), target);
  }

  // optional double day_upl_trade = 7;
  if ((_impl_._has_bits_[0] & 0x00000010u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        7, this->_internal_day_upl_trade(), target);
  }

  // optional double day_rpl = 8;
  if ((_impl_._has_bits_[0] & 0x00000020u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        8, this->_internal_day_rpl(), target);
  }

  // optional int32 warning_pl = 9;
  if ((_impl_._has_bits_[0] & 0x00000040u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        9, this->_internal_warning_pl(), target);
  }

  // optional int32 warning_loss_limit = 10;
  if ((_impl_._has_bits_[0] & 0x00000080u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        10, this->_internal_warning_loss_limit(), target);
  }

  // optional int32 warning_margin = 11;
  if ((_impl_._has_bits_[0] & 0x00000100u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        11, this->_internal_warning_margin(), target);
  }

  // optional int32 total_working_orders = 12;
  if ((_impl_._has_bits_[0] & 0x00000200u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        12, this->_internal_total_working_orders(), target);
  }

  // optional int32 total_working_volume = 13;
  if ((_impl_._has_bits_[0] & 0x00000400u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        13, this->_internal_total_working_volume(), target);
  }

  // optional bool is_alerting_live_margin = 14;
  if ((_impl_._has_bits_[0] & 0x00000800u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        14, this->_internal_is_alerting_live_margin(), target);
  }

  // optional bool is_alerting_full_margin = 15;
  if ((_impl_._has_bits_[0] & 0x00001000u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        15, this->_internal_is_alerting_full_margin(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:t4proto.v1.account.AccountProfit)
  return target;
}

::size_t AccountProfit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:t4proto.v1.account.AccountProfit)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string account_id = 1;
  if (!this->_internal_account_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_account_id());
  }

  // .google.protobuf.Timestamp update_time = 2;
  if (this->_internal_has_update_time()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.update_time_);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional double upl = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 9;
    }

    // optional double upl_trade = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 9;
    }

    // optional double rpl = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 9;
    }

    // optional double day_upl = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 9;
    }

    // optional double day_upl_trade = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 9;
    }

    // optional double day_rpl = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 9;
    }

    // optional int32 warning_pl = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_warning_pl());
    }

    // optional int32 warning_loss_limit = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_warning_loss_limit());
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // optional int32 warning_margin = 11;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_warning_margin());
    }

    // optional int32 total_working_orders = 12;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_total_working_orders());
    }

    // optional int32 total_working_volume = 13;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_total_working_volume());
    }

    // optional bool is_alerting_live_margin = 14;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2;
    }

    // optional bool is_alerting_full_margin = 15;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AccountProfit::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AccountProfit::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AccountProfit::GetClassData() const { return &_class_data_; }


void AccountProfit::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AccountProfit*>(&to_msg);
  auto& from = static_cast<const AccountProfit&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:t4proto.v1.account.AccountProfit)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_account_id().empty()) {
    _this->_internal_set_account_id(from._internal_account_id());
  }
  if (from._internal_has_update_time()) {
    _this->_internal_mutable_update_time()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_update_time());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.upl_ = from._impl_.upl_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.upl_trade_ = from._impl_.upl_trade_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.rpl_ = from._impl_.rpl_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.day_upl_ = from._impl_.day_upl_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.day_upl_trade_ = from._impl_.day_upl_trade_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.day_rpl_ = from._impl_.day_rpl_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.warning_pl_ = from._impl_.warning_pl_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.warning_loss_limit_ = from._impl_.warning_loss_limit_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.warning_margin_ = from._impl_.warning_margin_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.total_working_orders_ = from._impl_.total_working_orders_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.total_working_volume_ = from._impl_.total_working_volume_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.is_alerting_live_margin_ = from._impl_.is_alerting_live_margin_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.is_alerting_full_margin_ = from._impl_.is_alerting_full_margin_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AccountProfit::CopyFrom(const AccountProfit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:t4proto.v1.account.AccountProfit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountProfit::IsInitialized() const {
  return true;
}

void AccountProfit::InternalSwap(AccountProfit* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.account_id_, lhs_arena,
                                       &other->_impl_.account_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AccountProfit, _impl_.is_alerting_full_margin_)
      + sizeof(AccountProfit::_impl_.is_alerting_full_margin_)
      - PROTOBUF_FIELD_OFFSET(AccountProfit, _impl_.update_time_)>(
          reinterpret_cast<char*>(&_impl_.update_time_),
          reinterpret_cast<char*>(&other->_impl_.update_time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AccountProfit::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_t4_2fv1_2faccount_2faccount_2eproto_getter, &descriptor_table_t4_2fv1_2faccount_2faccount_2eproto_once,
      file_level_metadata_t4_2fv1_2faccount_2faccount_2eproto[8]);
}
// ===================================================================

class AccountPositionProfit::_Internal {
 public:
  using HasBits = decltype(std::declval<AccountPositionProfit>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AccountPositionProfit, _impl_._has_bits_);
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& update_time(const AccountPositionProfit* msg);
  static void set_has_net(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_upl(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_upl_trade(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_rpl(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_upl_usd(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_upl_trade_usd(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_rpl_usd(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_day_net(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_day_rpl(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_day_rpl_usd(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_day_upl(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_day_upl_trade(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_day_upl_usd(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_day_upl_trade_usd(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
};

const ::PROTOBUF_NAMESPACE_ID::Timestamp&
AccountPositionProfit::_Internal::update_time(const AccountPositionProfit* msg) {
  return *msg->_impl_.update_time_;
}
void AccountPositionProfit::clear_update_time() {
  if (GetArenaForAllocation() == nullptr && _impl_.update_time_ != nullptr) {
    delete _impl_.update_time_;
  }
  _impl_.update_time_ = nullptr;
}
AccountPositionProfit::AccountPositionProfit(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:t4proto.v1.account.AccountPositionProfit)
}
AccountPositionProfit::AccountPositionProfit(const AccountPositionProfit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AccountPositionProfit* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_) {}

    , decltype(_impl_.exchange_id_) {}

    , decltype(_impl_.contract_id_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.update_time_){nullptr}
    , decltype(_impl_.net_) {}

    , decltype(_impl_.upl_) {}

    , decltype(_impl_.upl_trade_) {}

    , decltype(_impl_.rpl_) {}

    , decltype(_impl_.upl_usd_) {}

    , decltype(_impl_.upl_trade_usd_) {}

    , decltype(_impl_.rpl_usd_) {}

    , decltype(_impl_.day_net_) {}

    , decltype(_impl_.day_rpl_) {}

    , decltype(_impl_.day_rpl_usd_) {}

    , decltype(_impl_.day_upl_) {}

    , decltype(_impl_.day_upl_trade_) {}

    , decltype(_impl_.day_upl_usd_) {}

    , decltype(_impl_.day_upl_trade_usd_) {}

    , decltype(_impl_.delayed_) {}

    , decltype(_impl_.is_options_) {}

    , decltype(_impl_.has_data_) {}

    , decltype(_impl_.is_implied_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.account_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_account_id().empty()) {
    _this->_impl_.account_id_.Set(from._internal_account_id(), _this->GetArenaForAllocation());
  }
  _impl_.exchange_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.exchange_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_exchange_id().empty()) {
    _this->_impl_.exchange_id_.Set(from._internal_exchange_id(), _this->GetArenaForAllocation());
  }
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_contract_id().empty()) {
    _this->_impl_.contract_id_.Set(from._internal_contract_id(), _this->GetArenaForAllocation());
  }
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  if (from._internal_has_update_time()) {
    _this->_impl_.update_time_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.update_time_);
  }
  ::memcpy(&_impl_.net_, &from._impl_.net_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.is_implied_) -
    reinterpret_cast<char*>(&_impl_.net_)) + sizeof(_impl_.is_implied_));
  // @@protoc_insertion_point(copy_constructor:t4proto.v1.account.AccountPositionProfit)
}

inline void AccountPositionProfit::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_) {}

    , decltype(_impl_.exchange_id_) {}

    , decltype(_impl_.contract_id_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.update_time_){nullptr}
    , decltype(_impl_.net_) { 0 }

    , decltype(_impl_.upl_) { 0 }

    , decltype(_impl_.upl_trade_) { 0 }

    , decltype(_impl_.rpl_) { 0 }

    , decltype(_impl_.upl_usd_) { 0 }

    , decltype(_impl_.upl_trade_usd_) { 0 }

    , decltype(_impl_.rpl_usd_) { 0 }

    , decltype(_impl_.day_net_) { 0 }

    , decltype(_impl_.day_rpl_) { 0 }

    , decltype(_impl_.day_rpl_usd_) { 0 }

    , decltype(_impl_.day_upl_) { 0 }

    , decltype(_impl_.day_upl_trade_) { 0 }

    , decltype(_impl_.day_upl_usd_) { 0 }

    , decltype(_impl_.day_upl_trade_usd_) { 0 }

    , decltype(_impl_.delayed_) { false }

    , decltype(_impl_.is_options_) { false }

    , decltype(_impl_.has_data_) { false }

    , decltype(_impl_.is_implied_) { false }

  };
  _impl_.account_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.exchange_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.exchange_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.contract_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AccountPositionProfit::~AccountPositionProfit() {
  // @@protoc_insertion_point(destructor:t4proto.v1.account.AccountPositionProfit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AccountPositionProfit::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.account_id_.Destroy();
  _impl_.exchange_id_.Destroy();
  _impl_.contract_id_.Destroy();
  _impl_.market_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.update_time_;
}

void AccountPositionProfit::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AccountPositionProfit::Clear() {
// @@protoc_insertion_point(message_clear_start:t4proto.v1.account.AccountPositionProfit)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.account_id_.ClearToEmpty();
  _impl_.exchange_id_.ClearToEmpty();
  _impl_.contract_id_.ClearToEmpty();
  _impl_.market_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.update_time_ != nullptr) {
    delete _impl_.update_time_;
  }
  _impl_.update_time_ = nullptr;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.net_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.day_net_) -
        reinterpret_cast<char*>(&_impl_.net_)) + sizeof(_impl_.day_net_));
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&_impl_.day_rpl_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.day_upl_trade_usd_) -
        reinterpret_cast<char*>(&_impl_.day_rpl_)) + sizeof(_impl_.day_upl_trade_usd_));
  }
  ::memset(&_impl_.delayed_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.is_implied_) -
      reinterpret_cast<char*>(&_impl_.delayed_)) + sizeof(_impl_.is_implied_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AccountPositionProfit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_account_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "t4proto.v1.account.AccountPositionProfit.account_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string exchange_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_exchange_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "t4proto.v1.account.AccountPositionProfit.exchange_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string contract_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "t4proto.v1.account.AccountPositionProfit.contract_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string market_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "t4proto.v1.account.AccountPositionProfit.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool delayed = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.delayed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.Timestamp update_time = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_update_time(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_options = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.is_options_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool has_data = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.has_data_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_implied = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _impl_.is_implied_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double net = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 81)) {
          _Internal::set_has_net(&has_bits);
          _impl_.net_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double upl = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 89)) {
          _Internal::set_has_upl(&has_bits);
          _impl_.upl_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double upl_trade = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 97)) {
          _Internal::set_has_upl_trade(&has_bits);
          _impl_.upl_trade_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double rpl = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 105)) {
          _Internal::set_has_rpl(&has_bits);
          _impl_.rpl_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double upl_usd = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 113)) {
          _Internal::set_has_upl_usd(&has_bits);
          _impl_.upl_usd_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double upl_trade_usd = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 121)) {
          _Internal::set_has_upl_trade_usd(&has_bits);
          _impl_.upl_trade_usd_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double rpl_usd = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 129)) {
          _Internal::set_has_rpl_usd(&has_bits);
          _impl_.rpl_usd_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double day_net = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 137)) {
          _Internal::set_has_day_net(&has_bits);
          _impl_.day_net_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double day_rpl = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 145)) {
          _Internal::set_has_day_rpl(&has_bits);
          _impl_.day_rpl_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double day_rpl_usd = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 153)) {
          _Internal::set_has_day_rpl_usd(&has_bits);
          _impl_.day_rpl_usd_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double day_upl = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 161)) {
          _Internal::set_has_day_upl(&has_bits);
          _impl_.day_upl_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double day_upl_trade = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 169)) {
          _Internal::set_has_day_upl_trade(&has_bits);
          _impl_.day_upl_trade_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double day_upl_usd = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 177)) {
          _Internal::set_has_day_upl_usd(&has_bits);
          _impl_.day_upl_usd_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double day_upl_trade_usd = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 185)) {
          _Internal::set_has_day_upl_trade_usd(&has_bits);
          _impl_.day_upl_trade_usd_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AccountPositionProfit::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:t4proto.v1.account.AccountPositionProfit)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string account_id = 1;
  if (!this->_internal_account_id().empty()) {
    const std::string& _s = this->_internal_account_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "t4proto.v1.account.AccountPositionProfit.account_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string exchange_id = 2;
  if (!this->_internal_exchange_id().empty()) {
    const std::string& _s = this->_internal_exchange_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "t4proto.v1.account.AccountPositionProfit.exchange_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string contract_id = 3;
  if (!this->_internal_contract_id().empty()) {
    const std::string& _s = this->_internal_contract_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "t4proto.v1.account.AccountPositionProfit.contract_id");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string market_id = 4;
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "t4proto.v1.account.AccountPositionProfit.market_id");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // bool delayed = 5;
  if (this->_internal_delayed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this->_internal_delayed(), target);
  }

  // .google.protobuf.Timestamp update_time = 6;
  if (this->_internal_has_update_time()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::update_time(this),
        _Internal::update_time(this).GetCachedSize(), target, stream);
  }

  // bool is_options = 7;
  if (this->_internal_is_options() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        7, this->_internal_is_options(), target);
  }

  // bool has_data = 8;
  if (this->_internal_has_data() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this->_internal_has_data(), target);
  }

  // bool is_implied = 9;
  if (this->_internal_is_implied() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        9, this->_internal_is_implied(), target);
  }

  // optional double net = 10;
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        10, this->_internal_net(), target);
  }

  // optional double upl = 11;
  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        11, this->_internal_upl(), target);
  }

  // optional double upl_trade = 12;
  if ((_impl_._has_bits_[0] & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        12, this->_internal_upl_trade(), target);
  }

  // optional double rpl = 13;
  if ((_impl_._has_bits_[0] & 0x00000008u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        13, this->_internal_rpl(), target);
  }

  // optional double upl_usd = 14;
  if ((_impl_._has_bits_[0] & 0x00000010u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        14, this->_internal_upl_usd(), target);
  }

  // optional double upl_trade_usd = 15;
  if ((_impl_._has_bits_[0] & 0x00000020u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        15, this->_internal_upl_trade_usd(), target);
  }

  // optional double rpl_usd = 16;
  if ((_impl_._has_bits_[0] & 0x00000040u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        16, this->_internal_rpl_usd(), target);
  }

  // optional double day_net = 17;
  if ((_impl_._has_bits_[0] & 0x00000080u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        17, this->_internal_day_net(), target);
  }

  // optional double day_rpl = 18;
  if ((_impl_._has_bits_[0] & 0x00000100u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        18, this->_internal_day_rpl(), target);
  }

  // optional double day_rpl_usd = 19;
  if ((_impl_._has_bits_[0] & 0x00000200u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        19, this->_internal_day_rpl_usd(), target);
  }

  // optional double day_upl = 20;
  if ((_impl_._has_bits_[0] & 0x00000400u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        20, this->_internal_day_upl(), target);
  }

  // optional double day_upl_trade = 21;
  if ((_impl_._has_bits_[0] & 0x00000800u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        21, this->_internal_day_upl_trade(), target);
  }

  // optional double day_upl_usd = 22;
  if ((_impl_._has_bits_[0] & 0x00001000u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        22, this->_internal_day_upl_usd(), target);
  }

  // optional double day_upl_trade_usd = 23;
  if ((_impl_._has_bits_[0] & 0x00002000u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        23, this->_internal_day_upl_trade_usd(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:t4proto.v1.account.AccountPositionProfit)
  return target;
}

::size_t AccountPositionProfit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:t4proto.v1.account.AccountPositionProfit)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string account_id = 1;
  if (!this->_internal_account_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_account_id());
  }

  // string exchange_id = 2;
  if (!this->_internal_exchange_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_exchange_id());
  }

  // string contract_id = 3;
  if (!this->_internal_contract_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_contract_id());
  }

  // string market_id = 4;
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // .google.protobuf.Timestamp update_time = 6;
  if (this->_internal_has_update_time()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.update_time_);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional double net = 10;
    if (cached_has_bits & 0x00000001u) {
      total_size += 9;
    }

    // optional double upl = 11;
    if (cached_has_bits & 0x00000002u) {
      total_size += 9;
    }

    // optional double upl_trade = 12;
    if (cached_has_bits & 0x00000004u) {
      total_size += 9;
    }

    // optional double rpl = 13;
    if (cached_has_bits & 0x00000008u) {
      total_size += 9;
    }

    // optional double upl_usd = 14;
    if (cached_has_bits & 0x00000010u) {
      total_size += 9;
    }

    // optional double upl_trade_usd = 15;
    if (cached_has_bits & 0x00000020u) {
      total_size += 9;
    }

    // optional double rpl_usd = 16;
    if (cached_has_bits & 0x00000040u) {
      total_size += 10;
    }

    // optional double day_net = 17;
    if (cached_has_bits & 0x00000080u) {
      total_size += 10;
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional double day_rpl = 18;
    if (cached_has_bits & 0x00000100u) {
      total_size += 10;
    }

    // optional double day_rpl_usd = 19;
    if (cached_has_bits & 0x00000200u) {
      total_size += 10;
    }

    // optional double day_upl = 20;
    if (cached_has_bits & 0x00000400u) {
      total_size += 10;
    }

    // optional double day_upl_trade = 21;
    if (cached_has_bits & 0x00000800u) {
      total_size += 10;
    }

    // optional double day_upl_usd = 22;
    if (cached_has_bits & 0x00001000u) {
      total_size += 10;
    }

    // optional double day_upl_trade_usd = 23;
    if (cached_has_bits & 0x00002000u) {
      total_size += 10;
    }

  }
  // bool delayed = 5;
  if (this->_internal_delayed() != 0) {
    total_size += 2;
  }

  // bool is_options = 7;
  if (this->_internal_is_options() != 0) {
    total_size += 2;
  }

  // bool has_data = 8;
  if (this->_internal_has_data() != 0) {
    total_size += 2;
  }

  // bool is_implied = 9;
  if (this->_internal_is_implied() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AccountPositionProfit::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AccountPositionProfit::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AccountPositionProfit::GetClassData() const { return &_class_data_; }


void AccountPositionProfit::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AccountPositionProfit*>(&to_msg);
  auto& from = static_cast<const AccountPositionProfit&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:t4proto.v1.account.AccountPositionProfit)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_account_id().empty()) {
    _this->_internal_set_account_id(from._internal_account_id());
  }
  if (!from._internal_exchange_id().empty()) {
    _this->_internal_set_exchange_id(from._internal_exchange_id());
  }
  if (!from._internal_contract_id().empty()) {
    _this->_internal_set_contract_id(from._internal_contract_id());
  }
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (from._internal_has_update_time()) {
    _this->_internal_mutable_update_time()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_update_time());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.net_ = from._impl_.net_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.upl_ = from._impl_.upl_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.upl_trade_ = from._impl_.upl_trade_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.rpl_ = from._impl_.rpl_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.upl_usd_ = from._impl_.upl_usd_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.upl_trade_usd_ = from._impl_.upl_trade_usd_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.rpl_usd_ = from._impl_.rpl_usd_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.day_net_ = from._impl_.day_net_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.day_rpl_ = from._impl_.day_rpl_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.day_rpl_usd_ = from._impl_.day_rpl_usd_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.day_upl_ = from._impl_.day_upl_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.day_upl_trade_ = from._impl_.day_upl_trade_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.day_upl_usd_ = from._impl_.day_upl_usd_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.day_upl_trade_usd_ = from._impl_.day_upl_trade_usd_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (from._internal_delayed() != 0) {
    _this->_internal_set_delayed(from._internal_delayed());
  }
  if (from._internal_is_options() != 0) {
    _this->_internal_set_is_options(from._internal_is_options());
  }
  if (from._internal_has_data() != 0) {
    _this->_internal_set_has_data(from._internal_has_data());
  }
  if (from._internal_is_implied() != 0) {
    _this->_internal_set_is_implied(from._internal_is_implied());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AccountPositionProfit::CopyFrom(const AccountPositionProfit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:t4proto.v1.account.AccountPositionProfit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountPositionProfit::IsInitialized() const {
  return true;
}

void AccountPositionProfit::InternalSwap(AccountPositionProfit* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.account_id_, lhs_arena,
                                       &other->_impl_.account_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.exchange_id_, lhs_arena,
                                       &other->_impl_.exchange_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.contract_id_, lhs_arena,
                                       &other->_impl_.contract_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AccountPositionProfit, _impl_.is_implied_)
      + sizeof(AccountPositionProfit::_impl_.is_implied_)
      - PROTOBUF_FIELD_OFFSET(AccountPositionProfit, _impl_.update_time_)>(
          reinterpret_cast<char*>(&_impl_.update_time_),
          reinterpret_cast<char*>(&other->_impl_.update_time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AccountPositionProfit::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_t4_2fv1_2faccount_2faccount_2eproto_getter, &descriptor_table_t4_2fv1_2faccount_2faccount_2eproto_once,
      file_level_metadata_t4_2fv1_2faccount_2faccount_2eproto[9]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace account
}  // namespace v1
}  // namespace t4proto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::t4proto::v1::account::AccountSubscribe*
Arena::CreateMaybeMessage< ::t4proto::v1::account::AccountSubscribe >(Arena* arena) {
  return Arena::CreateMessageInternal< ::t4proto::v1::account::AccountSubscribe >(arena);
}
template<> PROTOBUF_NOINLINE ::t4proto::v1::account::AccountSubscribeResponse*
Arena::CreateMaybeMessage< ::t4proto::v1::account::AccountSubscribeResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::t4proto::v1::account::AccountSubscribeResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::t4proto::v1::account::AccountCurrency*
Arena::CreateMaybeMessage< ::t4proto::v1::account::AccountCurrency >(Arena* arena) {
  return Arena::CreateMessageInternal< ::t4proto::v1::account::AccountCurrency >(arena);
}
template<> PROTOBUF_NOINLINE ::t4proto::v1::account::AccountPosition*
Arena::CreateMaybeMessage< ::t4proto::v1::account::AccountPosition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::t4proto::v1::account::AccountPosition >(arena);
}
template<> PROTOBUF_NOINLINE ::t4proto::v1::account::AccountUpdate*
Arena::CreateMaybeMessage< ::t4proto::v1::account::AccountUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::t4proto::v1::account::AccountUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::t4proto::v1::account::AccountDetails*
Arena::CreateMaybeMessage< ::t4proto::v1::account::AccountDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::t4proto::v1::account::AccountDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::t4proto::v1::account::AccountSnapshotMessage*
Arena::CreateMaybeMessage< ::t4proto::v1::account::AccountSnapshotMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::t4proto::v1::account::AccountSnapshotMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::t4proto::v1::account::AccountSnapshot*
Arena::CreateMaybeMessage< ::t4proto::v1::account::AccountSnapshot >(Arena* arena) {
  return Arena::CreateMessageInternal< ::t4proto::v1::account::AccountSnapshot >(arena);
}
template<> PROTOBUF_NOINLINE ::t4proto::v1::account::AccountProfit*
Arena::CreateMaybeMessage< ::t4proto::v1::account::AccountProfit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::t4proto::v1::account::AccountProfit >(arena);
}
template<> PROTOBUF_NOINLINE ::t4proto::v1::account::AccountPositionProfit*
Arena::CreateMaybeMessage< ::t4proto::v1::account::AccountPositionProfit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::t4proto::v1::account::AccountPositionProfit >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
