// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: t4/v1/service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_t4_2fv1_2fservice_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_t4_2fv1_2fservice_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4022000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4022002 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "t4/v1/auth/auth.pb.h"
#include "t4/v1/market/market.pb.h"
#include "t4/v1/account/account.pb.h"
#include "t4/v1/orderrouting/orderrouting.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_t4_2fv1_2fservice_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_t4_2fv1_2fservice_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_t4_2fv1_2fservice_2eproto;
namespace t4proto {
namespace v1 {
namespace service {
class ClientMessage;
struct ClientMessageDefaultTypeInternal;
extern ClientMessageDefaultTypeInternal _ClientMessage_default_instance_;
class Heartbeat;
struct HeartbeatDefaultTypeInternal;
extern HeartbeatDefaultTypeInternal _Heartbeat_default_instance_;
class ServerMessage;
struct ServerMessageDefaultTypeInternal;
extern ServerMessageDefaultTypeInternal _ServerMessage_default_instance_;
}  // namespace service
}  // namespace v1
}  // namespace t4proto
PROTOBUF_NAMESPACE_OPEN
template <>
::t4proto::v1::service::ClientMessage* Arena::CreateMaybeMessage<::t4proto::v1::service::ClientMessage>(Arena*);
template <>
::t4proto::v1::service::Heartbeat* Arena::CreateMaybeMessage<::t4proto::v1::service::Heartbeat>(Arena*);
template <>
::t4proto::v1::service::ServerMessage* Arena::CreateMaybeMessage<::t4proto::v1::service::ServerMessage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace t4proto {
namespace v1 {
namespace service {

// ===================================================================


// -------------------------------------------------------------------

class ClientMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:t4proto.v1.service.ClientMessage) */ {
 public:
  inline ClientMessage() : ClientMessage(nullptr) {}
  ~ClientMessage() override;
  explicit PROTOBUF_CONSTEXPR ClientMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientMessage(const ClientMessage& from);
  ClientMessage(ClientMessage&& from) noexcept
    : ClientMessage() {
    *this = ::std::move(from);
  }

  inline ClientMessage& operator=(const ClientMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientMessage& operator=(ClientMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientMessage& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kHeartbeat = 1,
    kLoginRequest = 2,
    kAuthenticationTokenRequest = 3,
    kMarketDepthSubscribe = 100,
    kMarketByOrderSubscribe = 101,
    kAccountSubscribe = 200,
    kOrderSubmit = 300,
    kOrderRevise = 301,
    kOrderPull = 302,
    kCreateUds = 340,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const ClientMessage* internal_default_instance() {
    return reinterpret_cast<const ClientMessage*>(
               &_ClientMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ClientMessage& a, ClientMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClientMessage& from) {
    ClientMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "t4proto.v1.service.ClientMessage";
  }
  protected:
  explicit ClientMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeartbeatFieldNumber = 1,
    kLoginRequestFieldNumber = 2,
    kAuthenticationTokenRequestFieldNumber = 3,
    kMarketDepthSubscribeFieldNumber = 100,
    kMarketByOrderSubscribeFieldNumber = 101,
    kAccountSubscribeFieldNumber = 200,
    kOrderSubmitFieldNumber = 300,
    kOrderReviseFieldNumber = 301,
    kOrderPullFieldNumber = 302,
    kCreateUdsFieldNumber = 340,
  };
  // .t4proto.v1.service.Heartbeat heartbeat = 1;
  bool has_heartbeat() const;
  private:
  bool _internal_has_heartbeat() const;

  public:
  void clear_heartbeat() ;
  const ::t4proto::v1::service::Heartbeat& heartbeat() const;
  PROTOBUF_NODISCARD ::t4proto::v1::service::Heartbeat* release_heartbeat();
  ::t4proto::v1::service::Heartbeat* mutable_heartbeat();
  void set_allocated_heartbeat(::t4proto::v1::service::Heartbeat* heartbeat);
  private:
  const ::t4proto::v1::service::Heartbeat& _internal_heartbeat() const;
  ::t4proto::v1::service::Heartbeat* _internal_mutable_heartbeat();
  public:
  void unsafe_arena_set_allocated_heartbeat(
      ::t4proto::v1::service::Heartbeat* heartbeat);
  ::t4proto::v1::service::Heartbeat* unsafe_arena_release_heartbeat();
  // .t4proto.v1.auth.LoginRequest login_request = 2;
  bool has_login_request() const;
  private:
  bool _internal_has_login_request() const;

  public:
  void clear_login_request() ;
  const ::t4proto::v1::auth::LoginRequest& login_request() const;
  PROTOBUF_NODISCARD ::t4proto::v1::auth::LoginRequest* release_login_request();
  ::t4proto::v1::auth::LoginRequest* mutable_login_request();
  void set_allocated_login_request(::t4proto::v1::auth::LoginRequest* login_request);
  private:
  const ::t4proto::v1::auth::LoginRequest& _internal_login_request() const;
  ::t4proto::v1::auth::LoginRequest* _internal_mutable_login_request();
  public:
  void unsafe_arena_set_allocated_login_request(
      ::t4proto::v1::auth::LoginRequest* login_request);
  ::t4proto::v1::auth::LoginRequest* unsafe_arena_release_login_request();
  // .t4proto.v1.auth.AuthenticationTokenRequest authentication_token_request = 3;
  bool has_authentication_token_request() const;
  private:
  bool _internal_has_authentication_token_request() const;

  public:
  void clear_authentication_token_request() ;
  const ::t4proto::v1::auth::AuthenticationTokenRequest& authentication_token_request() const;
  PROTOBUF_NODISCARD ::t4proto::v1::auth::AuthenticationTokenRequest* release_authentication_token_request();
  ::t4proto::v1::auth::AuthenticationTokenRequest* mutable_authentication_token_request();
  void set_allocated_authentication_token_request(::t4proto::v1::auth::AuthenticationTokenRequest* authentication_token_request);
  private:
  const ::t4proto::v1::auth::AuthenticationTokenRequest& _internal_authentication_token_request() const;
  ::t4proto::v1::auth::AuthenticationTokenRequest* _internal_mutable_authentication_token_request();
  public:
  void unsafe_arena_set_allocated_authentication_token_request(
      ::t4proto::v1::auth::AuthenticationTokenRequest* authentication_token_request);
  ::t4proto::v1::auth::AuthenticationTokenRequest* unsafe_arena_release_authentication_token_request();
  // .t4proto.v1.market.MarketDepthSubscribe market_depth_subscribe = 100;
  bool has_market_depth_subscribe() const;
  private:
  bool _internal_has_market_depth_subscribe() const;

  public:
  void clear_market_depth_subscribe() ;
  const ::t4proto::v1::market::MarketDepthSubscribe& market_depth_subscribe() const;
  PROTOBUF_NODISCARD ::t4proto::v1::market::MarketDepthSubscribe* release_market_depth_subscribe();
  ::t4proto::v1::market::MarketDepthSubscribe* mutable_market_depth_subscribe();
  void set_allocated_market_depth_subscribe(::t4proto::v1::market::MarketDepthSubscribe* market_depth_subscribe);
  private:
  const ::t4proto::v1::market::MarketDepthSubscribe& _internal_market_depth_subscribe() const;
  ::t4proto::v1::market::MarketDepthSubscribe* _internal_mutable_market_depth_subscribe();
  public:
  void unsafe_arena_set_allocated_market_depth_subscribe(
      ::t4proto::v1::market::MarketDepthSubscribe* market_depth_subscribe);
  ::t4proto::v1::market::MarketDepthSubscribe* unsafe_arena_release_market_depth_subscribe();
  // .t4proto.v1.market.MarketByOrderSubscribe market_by_order_subscribe = 101;
  bool has_market_by_order_subscribe() const;
  private:
  bool _internal_has_market_by_order_subscribe() const;

  public:
  void clear_market_by_order_subscribe() ;
  const ::t4proto::v1::market::MarketByOrderSubscribe& market_by_order_subscribe() const;
  PROTOBUF_NODISCARD ::t4proto::v1::market::MarketByOrderSubscribe* release_market_by_order_subscribe();
  ::t4proto::v1::market::MarketByOrderSubscribe* mutable_market_by_order_subscribe();
  void set_allocated_market_by_order_subscribe(::t4proto::v1::market::MarketByOrderSubscribe* market_by_order_subscribe);
  private:
  const ::t4proto::v1::market::MarketByOrderSubscribe& _internal_market_by_order_subscribe() const;
  ::t4proto::v1::market::MarketByOrderSubscribe* _internal_mutable_market_by_order_subscribe();
  public:
  void unsafe_arena_set_allocated_market_by_order_subscribe(
      ::t4proto::v1::market::MarketByOrderSubscribe* market_by_order_subscribe);
  ::t4proto::v1::market::MarketByOrderSubscribe* unsafe_arena_release_market_by_order_subscribe();
  // .t4proto.v1.account.AccountSubscribe account_subscribe = 200;
  bool has_account_subscribe() const;
  private:
  bool _internal_has_account_subscribe() const;

  public:
  void clear_account_subscribe() ;
  const ::t4proto::v1::account::AccountSubscribe& account_subscribe() const;
  PROTOBUF_NODISCARD ::t4proto::v1::account::AccountSubscribe* release_account_subscribe();
  ::t4proto::v1::account::AccountSubscribe* mutable_account_subscribe();
  void set_allocated_account_subscribe(::t4proto::v1::account::AccountSubscribe* account_subscribe);
  private:
  const ::t4proto::v1::account::AccountSubscribe& _internal_account_subscribe() const;
  ::t4proto::v1::account::AccountSubscribe* _internal_mutable_account_subscribe();
  public:
  void unsafe_arena_set_allocated_account_subscribe(
      ::t4proto::v1::account::AccountSubscribe* account_subscribe);
  ::t4proto::v1::account::AccountSubscribe* unsafe_arena_release_account_subscribe();
  // .t4proto.v1.orderrouting.OrderSubmit order_submit = 300;
  bool has_order_submit() const;
  private:
  bool _internal_has_order_submit() const;

  public:
  void clear_order_submit() ;
  const ::t4proto::v1::orderrouting::OrderSubmit& order_submit() const;
  PROTOBUF_NODISCARD ::t4proto::v1::orderrouting::OrderSubmit* release_order_submit();
  ::t4proto::v1::orderrouting::OrderSubmit* mutable_order_submit();
  void set_allocated_order_submit(::t4proto::v1::orderrouting::OrderSubmit* order_submit);
  private:
  const ::t4proto::v1::orderrouting::OrderSubmit& _internal_order_submit() const;
  ::t4proto::v1::orderrouting::OrderSubmit* _internal_mutable_order_submit();
  public:
  void unsafe_arena_set_allocated_order_submit(
      ::t4proto::v1::orderrouting::OrderSubmit* order_submit);
  ::t4proto::v1::orderrouting::OrderSubmit* unsafe_arena_release_order_submit();
  // .t4proto.v1.orderrouting.OrderRevise order_revise = 301;
  bool has_order_revise() const;
  private:
  bool _internal_has_order_revise() const;

  public:
  void clear_order_revise() ;
  const ::t4proto::v1::orderrouting::OrderRevise& order_revise() const;
  PROTOBUF_NODISCARD ::t4proto::v1::orderrouting::OrderRevise* release_order_revise();
  ::t4proto::v1::orderrouting::OrderRevise* mutable_order_revise();
  void set_allocated_order_revise(::t4proto::v1::orderrouting::OrderRevise* order_revise);
  private:
  const ::t4proto::v1::orderrouting::OrderRevise& _internal_order_revise() const;
  ::t4proto::v1::orderrouting::OrderRevise* _internal_mutable_order_revise();
  public:
  void unsafe_arena_set_allocated_order_revise(
      ::t4proto::v1::orderrouting::OrderRevise* order_revise);
  ::t4proto::v1::orderrouting::OrderRevise* unsafe_arena_release_order_revise();
  // .t4proto.v1.orderrouting.OrderPull order_pull = 302;
  bool has_order_pull() const;
  private:
  bool _internal_has_order_pull() const;

  public:
  void clear_order_pull() ;
  const ::t4proto::v1::orderrouting::OrderPull& order_pull() const;
  PROTOBUF_NODISCARD ::t4proto::v1::orderrouting::OrderPull* release_order_pull();
  ::t4proto::v1::orderrouting::OrderPull* mutable_order_pull();
  void set_allocated_order_pull(::t4proto::v1::orderrouting::OrderPull* order_pull);
  private:
  const ::t4proto::v1::orderrouting::OrderPull& _internal_order_pull() const;
  ::t4proto::v1::orderrouting::OrderPull* _internal_mutable_order_pull();
  public:
  void unsafe_arena_set_allocated_order_pull(
      ::t4proto::v1::orderrouting::OrderPull* order_pull);
  ::t4proto::v1::orderrouting::OrderPull* unsafe_arena_release_order_pull();
  // .t4proto.v1.orderrouting.CreateUDS create_uds = 340;
  bool has_create_uds() const;
  private:
  bool _internal_has_create_uds() const;

  public:
  void clear_create_uds() ;
  const ::t4proto::v1::orderrouting::CreateUDS& create_uds() const;
  PROTOBUF_NODISCARD ::t4proto::v1::orderrouting::CreateUDS* release_create_uds();
  ::t4proto::v1::orderrouting::CreateUDS* mutable_create_uds();
  void set_allocated_create_uds(::t4proto::v1::orderrouting::CreateUDS* create_uds);
  private:
  const ::t4proto::v1::orderrouting::CreateUDS& _internal_create_uds() const;
  ::t4proto::v1::orderrouting::CreateUDS* _internal_mutable_create_uds();
  public:
  void unsafe_arena_set_allocated_create_uds(
      ::t4proto::v1::orderrouting::CreateUDS* create_uds);
  ::t4proto::v1::orderrouting::CreateUDS* unsafe_arena_release_create_uds();
  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:t4proto.v1.service.ClientMessage)
 private:
  class _Internal;
  void set_has_heartbeat();
  void set_has_login_request();
  void set_has_authentication_token_request();
  void set_has_market_depth_subscribe();
  void set_has_market_by_order_subscribe();
  void set_has_account_subscribe();
  void set_has_order_submit();
  void set_has_order_revise();
  void set_has_order_pull();
  void set_has_create_uds();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::t4proto::v1::service::Heartbeat* heartbeat_;
      ::t4proto::v1::auth::LoginRequest* login_request_;
      ::t4proto::v1::auth::AuthenticationTokenRequest* authentication_token_request_;
      ::t4proto::v1::market::MarketDepthSubscribe* market_depth_subscribe_;
      ::t4proto::v1::market::MarketByOrderSubscribe* market_by_order_subscribe_;
      ::t4proto::v1::account::AccountSubscribe* account_subscribe_;
      ::t4proto::v1::orderrouting::OrderSubmit* order_submit_;
      ::t4proto::v1::orderrouting::OrderRevise* order_revise_;
      ::t4proto::v1::orderrouting::OrderPull* order_pull_;
      ::t4proto::v1::orderrouting::CreateUDS* create_uds_;
    } payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t4_2fv1_2fservice_2eproto;
};// -------------------------------------------------------------------

class ServerMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:t4proto.v1.service.ServerMessage) */ {
 public:
  inline ServerMessage() : ServerMessage(nullptr) {}
  ~ServerMessage() override;
  explicit PROTOBUF_CONSTEXPR ServerMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerMessage(const ServerMessage& from);
  ServerMessage(ServerMessage&& from) noexcept
    : ServerMessage() {
    *this = ::std::move(from);
  }

  inline ServerMessage& operator=(const ServerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerMessage& operator=(ServerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerMessage& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kHeartbeat = 1,
    kLoginResponse = 2,
    kAuthenticationToken = 3,
    kMarketDepthSubscribeReject = 100,
    kMarketByOrderSubscribeReject = 101,
    kMarketDetails = 102,
    kMarketDepth = 103,
    kMarketDepthTrade = 104,
    kMarketHighLow = 105,
    kMarketPriceLimits = 106,
    kMarketSettlement = 107,
    kMarketSnapshot = 108,
    kMarketByOrderSnapshot = 109,
    kMarketByOrderUpdate = 110,
    kAccountSubscribeResponse = 200,
    kAccountCurrency = 201,
    kAccountPosition = 202,
    kAccountUpdate = 203,
    kAccountDetails = 204,
    kAccountSnapshot = 205,
    kAccountProfit = 206,
    kAccountPositionProfit = 207,
    kOrderUpdate = 300,
    kOrderUpdateMulti = 301,
    kOrderUpdateFailed = 302,
    kOrderUpdateStatus = 303,
    kOrderUpdateTrade = 304,
    kOrderUpdateTradeLeg = 305,
    kCreateUdsResponse = 340,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const ServerMessage* internal_default_instance() {
    return reinterpret_cast<const ServerMessage*>(
               &_ServerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ServerMessage& a, ServerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerMessage& from) {
    ServerMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "t4proto.v1.service.ServerMessage";
  }
  protected:
  explicit ServerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeartbeatFieldNumber = 1,
    kLoginResponseFieldNumber = 2,
    kAuthenticationTokenFieldNumber = 3,
    kMarketDepthSubscribeRejectFieldNumber = 100,
    kMarketByOrderSubscribeRejectFieldNumber = 101,
    kMarketDetailsFieldNumber = 102,
    kMarketDepthFieldNumber = 103,
    kMarketDepthTradeFieldNumber = 104,
    kMarketHighLowFieldNumber = 105,
    kMarketPriceLimitsFieldNumber = 106,
    kMarketSettlementFieldNumber = 107,
    kMarketSnapshotFieldNumber = 108,
    kMarketByOrderSnapshotFieldNumber = 109,
    kMarketByOrderUpdateFieldNumber = 110,
    kAccountSubscribeResponseFieldNumber = 200,
    kAccountCurrencyFieldNumber = 201,
    kAccountPositionFieldNumber = 202,
    kAccountUpdateFieldNumber = 203,
    kAccountDetailsFieldNumber = 204,
    kAccountSnapshotFieldNumber = 205,
    kAccountProfitFieldNumber = 206,
    kAccountPositionProfitFieldNumber = 207,
    kOrderUpdateFieldNumber = 300,
    kOrderUpdateMultiFieldNumber = 301,
    kOrderUpdateFailedFieldNumber = 302,
    kOrderUpdateStatusFieldNumber = 303,
    kOrderUpdateTradeFieldNumber = 304,
    kOrderUpdateTradeLegFieldNumber = 305,
    kCreateUdsResponseFieldNumber = 340,
  };
  // .t4proto.v1.service.Heartbeat heartbeat = 1;
  bool has_heartbeat() const;
  private:
  bool _internal_has_heartbeat() const;

  public:
  void clear_heartbeat() ;
  const ::t4proto::v1::service::Heartbeat& heartbeat() const;
  PROTOBUF_NODISCARD ::t4proto::v1::service::Heartbeat* release_heartbeat();
  ::t4proto::v1::service::Heartbeat* mutable_heartbeat();
  void set_allocated_heartbeat(::t4proto::v1::service::Heartbeat* heartbeat);
  private:
  const ::t4proto::v1::service::Heartbeat& _internal_heartbeat() const;
  ::t4proto::v1::service::Heartbeat* _internal_mutable_heartbeat();
  public:
  void unsafe_arena_set_allocated_heartbeat(
      ::t4proto::v1::service::Heartbeat* heartbeat);
  ::t4proto::v1::service::Heartbeat* unsafe_arena_release_heartbeat();
  // .t4proto.v1.auth.LoginResponse login_response = 2;
  bool has_login_response() const;
  private:
  bool _internal_has_login_response() const;

  public:
  void clear_login_response() ;
  const ::t4proto::v1::auth::LoginResponse& login_response() const;
  PROTOBUF_NODISCARD ::t4proto::v1::auth::LoginResponse* release_login_response();
  ::t4proto::v1::auth::LoginResponse* mutable_login_response();
  void set_allocated_login_response(::t4proto::v1::auth::LoginResponse* login_response);
  private:
  const ::t4proto::v1::auth::LoginResponse& _internal_login_response() const;
  ::t4proto::v1::auth::LoginResponse* _internal_mutable_login_response();
  public:
  void unsafe_arena_set_allocated_login_response(
      ::t4proto::v1::auth::LoginResponse* login_response);
  ::t4proto::v1::auth::LoginResponse* unsafe_arena_release_login_response();
  // .t4proto.v1.auth.AuthenticationToken authentication_token = 3;
  bool has_authentication_token() const;
  private:
  bool _internal_has_authentication_token() const;

  public:
  void clear_authentication_token() ;
  const ::t4proto::v1::auth::AuthenticationToken& authentication_token() const;
  PROTOBUF_NODISCARD ::t4proto::v1::auth::AuthenticationToken* release_authentication_token();
  ::t4proto::v1::auth::AuthenticationToken* mutable_authentication_token();
  void set_allocated_authentication_token(::t4proto::v1::auth::AuthenticationToken* authentication_token);
  private:
  const ::t4proto::v1::auth::AuthenticationToken& _internal_authentication_token() const;
  ::t4proto::v1::auth::AuthenticationToken* _internal_mutable_authentication_token();
  public:
  void unsafe_arena_set_allocated_authentication_token(
      ::t4proto::v1::auth::AuthenticationToken* authentication_token);
  ::t4proto::v1::auth::AuthenticationToken* unsafe_arena_release_authentication_token();
  // .t4proto.v1.market.MarketDepthSubscribeReject market_depth_subscribe_reject = 100;
  bool has_market_depth_subscribe_reject() const;
  private:
  bool _internal_has_market_depth_subscribe_reject() const;

  public:
  void clear_market_depth_subscribe_reject() ;
  const ::t4proto::v1::market::MarketDepthSubscribeReject& market_depth_subscribe_reject() const;
  PROTOBUF_NODISCARD ::t4proto::v1::market::MarketDepthSubscribeReject* release_market_depth_subscribe_reject();
  ::t4proto::v1::market::MarketDepthSubscribeReject* mutable_market_depth_subscribe_reject();
  void set_allocated_market_depth_subscribe_reject(::t4proto::v1::market::MarketDepthSubscribeReject* market_depth_subscribe_reject);
  private:
  const ::t4proto::v1::market::MarketDepthSubscribeReject& _internal_market_depth_subscribe_reject() const;
  ::t4proto::v1::market::MarketDepthSubscribeReject* _internal_mutable_market_depth_subscribe_reject();
  public:
  void unsafe_arena_set_allocated_market_depth_subscribe_reject(
      ::t4proto::v1::market::MarketDepthSubscribeReject* market_depth_subscribe_reject);
  ::t4proto::v1::market::MarketDepthSubscribeReject* unsafe_arena_release_market_depth_subscribe_reject();
  // .t4proto.v1.market.MarketByOrderSubscribeReject market_by_order_subscribe_reject = 101;
  bool has_market_by_order_subscribe_reject() const;
  private:
  bool _internal_has_market_by_order_subscribe_reject() const;

  public:
  void clear_market_by_order_subscribe_reject() ;
  const ::t4proto::v1::market::MarketByOrderSubscribeReject& market_by_order_subscribe_reject() const;
  PROTOBUF_NODISCARD ::t4proto::v1::market::MarketByOrderSubscribeReject* release_market_by_order_subscribe_reject();
  ::t4proto::v1::market::MarketByOrderSubscribeReject* mutable_market_by_order_subscribe_reject();
  void set_allocated_market_by_order_subscribe_reject(::t4proto::v1::market::MarketByOrderSubscribeReject* market_by_order_subscribe_reject);
  private:
  const ::t4proto::v1::market::MarketByOrderSubscribeReject& _internal_market_by_order_subscribe_reject() const;
  ::t4proto::v1::market::MarketByOrderSubscribeReject* _internal_mutable_market_by_order_subscribe_reject();
  public:
  void unsafe_arena_set_allocated_market_by_order_subscribe_reject(
      ::t4proto::v1::market::MarketByOrderSubscribeReject* market_by_order_subscribe_reject);
  ::t4proto::v1::market::MarketByOrderSubscribeReject* unsafe_arena_release_market_by_order_subscribe_reject();
  // .t4proto.v1.market.MarketDetails market_details = 102;
  bool has_market_details() const;
  private:
  bool _internal_has_market_details() const;

  public:
  void clear_market_details() ;
  const ::t4proto::v1::market::MarketDetails& market_details() const;
  PROTOBUF_NODISCARD ::t4proto::v1::market::MarketDetails* release_market_details();
  ::t4proto::v1::market::MarketDetails* mutable_market_details();
  void set_allocated_market_details(::t4proto::v1::market::MarketDetails* market_details);
  private:
  const ::t4proto::v1::market::MarketDetails& _internal_market_details() const;
  ::t4proto::v1::market::MarketDetails* _internal_mutable_market_details();
  public:
  void unsafe_arena_set_allocated_market_details(
      ::t4proto::v1::market::MarketDetails* market_details);
  ::t4proto::v1::market::MarketDetails* unsafe_arena_release_market_details();
  // .t4proto.v1.market.MarketDepth market_depth = 103;
  bool has_market_depth() const;
  private:
  bool _internal_has_market_depth() const;

  public:
  void clear_market_depth() ;
  const ::t4proto::v1::market::MarketDepth& market_depth() const;
  PROTOBUF_NODISCARD ::t4proto::v1::market::MarketDepth* release_market_depth();
  ::t4proto::v1::market::MarketDepth* mutable_market_depth();
  void set_allocated_market_depth(::t4proto::v1::market::MarketDepth* market_depth);
  private:
  const ::t4proto::v1::market::MarketDepth& _internal_market_depth() const;
  ::t4proto::v1::market::MarketDepth* _internal_mutable_market_depth();
  public:
  void unsafe_arena_set_allocated_market_depth(
      ::t4proto::v1::market::MarketDepth* market_depth);
  ::t4proto::v1::market::MarketDepth* unsafe_arena_release_market_depth();
  // .t4proto.v1.market.MarketDepthTrade market_depth_trade = 104;
  bool has_market_depth_trade() const;
  private:
  bool _internal_has_market_depth_trade() const;

  public:
  void clear_market_depth_trade() ;
  const ::t4proto::v1::market::MarketDepthTrade& market_depth_trade() const;
  PROTOBUF_NODISCARD ::t4proto::v1::market::MarketDepthTrade* release_market_depth_trade();
  ::t4proto::v1::market::MarketDepthTrade* mutable_market_depth_trade();
  void set_allocated_market_depth_trade(::t4proto::v1::market::MarketDepthTrade* market_depth_trade);
  private:
  const ::t4proto::v1::market::MarketDepthTrade& _internal_market_depth_trade() const;
  ::t4proto::v1::market::MarketDepthTrade* _internal_mutable_market_depth_trade();
  public:
  void unsafe_arena_set_allocated_market_depth_trade(
      ::t4proto::v1::market::MarketDepthTrade* market_depth_trade);
  ::t4proto::v1::market::MarketDepthTrade* unsafe_arena_release_market_depth_trade();
  // .t4proto.v1.market.MarketHighLow market_high_low = 105;
  bool has_market_high_low() const;
  private:
  bool _internal_has_market_high_low() const;

  public:
  void clear_market_high_low() ;
  const ::t4proto::v1::market::MarketHighLow& market_high_low() const;
  PROTOBUF_NODISCARD ::t4proto::v1::market::MarketHighLow* release_market_high_low();
  ::t4proto::v1::market::MarketHighLow* mutable_market_high_low();
  void set_allocated_market_high_low(::t4proto::v1::market::MarketHighLow* market_high_low);
  private:
  const ::t4proto::v1::market::MarketHighLow& _internal_market_high_low() const;
  ::t4proto::v1::market::MarketHighLow* _internal_mutable_market_high_low();
  public:
  void unsafe_arena_set_allocated_market_high_low(
      ::t4proto::v1::market::MarketHighLow* market_high_low);
  ::t4proto::v1::market::MarketHighLow* unsafe_arena_release_market_high_low();
  // .t4proto.v1.market.MarketPriceLimits market_price_limits = 106;
  bool has_market_price_limits() const;
  private:
  bool _internal_has_market_price_limits() const;

  public:
  void clear_market_price_limits() ;
  const ::t4proto::v1::market::MarketPriceLimits& market_price_limits() const;
  PROTOBUF_NODISCARD ::t4proto::v1::market::MarketPriceLimits* release_market_price_limits();
  ::t4proto::v1::market::MarketPriceLimits* mutable_market_price_limits();
  void set_allocated_market_price_limits(::t4proto::v1::market::MarketPriceLimits* market_price_limits);
  private:
  const ::t4proto::v1::market::MarketPriceLimits& _internal_market_price_limits() const;
  ::t4proto::v1::market::MarketPriceLimits* _internal_mutable_market_price_limits();
  public:
  void unsafe_arena_set_allocated_market_price_limits(
      ::t4proto::v1::market::MarketPriceLimits* market_price_limits);
  ::t4proto::v1::market::MarketPriceLimits* unsafe_arena_release_market_price_limits();
  // .t4proto.v1.market.MarketSettlement market_settlement = 107;
  bool has_market_settlement() const;
  private:
  bool _internal_has_market_settlement() const;

  public:
  void clear_market_settlement() ;
  const ::t4proto::v1::market::MarketSettlement& market_settlement() const;
  PROTOBUF_NODISCARD ::t4proto::v1::market::MarketSettlement* release_market_settlement();
  ::t4proto::v1::market::MarketSettlement* mutable_market_settlement();
  void set_allocated_market_settlement(::t4proto::v1::market::MarketSettlement* market_settlement);
  private:
  const ::t4proto::v1::market::MarketSettlement& _internal_market_settlement() const;
  ::t4proto::v1::market::MarketSettlement* _internal_mutable_market_settlement();
  public:
  void unsafe_arena_set_allocated_market_settlement(
      ::t4proto::v1::market::MarketSettlement* market_settlement);
  ::t4proto::v1::market::MarketSettlement* unsafe_arena_release_market_settlement();
  // .t4proto.v1.market.MarketSnapshot market_snapshot = 108;
  bool has_market_snapshot() const;
  private:
  bool _internal_has_market_snapshot() const;

  public:
  void clear_market_snapshot() ;
  const ::t4proto::v1::market::MarketSnapshot& market_snapshot() const;
  PROTOBUF_NODISCARD ::t4proto::v1::market::MarketSnapshot* release_market_snapshot();
  ::t4proto::v1::market::MarketSnapshot* mutable_market_snapshot();
  void set_allocated_market_snapshot(::t4proto::v1::market::MarketSnapshot* market_snapshot);
  private:
  const ::t4proto::v1::market::MarketSnapshot& _internal_market_snapshot() const;
  ::t4proto::v1::market::MarketSnapshot* _internal_mutable_market_snapshot();
  public:
  void unsafe_arena_set_allocated_market_snapshot(
      ::t4proto::v1::market::MarketSnapshot* market_snapshot);
  ::t4proto::v1::market::MarketSnapshot* unsafe_arena_release_market_snapshot();
  // .t4proto.v1.market.MarketByOrderSnapshot market_by_order_snapshot = 109;
  bool has_market_by_order_snapshot() const;
  private:
  bool _internal_has_market_by_order_snapshot() const;

  public:
  void clear_market_by_order_snapshot() ;
  const ::t4proto::v1::market::MarketByOrderSnapshot& market_by_order_snapshot() const;
  PROTOBUF_NODISCARD ::t4proto::v1::market::MarketByOrderSnapshot* release_market_by_order_snapshot();
  ::t4proto::v1::market::MarketByOrderSnapshot* mutable_market_by_order_snapshot();
  void set_allocated_market_by_order_snapshot(::t4proto::v1::market::MarketByOrderSnapshot* market_by_order_snapshot);
  private:
  const ::t4proto::v1::market::MarketByOrderSnapshot& _internal_market_by_order_snapshot() const;
  ::t4proto::v1::market::MarketByOrderSnapshot* _internal_mutable_market_by_order_snapshot();
  public:
  void unsafe_arena_set_allocated_market_by_order_snapshot(
      ::t4proto::v1::market::MarketByOrderSnapshot* market_by_order_snapshot);
  ::t4proto::v1::market::MarketByOrderSnapshot* unsafe_arena_release_market_by_order_snapshot();
  // .t4proto.v1.market.MarketByOrderUpdate market_by_order_update = 110;
  bool has_market_by_order_update() const;
  private:
  bool _internal_has_market_by_order_update() const;

  public:
  void clear_market_by_order_update() ;
  const ::t4proto::v1::market::MarketByOrderUpdate& market_by_order_update() const;
  PROTOBUF_NODISCARD ::t4proto::v1::market::MarketByOrderUpdate* release_market_by_order_update();
  ::t4proto::v1::market::MarketByOrderUpdate* mutable_market_by_order_update();
  void set_allocated_market_by_order_update(::t4proto::v1::market::MarketByOrderUpdate* market_by_order_update);
  private:
  const ::t4proto::v1::market::MarketByOrderUpdate& _internal_market_by_order_update() const;
  ::t4proto::v1::market::MarketByOrderUpdate* _internal_mutable_market_by_order_update();
  public:
  void unsafe_arena_set_allocated_market_by_order_update(
      ::t4proto::v1::market::MarketByOrderUpdate* market_by_order_update);
  ::t4proto::v1::market::MarketByOrderUpdate* unsafe_arena_release_market_by_order_update();
  // .t4proto.v1.account.AccountSubscribeResponse account_subscribe_response = 200;
  bool has_account_subscribe_response() const;
  private:
  bool _internal_has_account_subscribe_response() const;

  public:
  void clear_account_subscribe_response() ;
  const ::t4proto::v1::account::AccountSubscribeResponse& account_subscribe_response() const;
  PROTOBUF_NODISCARD ::t4proto::v1::account::AccountSubscribeResponse* release_account_subscribe_response();
  ::t4proto::v1::account::AccountSubscribeResponse* mutable_account_subscribe_response();
  void set_allocated_account_subscribe_response(::t4proto::v1::account::AccountSubscribeResponse* account_subscribe_response);
  private:
  const ::t4proto::v1::account::AccountSubscribeResponse& _internal_account_subscribe_response() const;
  ::t4proto::v1::account::AccountSubscribeResponse* _internal_mutable_account_subscribe_response();
  public:
  void unsafe_arena_set_allocated_account_subscribe_response(
      ::t4proto::v1::account::AccountSubscribeResponse* account_subscribe_response);
  ::t4proto::v1::account::AccountSubscribeResponse* unsafe_arena_release_account_subscribe_response();
  // .t4proto.v1.account.AccountCurrency account_currency = 201;
  bool has_account_currency() const;
  private:
  bool _internal_has_account_currency() const;

  public:
  void clear_account_currency() ;
  const ::t4proto::v1::account::AccountCurrency& account_currency() const;
  PROTOBUF_NODISCARD ::t4proto::v1::account::AccountCurrency* release_account_currency();
  ::t4proto::v1::account::AccountCurrency* mutable_account_currency();
  void set_allocated_account_currency(::t4proto::v1::account::AccountCurrency* account_currency);
  private:
  const ::t4proto::v1::account::AccountCurrency& _internal_account_currency() const;
  ::t4proto::v1::account::AccountCurrency* _internal_mutable_account_currency();
  public:
  void unsafe_arena_set_allocated_account_currency(
      ::t4proto::v1::account::AccountCurrency* account_currency);
  ::t4proto::v1::account::AccountCurrency* unsafe_arena_release_account_currency();
  // .t4proto.v1.account.AccountPosition account_position = 202;
  bool has_account_position() const;
  private:
  bool _internal_has_account_position() const;

  public:
  void clear_account_position() ;
  const ::t4proto::v1::account::AccountPosition& account_position() const;
  PROTOBUF_NODISCARD ::t4proto::v1::account::AccountPosition* release_account_position();
  ::t4proto::v1::account::AccountPosition* mutable_account_position();
  void set_allocated_account_position(::t4proto::v1::account::AccountPosition* account_position);
  private:
  const ::t4proto::v1::account::AccountPosition& _internal_account_position() const;
  ::t4proto::v1::account::AccountPosition* _internal_mutable_account_position();
  public:
  void unsafe_arena_set_allocated_account_position(
      ::t4proto::v1::account::AccountPosition* account_position);
  ::t4proto::v1::account::AccountPosition* unsafe_arena_release_account_position();
  // .t4proto.v1.account.AccountUpdate account_update = 203;
  bool has_account_update() const;
  private:
  bool _internal_has_account_update() const;

  public:
  void clear_account_update() ;
  const ::t4proto::v1::account::AccountUpdate& account_update() const;
  PROTOBUF_NODISCARD ::t4proto::v1::account::AccountUpdate* release_account_update();
  ::t4proto::v1::account::AccountUpdate* mutable_account_update();
  void set_allocated_account_update(::t4proto::v1::account::AccountUpdate* account_update);
  private:
  const ::t4proto::v1::account::AccountUpdate& _internal_account_update() const;
  ::t4proto::v1::account::AccountUpdate* _internal_mutable_account_update();
  public:
  void unsafe_arena_set_allocated_account_update(
      ::t4proto::v1::account::AccountUpdate* account_update);
  ::t4proto::v1::account::AccountUpdate* unsafe_arena_release_account_update();
  // .t4proto.v1.account.AccountDetails account_details = 204;
  bool has_account_details() const;
  private:
  bool _internal_has_account_details() const;

  public:
  void clear_account_details() ;
  const ::t4proto::v1::account::AccountDetails& account_details() const;
  PROTOBUF_NODISCARD ::t4proto::v1::account::AccountDetails* release_account_details();
  ::t4proto::v1::account::AccountDetails* mutable_account_details();
  void set_allocated_account_details(::t4proto::v1::account::AccountDetails* account_details);
  private:
  const ::t4proto::v1::account::AccountDetails& _internal_account_details() const;
  ::t4proto::v1::account::AccountDetails* _internal_mutable_account_details();
  public:
  void unsafe_arena_set_allocated_account_details(
      ::t4proto::v1::account::AccountDetails* account_details);
  ::t4proto::v1::account::AccountDetails* unsafe_arena_release_account_details();
  // .t4proto.v1.account.AccountSnapshot account_snapshot = 205;
  bool has_account_snapshot() const;
  private:
  bool _internal_has_account_snapshot() const;

  public:
  void clear_account_snapshot() ;
  const ::t4proto::v1::account::AccountSnapshot& account_snapshot() const;
  PROTOBUF_NODISCARD ::t4proto::v1::account::AccountSnapshot* release_account_snapshot();
  ::t4proto::v1::account::AccountSnapshot* mutable_account_snapshot();
  void set_allocated_account_snapshot(::t4proto::v1::account::AccountSnapshot* account_snapshot);
  private:
  const ::t4proto::v1::account::AccountSnapshot& _internal_account_snapshot() const;
  ::t4proto::v1::account::AccountSnapshot* _internal_mutable_account_snapshot();
  public:
  void unsafe_arena_set_allocated_account_snapshot(
      ::t4proto::v1::account::AccountSnapshot* account_snapshot);
  ::t4proto::v1::account::AccountSnapshot* unsafe_arena_release_account_snapshot();
  // .t4proto.v1.account.AccountProfit account_profit = 206;
  bool has_account_profit() const;
  private:
  bool _internal_has_account_profit() const;

  public:
  void clear_account_profit() ;
  const ::t4proto::v1::account::AccountProfit& account_profit() const;
  PROTOBUF_NODISCARD ::t4proto::v1::account::AccountProfit* release_account_profit();
  ::t4proto::v1::account::AccountProfit* mutable_account_profit();
  void set_allocated_account_profit(::t4proto::v1::account::AccountProfit* account_profit);
  private:
  const ::t4proto::v1::account::AccountProfit& _internal_account_profit() const;
  ::t4proto::v1::account::AccountProfit* _internal_mutable_account_profit();
  public:
  void unsafe_arena_set_allocated_account_profit(
      ::t4proto::v1::account::AccountProfit* account_profit);
  ::t4proto::v1::account::AccountProfit* unsafe_arena_release_account_profit();
  // .t4proto.v1.account.AccountPositionProfit account_position_profit = 207;
  bool has_account_position_profit() const;
  private:
  bool _internal_has_account_position_profit() const;

  public:
  void clear_account_position_profit() ;
  const ::t4proto::v1::account::AccountPositionProfit& account_position_profit() const;
  PROTOBUF_NODISCARD ::t4proto::v1::account::AccountPositionProfit* release_account_position_profit();
  ::t4proto::v1::account::AccountPositionProfit* mutable_account_position_profit();
  void set_allocated_account_position_profit(::t4proto::v1::account::AccountPositionProfit* account_position_profit);
  private:
  const ::t4proto::v1::account::AccountPositionProfit& _internal_account_position_profit() const;
  ::t4proto::v1::account::AccountPositionProfit* _internal_mutable_account_position_profit();
  public:
  void unsafe_arena_set_allocated_account_position_profit(
      ::t4proto::v1::account::AccountPositionProfit* account_position_profit);
  ::t4proto::v1::account::AccountPositionProfit* unsafe_arena_release_account_position_profit();
  // .t4proto.v1.orderrouting.OrderUpdate order_update = 300;
  bool has_order_update() const;
  private:
  bool _internal_has_order_update() const;

  public:
  void clear_order_update() ;
  const ::t4proto::v1::orderrouting::OrderUpdate& order_update() const;
  PROTOBUF_NODISCARD ::t4proto::v1::orderrouting::OrderUpdate* release_order_update();
  ::t4proto::v1::orderrouting::OrderUpdate* mutable_order_update();
  void set_allocated_order_update(::t4proto::v1::orderrouting::OrderUpdate* order_update);
  private:
  const ::t4proto::v1::orderrouting::OrderUpdate& _internal_order_update() const;
  ::t4proto::v1::orderrouting::OrderUpdate* _internal_mutable_order_update();
  public:
  void unsafe_arena_set_allocated_order_update(
      ::t4proto::v1::orderrouting::OrderUpdate* order_update);
  ::t4proto::v1::orderrouting::OrderUpdate* unsafe_arena_release_order_update();
  // .t4proto.v1.orderrouting.OrderUpdateMulti order_update_multi = 301;
  bool has_order_update_multi() const;
  private:
  bool _internal_has_order_update_multi() const;

  public:
  void clear_order_update_multi() ;
  const ::t4proto::v1::orderrouting::OrderUpdateMulti& order_update_multi() const;
  PROTOBUF_NODISCARD ::t4proto::v1::orderrouting::OrderUpdateMulti* release_order_update_multi();
  ::t4proto::v1::orderrouting::OrderUpdateMulti* mutable_order_update_multi();
  void set_allocated_order_update_multi(::t4proto::v1::orderrouting::OrderUpdateMulti* order_update_multi);
  private:
  const ::t4proto::v1::orderrouting::OrderUpdateMulti& _internal_order_update_multi() const;
  ::t4proto::v1::orderrouting::OrderUpdateMulti* _internal_mutable_order_update_multi();
  public:
  void unsafe_arena_set_allocated_order_update_multi(
      ::t4proto::v1::orderrouting::OrderUpdateMulti* order_update_multi);
  ::t4proto::v1::orderrouting::OrderUpdateMulti* unsafe_arena_release_order_update_multi();
  // .t4proto.v1.orderrouting.OrderUpdateFailed order_update_failed = 302;
  bool has_order_update_failed() const;
  private:
  bool _internal_has_order_update_failed() const;

  public:
  void clear_order_update_failed() ;
  const ::t4proto::v1::orderrouting::OrderUpdateFailed& order_update_failed() const;
  PROTOBUF_NODISCARD ::t4proto::v1::orderrouting::OrderUpdateFailed* release_order_update_failed();
  ::t4proto::v1::orderrouting::OrderUpdateFailed* mutable_order_update_failed();
  void set_allocated_order_update_failed(::t4proto::v1::orderrouting::OrderUpdateFailed* order_update_failed);
  private:
  const ::t4proto::v1::orderrouting::OrderUpdateFailed& _internal_order_update_failed() const;
  ::t4proto::v1::orderrouting::OrderUpdateFailed* _internal_mutable_order_update_failed();
  public:
  void unsafe_arena_set_allocated_order_update_failed(
      ::t4proto::v1::orderrouting::OrderUpdateFailed* order_update_failed);
  ::t4proto::v1::orderrouting::OrderUpdateFailed* unsafe_arena_release_order_update_failed();
  // .t4proto.v1.orderrouting.OrderUpdateStatus order_update_status = 303;
  bool has_order_update_status() const;
  private:
  bool _internal_has_order_update_status() const;

  public:
  void clear_order_update_status() ;
  const ::t4proto::v1::orderrouting::OrderUpdateStatus& order_update_status() const;
  PROTOBUF_NODISCARD ::t4proto::v1::orderrouting::OrderUpdateStatus* release_order_update_status();
  ::t4proto::v1::orderrouting::OrderUpdateStatus* mutable_order_update_status();
  void set_allocated_order_update_status(::t4proto::v1::orderrouting::OrderUpdateStatus* order_update_status);
  private:
  const ::t4proto::v1::orderrouting::OrderUpdateStatus& _internal_order_update_status() const;
  ::t4proto::v1::orderrouting::OrderUpdateStatus* _internal_mutable_order_update_status();
  public:
  void unsafe_arena_set_allocated_order_update_status(
      ::t4proto::v1::orderrouting::OrderUpdateStatus* order_update_status);
  ::t4proto::v1::orderrouting::OrderUpdateStatus* unsafe_arena_release_order_update_status();
  // .t4proto.v1.orderrouting.OrderUpdateTrade order_update_trade = 304;
  bool has_order_update_trade() const;
  private:
  bool _internal_has_order_update_trade() const;

  public:
  void clear_order_update_trade() ;
  const ::t4proto::v1::orderrouting::OrderUpdateTrade& order_update_trade() const;
  PROTOBUF_NODISCARD ::t4proto::v1::orderrouting::OrderUpdateTrade* release_order_update_trade();
  ::t4proto::v1::orderrouting::OrderUpdateTrade* mutable_order_update_trade();
  void set_allocated_order_update_trade(::t4proto::v1::orderrouting::OrderUpdateTrade* order_update_trade);
  private:
  const ::t4proto::v1::orderrouting::OrderUpdateTrade& _internal_order_update_trade() const;
  ::t4proto::v1::orderrouting::OrderUpdateTrade* _internal_mutable_order_update_trade();
  public:
  void unsafe_arena_set_allocated_order_update_trade(
      ::t4proto::v1::orderrouting::OrderUpdateTrade* order_update_trade);
  ::t4proto::v1::orderrouting::OrderUpdateTrade* unsafe_arena_release_order_update_trade();
  // .t4proto.v1.orderrouting.OrderUpdateTradeLeg order_update_trade_leg = 305;
  bool has_order_update_trade_leg() const;
  private:
  bool _internal_has_order_update_trade_leg() const;

  public:
  void clear_order_update_trade_leg() ;
  const ::t4proto::v1::orderrouting::OrderUpdateTradeLeg& order_update_trade_leg() const;
  PROTOBUF_NODISCARD ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* release_order_update_trade_leg();
  ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* mutable_order_update_trade_leg();
  void set_allocated_order_update_trade_leg(::t4proto::v1::orderrouting::OrderUpdateTradeLeg* order_update_trade_leg);
  private:
  const ::t4proto::v1::orderrouting::OrderUpdateTradeLeg& _internal_order_update_trade_leg() const;
  ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* _internal_mutable_order_update_trade_leg();
  public:
  void unsafe_arena_set_allocated_order_update_trade_leg(
      ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* order_update_trade_leg);
  ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* unsafe_arena_release_order_update_trade_leg();
  // .t4proto.v1.orderrouting.CreateUDSResponse create_uds_response = 340;
  bool has_create_uds_response() const;
  private:
  bool _internal_has_create_uds_response() const;

  public:
  void clear_create_uds_response() ;
  const ::t4proto::v1::orderrouting::CreateUDSResponse& create_uds_response() const;
  PROTOBUF_NODISCARD ::t4proto::v1::orderrouting::CreateUDSResponse* release_create_uds_response();
  ::t4proto::v1::orderrouting::CreateUDSResponse* mutable_create_uds_response();
  void set_allocated_create_uds_response(::t4proto::v1::orderrouting::CreateUDSResponse* create_uds_response);
  private:
  const ::t4proto::v1::orderrouting::CreateUDSResponse& _internal_create_uds_response() const;
  ::t4proto::v1::orderrouting::CreateUDSResponse* _internal_mutable_create_uds_response();
  public:
  void unsafe_arena_set_allocated_create_uds_response(
      ::t4proto::v1::orderrouting::CreateUDSResponse* create_uds_response);
  ::t4proto::v1::orderrouting::CreateUDSResponse* unsafe_arena_release_create_uds_response();
  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:t4proto.v1.service.ServerMessage)
 private:
  class _Internal;
  void set_has_heartbeat();
  void set_has_login_response();
  void set_has_authentication_token();
  void set_has_market_depth_subscribe_reject();
  void set_has_market_by_order_subscribe_reject();
  void set_has_market_details();
  void set_has_market_depth();
  void set_has_market_depth_trade();
  void set_has_market_high_low();
  void set_has_market_price_limits();
  void set_has_market_settlement();
  void set_has_market_snapshot();
  void set_has_market_by_order_snapshot();
  void set_has_market_by_order_update();
  void set_has_account_subscribe_response();
  void set_has_account_currency();
  void set_has_account_position();
  void set_has_account_update();
  void set_has_account_details();
  void set_has_account_snapshot();
  void set_has_account_profit();
  void set_has_account_position_profit();
  void set_has_order_update();
  void set_has_order_update_multi();
  void set_has_order_update_failed();
  void set_has_order_update_status();
  void set_has_order_update_trade();
  void set_has_order_update_trade_leg();
  void set_has_create_uds_response();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::t4proto::v1::service::Heartbeat* heartbeat_;
      ::t4proto::v1::auth::LoginResponse* login_response_;
      ::t4proto::v1::auth::AuthenticationToken* authentication_token_;
      ::t4proto::v1::market::MarketDepthSubscribeReject* market_depth_subscribe_reject_;
      ::t4proto::v1::market::MarketByOrderSubscribeReject* market_by_order_subscribe_reject_;
      ::t4proto::v1::market::MarketDetails* market_details_;
      ::t4proto::v1::market::MarketDepth* market_depth_;
      ::t4proto::v1::market::MarketDepthTrade* market_depth_trade_;
      ::t4proto::v1::market::MarketHighLow* market_high_low_;
      ::t4proto::v1::market::MarketPriceLimits* market_price_limits_;
      ::t4proto::v1::market::MarketSettlement* market_settlement_;
      ::t4proto::v1::market::MarketSnapshot* market_snapshot_;
      ::t4proto::v1::market::MarketByOrderSnapshot* market_by_order_snapshot_;
      ::t4proto::v1::market::MarketByOrderUpdate* market_by_order_update_;
      ::t4proto::v1::account::AccountSubscribeResponse* account_subscribe_response_;
      ::t4proto::v1::account::AccountCurrency* account_currency_;
      ::t4proto::v1::account::AccountPosition* account_position_;
      ::t4proto::v1::account::AccountUpdate* account_update_;
      ::t4proto::v1::account::AccountDetails* account_details_;
      ::t4proto::v1::account::AccountSnapshot* account_snapshot_;
      ::t4proto::v1::account::AccountProfit* account_profit_;
      ::t4proto::v1::account::AccountPositionProfit* account_position_profit_;
      ::t4proto::v1::orderrouting::OrderUpdate* order_update_;
      ::t4proto::v1::orderrouting::OrderUpdateMulti* order_update_multi_;
      ::t4proto::v1::orderrouting::OrderUpdateFailed* order_update_failed_;
      ::t4proto::v1::orderrouting::OrderUpdateStatus* order_update_status_;
      ::t4proto::v1::orderrouting::OrderUpdateTrade* order_update_trade_;
      ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* order_update_trade_leg_;
      ::t4proto::v1::orderrouting::CreateUDSResponse* create_uds_response_;
    } payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t4_2fv1_2fservice_2eproto;
};// -------------------------------------------------------------------

class Heartbeat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:t4proto.v1.service.Heartbeat) */ {
 public:
  inline Heartbeat() : Heartbeat(nullptr) {}
  ~Heartbeat() override;
  explicit PROTOBUF_CONSTEXPR Heartbeat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Heartbeat(const Heartbeat& from);
  Heartbeat(Heartbeat&& from) noexcept
    : Heartbeat() {
    *this = ::std::move(from);
  }

  inline Heartbeat& operator=(const Heartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Heartbeat& operator=(Heartbeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Heartbeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Heartbeat* internal_default_instance() {
    return reinterpret_cast<const Heartbeat*>(
               &_Heartbeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Heartbeat& a, Heartbeat& b) {
    a.Swap(&b);
  }
  inline void Swap(Heartbeat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Heartbeat* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Heartbeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Heartbeat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Heartbeat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Heartbeat& from) {
    Heartbeat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Heartbeat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "t4proto.v1.service.Heartbeat";
  }
  protected:
  explicit Heartbeat(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
  };
  // int64 timestamp = 1;
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:t4proto.v1.service.Heartbeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t4_2fv1_2fservice_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ClientMessage

// .t4proto.v1.service.Heartbeat heartbeat = 1;
inline bool ClientMessage::has_heartbeat() const {
  return payload_case() == kHeartbeat;
}
inline bool ClientMessage::_internal_has_heartbeat() const {
  return payload_case() == kHeartbeat;
}
inline void ClientMessage::set_has_heartbeat() {
  _impl_._oneof_case_[0] = kHeartbeat;
}
inline void ClientMessage::clear_heartbeat() {
  if (payload_case() == kHeartbeat) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.heartbeat_;
    }
    clear_has_payload();
  }
}
inline ::t4proto::v1::service::Heartbeat* ClientMessage::release_heartbeat() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ClientMessage.heartbeat)
  if (payload_case() == kHeartbeat) {
    clear_has_payload();
    ::t4proto::v1::service::Heartbeat* temp = _impl_.payload_.heartbeat_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::service::Heartbeat& ClientMessage::_internal_heartbeat() const {
  return payload_case() == kHeartbeat
      ? *_impl_.payload_.heartbeat_
      : reinterpret_cast< ::t4proto::v1::service::Heartbeat&>(::t4proto::v1::service::_Heartbeat_default_instance_);
}
inline const ::t4proto::v1::service::Heartbeat& ClientMessage::heartbeat() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ClientMessage.heartbeat)
  return _internal_heartbeat();
}
inline ::t4proto::v1::service::Heartbeat* ClientMessage::unsafe_arena_release_heartbeat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ClientMessage.heartbeat)
  if (payload_case() == kHeartbeat) {
    clear_has_payload();
    ::t4proto::v1::service::Heartbeat* temp = _impl_.payload_.heartbeat_;
    _impl_.payload_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_heartbeat(::t4proto::v1::service::Heartbeat* heartbeat) {
  clear_payload();
  if (heartbeat) {
    set_has_heartbeat();
    _impl_.payload_.heartbeat_ = heartbeat;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ClientMessage.heartbeat)
}
inline ::t4proto::v1::service::Heartbeat* ClientMessage::_internal_mutable_heartbeat() {
  if (payload_case() != kHeartbeat) {
    clear_payload();
    set_has_heartbeat();
    _impl_.payload_.heartbeat_ = CreateMaybeMessage< ::t4proto::v1::service::Heartbeat >(GetArenaForAllocation());
  }
  return _impl_.payload_.heartbeat_;
}
inline ::t4proto::v1::service::Heartbeat* ClientMessage::mutable_heartbeat() {
  ::t4proto::v1::service::Heartbeat* _msg = _internal_mutable_heartbeat();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ClientMessage.heartbeat)
  return _msg;
}

// .t4proto.v1.auth.LoginRequest login_request = 2;
inline bool ClientMessage::has_login_request() const {
  return payload_case() == kLoginRequest;
}
inline bool ClientMessage::_internal_has_login_request() const {
  return payload_case() == kLoginRequest;
}
inline void ClientMessage::set_has_login_request() {
  _impl_._oneof_case_[0] = kLoginRequest;
}
inline ::t4proto::v1::auth::LoginRequest* ClientMessage::release_login_request() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ClientMessage.login_request)
  if (payload_case() == kLoginRequest) {
    clear_has_payload();
    ::t4proto::v1::auth::LoginRequest* temp = _impl_.payload_.login_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.login_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::auth::LoginRequest& ClientMessage::_internal_login_request() const {
  return payload_case() == kLoginRequest
      ? *_impl_.payload_.login_request_
      : reinterpret_cast< ::t4proto::v1::auth::LoginRequest&>(::t4proto::v1::auth::_LoginRequest_default_instance_);
}
inline const ::t4proto::v1::auth::LoginRequest& ClientMessage::login_request() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ClientMessage.login_request)
  return _internal_login_request();
}
inline ::t4proto::v1::auth::LoginRequest* ClientMessage::unsafe_arena_release_login_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ClientMessage.login_request)
  if (payload_case() == kLoginRequest) {
    clear_has_payload();
    ::t4proto::v1::auth::LoginRequest* temp = _impl_.payload_.login_request_;
    _impl_.payload_.login_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_login_request(::t4proto::v1::auth::LoginRequest* login_request) {
  clear_payload();
  if (login_request) {
    set_has_login_request();
    _impl_.payload_.login_request_ = login_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ClientMessage.login_request)
}
inline ::t4proto::v1::auth::LoginRequest* ClientMessage::_internal_mutable_login_request() {
  if (payload_case() != kLoginRequest) {
    clear_payload();
    set_has_login_request();
    _impl_.payload_.login_request_ = CreateMaybeMessage< ::t4proto::v1::auth::LoginRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.login_request_;
}
inline ::t4proto::v1::auth::LoginRequest* ClientMessage::mutable_login_request() {
  ::t4proto::v1::auth::LoginRequest* _msg = _internal_mutable_login_request();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ClientMessage.login_request)
  return _msg;
}

// .t4proto.v1.auth.AuthenticationTokenRequest authentication_token_request = 3;
inline bool ClientMessage::has_authentication_token_request() const {
  return payload_case() == kAuthenticationTokenRequest;
}
inline bool ClientMessage::_internal_has_authentication_token_request() const {
  return payload_case() == kAuthenticationTokenRequest;
}
inline void ClientMessage::set_has_authentication_token_request() {
  _impl_._oneof_case_[0] = kAuthenticationTokenRequest;
}
inline ::t4proto::v1::auth::AuthenticationTokenRequest* ClientMessage::release_authentication_token_request() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ClientMessage.authentication_token_request)
  if (payload_case() == kAuthenticationTokenRequest) {
    clear_has_payload();
    ::t4proto::v1::auth::AuthenticationTokenRequest* temp = _impl_.payload_.authentication_token_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.authentication_token_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::auth::AuthenticationTokenRequest& ClientMessage::_internal_authentication_token_request() const {
  return payload_case() == kAuthenticationTokenRequest
      ? *_impl_.payload_.authentication_token_request_
      : reinterpret_cast< ::t4proto::v1::auth::AuthenticationTokenRequest&>(::t4proto::v1::auth::_AuthenticationTokenRequest_default_instance_);
}
inline const ::t4proto::v1::auth::AuthenticationTokenRequest& ClientMessage::authentication_token_request() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ClientMessage.authentication_token_request)
  return _internal_authentication_token_request();
}
inline ::t4proto::v1::auth::AuthenticationTokenRequest* ClientMessage::unsafe_arena_release_authentication_token_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ClientMessage.authentication_token_request)
  if (payload_case() == kAuthenticationTokenRequest) {
    clear_has_payload();
    ::t4proto::v1::auth::AuthenticationTokenRequest* temp = _impl_.payload_.authentication_token_request_;
    _impl_.payload_.authentication_token_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_authentication_token_request(::t4proto::v1::auth::AuthenticationTokenRequest* authentication_token_request) {
  clear_payload();
  if (authentication_token_request) {
    set_has_authentication_token_request();
    _impl_.payload_.authentication_token_request_ = authentication_token_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ClientMessage.authentication_token_request)
}
inline ::t4proto::v1::auth::AuthenticationTokenRequest* ClientMessage::_internal_mutable_authentication_token_request() {
  if (payload_case() != kAuthenticationTokenRequest) {
    clear_payload();
    set_has_authentication_token_request();
    _impl_.payload_.authentication_token_request_ = CreateMaybeMessage< ::t4proto::v1::auth::AuthenticationTokenRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.authentication_token_request_;
}
inline ::t4proto::v1::auth::AuthenticationTokenRequest* ClientMessage::mutable_authentication_token_request() {
  ::t4proto::v1::auth::AuthenticationTokenRequest* _msg = _internal_mutable_authentication_token_request();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ClientMessage.authentication_token_request)
  return _msg;
}

// .t4proto.v1.market.MarketDepthSubscribe market_depth_subscribe = 100;
inline bool ClientMessage::has_market_depth_subscribe() const {
  return payload_case() == kMarketDepthSubscribe;
}
inline bool ClientMessage::_internal_has_market_depth_subscribe() const {
  return payload_case() == kMarketDepthSubscribe;
}
inline void ClientMessage::set_has_market_depth_subscribe() {
  _impl_._oneof_case_[0] = kMarketDepthSubscribe;
}
inline ::t4proto::v1::market::MarketDepthSubscribe* ClientMessage::release_market_depth_subscribe() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ClientMessage.market_depth_subscribe)
  if (payload_case() == kMarketDepthSubscribe) {
    clear_has_payload();
    ::t4proto::v1::market::MarketDepthSubscribe* temp = _impl_.payload_.market_depth_subscribe_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_depth_subscribe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketDepthSubscribe& ClientMessage::_internal_market_depth_subscribe() const {
  return payload_case() == kMarketDepthSubscribe
      ? *_impl_.payload_.market_depth_subscribe_
      : reinterpret_cast< ::t4proto::v1::market::MarketDepthSubscribe&>(::t4proto::v1::market::_MarketDepthSubscribe_default_instance_);
}
inline const ::t4proto::v1::market::MarketDepthSubscribe& ClientMessage::market_depth_subscribe() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ClientMessage.market_depth_subscribe)
  return _internal_market_depth_subscribe();
}
inline ::t4proto::v1::market::MarketDepthSubscribe* ClientMessage::unsafe_arena_release_market_depth_subscribe() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ClientMessage.market_depth_subscribe)
  if (payload_case() == kMarketDepthSubscribe) {
    clear_has_payload();
    ::t4proto::v1::market::MarketDepthSubscribe* temp = _impl_.payload_.market_depth_subscribe_;
    _impl_.payload_.market_depth_subscribe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_market_depth_subscribe(::t4proto::v1::market::MarketDepthSubscribe* market_depth_subscribe) {
  clear_payload();
  if (market_depth_subscribe) {
    set_has_market_depth_subscribe();
    _impl_.payload_.market_depth_subscribe_ = market_depth_subscribe;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ClientMessage.market_depth_subscribe)
}
inline ::t4proto::v1::market::MarketDepthSubscribe* ClientMessage::_internal_mutable_market_depth_subscribe() {
  if (payload_case() != kMarketDepthSubscribe) {
    clear_payload();
    set_has_market_depth_subscribe();
    _impl_.payload_.market_depth_subscribe_ = CreateMaybeMessage< ::t4proto::v1::market::MarketDepthSubscribe >(GetArenaForAllocation());
  }
  return _impl_.payload_.market_depth_subscribe_;
}
inline ::t4proto::v1::market::MarketDepthSubscribe* ClientMessage::mutable_market_depth_subscribe() {
  ::t4proto::v1::market::MarketDepthSubscribe* _msg = _internal_mutable_market_depth_subscribe();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ClientMessage.market_depth_subscribe)
  return _msg;
}

// .t4proto.v1.market.MarketByOrderSubscribe market_by_order_subscribe = 101;
inline bool ClientMessage::has_market_by_order_subscribe() const {
  return payload_case() == kMarketByOrderSubscribe;
}
inline bool ClientMessage::_internal_has_market_by_order_subscribe() const {
  return payload_case() == kMarketByOrderSubscribe;
}
inline void ClientMessage::set_has_market_by_order_subscribe() {
  _impl_._oneof_case_[0] = kMarketByOrderSubscribe;
}
inline ::t4proto::v1::market::MarketByOrderSubscribe* ClientMessage::release_market_by_order_subscribe() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ClientMessage.market_by_order_subscribe)
  if (payload_case() == kMarketByOrderSubscribe) {
    clear_has_payload();
    ::t4proto::v1::market::MarketByOrderSubscribe* temp = _impl_.payload_.market_by_order_subscribe_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_by_order_subscribe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketByOrderSubscribe& ClientMessage::_internal_market_by_order_subscribe() const {
  return payload_case() == kMarketByOrderSubscribe
      ? *_impl_.payload_.market_by_order_subscribe_
      : reinterpret_cast< ::t4proto::v1::market::MarketByOrderSubscribe&>(::t4proto::v1::market::_MarketByOrderSubscribe_default_instance_);
}
inline const ::t4proto::v1::market::MarketByOrderSubscribe& ClientMessage::market_by_order_subscribe() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ClientMessage.market_by_order_subscribe)
  return _internal_market_by_order_subscribe();
}
inline ::t4proto::v1::market::MarketByOrderSubscribe* ClientMessage::unsafe_arena_release_market_by_order_subscribe() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ClientMessage.market_by_order_subscribe)
  if (payload_case() == kMarketByOrderSubscribe) {
    clear_has_payload();
    ::t4proto::v1::market::MarketByOrderSubscribe* temp = _impl_.payload_.market_by_order_subscribe_;
    _impl_.payload_.market_by_order_subscribe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_market_by_order_subscribe(::t4proto::v1::market::MarketByOrderSubscribe* market_by_order_subscribe) {
  clear_payload();
  if (market_by_order_subscribe) {
    set_has_market_by_order_subscribe();
    _impl_.payload_.market_by_order_subscribe_ = market_by_order_subscribe;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ClientMessage.market_by_order_subscribe)
}
inline ::t4proto::v1::market::MarketByOrderSubscribe* ClientMessage::_internal_mutable_market_by_order_subscribe() {
  if (payload_case() != kMarketByOrderSubscribe) {
    clear_payload();
    set_has_market_by_order_subscribe();
    _impl_.payload_.market_by_order_subscribe_ = CreateMaybeMessage< ::t4proto::v1::market::MarketByOrderSubscribe >(GetArenaForAllocation());
  }
  return _impl_.payload_.market_by_order_subscribe_;
}
inline ::t4proto::v1::market::MarketByOrderSubscribe* ClientMessage::mutable_market_by_order_subscribe() {
  ::t4proto::v1::market::MarketByOrderSubscribe* _msg = _internal_mutable_market_by_order_subscribe();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ClientMessage.market_by_order_subscribe)
  return _msg;
}

// .t4proto.v1.account.AccountSubscribe account_subscribe = 200;
inline bool ClientMessage::has_account_subscribe() const {
  return payload_case() == kAccountSubscribe;
}
inline bool ClientMessage::_internal_has_account_subscribe() const {
  return payload_case() == kAccountSubscribe;
}
inline void ClientMessage::set_has_account_subscribe() {
  _impl_._oneof_case_[0] = kAccountSubscribe;
}
inline ::t4proto::v1::account::AccountSubscribe* ClientMessage::release_account_subscribe() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ClientMessage.account_subscribe)
  if (payload_case() == kAccountSubscribe) {
    clear_has_payload();
    ::t4proto::v1::account::AccountSubscribe* temp = _impl_.payload_.account_subscribe_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.account_subscribe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::account::AccountSubscribe& ClientMessage::_internal_account_subscribe() const {
  return payload_case() == kAccountSubscribe
      ? *_impl_.payload_.account_subscribe_
      : reinterpret_cast< ::t4proto::v1::account::AccountSubscribe&>(::t4proto::v1::account::_AccountSubscribe_default_instance_);
}
inline const ::t4proto::v1::account::AccountSubscribe& ClientMessage::account_subscribe() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ClientMessage.account_subscribe)
  return _internal_account_subscribe();
}
inline ::t4proto::v1::account::AccountSubscribe* ClientMessage::unsafe_arena_release_account_subscribe() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ClientMessage.account_subscribe)
  if (payload_case() == kAccountSubscribe) {
    clear_has_payload();
    ::t4proto::v1::account::AccountSubscribe* temp = _impl_.payload_.account_subscribe_;
    _impl_.payload_.account_subscribe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_account_subscribe(::t4proto::v1::account::AccountSubscribe* account_subscribe) {
  clear_payload();
  if (account_subscribe) {
    set_has_account_subscribe();
    _impl_.payload_.account_subscribe_ = account_subscribe;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ClientMessage.account_subscribe)
}
inline ::t4proto::v1::account::AccountSubscribe* ClientMessage::_internal_mutable_account_subscribe() {
  if (payload_case() != kAccountSubscribe) {
    clear_payload();
    set_has_account_subscribe();
    _impl_.payload_.account_subscribe_ = CreateMaybeMessage< ::t4proto::v1::account::AccountSubscribe >(GetArenaForAllocation());
  }
  return _impl_.payload_.account_subscribe_;
}
inline ::t4proto::v1::account::AccountSubscribe* ClientMessage::mutable_account_subscribe() {
  ::t4proto::v1::account::AccountSubscribe* _msg = _internal_mutable_account_subscribe();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ClientMessage.account_subscribe)
  return _msg;
}

// .t4proto.v1.orderrouting.OrderSubmit order_submit = 300;
inline bool ClientMessage::has_order_submit() const {
  return payload_case() == kOrderSubmit;
}
inline bool ClientMessage::_internal_has_order_submit() const {
  return payload_case() == kOrderSubmit;
}
inline void ClientMessage::set_has_order_submit() {
  _impl_._oneof_case_[0] = kOrderSubmit;
}
inline ::t4proto::v1::orderrouting::OrderSubmit* ClientMessage::release_order_submit() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ClientMessage.order_submit)
  if (payload_case() == kOrderSubmit) {
    clear_has_payload();
    ::t4proto::v1::orderrouting::OrderSubmit* temp = _impl_.payload_.order_submit_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.order_submit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::OrderSubmit& ClientMessage::_internal_order_submit() const {
  return payload_case() == kOrderSubmit
      ? *_impl_.payload_.order_submit_
      : reinterpret_cast< ::t4proto::v1::orderrouting::OrderSubmit&>(::t4proto::v1::orderrouting::_OrderSubmit_default_instance_);
}
inline const ::t4proto::v1::orderrouting::OrderSubmit& ClientMessage::order_submit() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ClientMessage.order_submit)
  return _internal_order_submit();
}
inline ::t4proto::v1::orderrouting::OrderSubmit* ClientMessage::unsafe_arena_release_order_submit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ClientMessage.order_submit)
  if (payload_case() == kOrderSubmit) {
    clear_has_payload();
    ::t4proto::v1::orderrouting::OrderSubmit* temp = _impl_.payload_.order_submit_;
    _impl_.payload_.order_submit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_order_submit(::t4proto::v1::orderrouting::OrderSubmit* order_submit) {
  clear_payload();
  if (order_submit) {
    set_has_order_submit();
    _impl_.payload_.order_submit_ = order_submit;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ClientMessage.order_submit)
}
inline ::t4proto::v1::orderrouting::OrderSubmit* ClientMessage::_internal_mutable_order_submit() {
  if (payload_case() != kOrderSubmit) {
    clear_payload();
    set_has_order_submit();
    _impl_.payload_.order_submit_ = CreateMaybeMessage< ::t4proto::v1::orderrouting::OrderSubmit >(GetArenaForAllocation());
  }
  return _impl_.payload_.order_submit_;
}
inline ::t4proto::v1::orderrouting::OrderSubmit* ClientMessage::mutable_order_submit() {
  ::t4proto::v1::orderrouting::OrderSubmit* _msg = _internal_mutable_order_submit();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ClientMessage.order_submit)
  return _msg;
}

// .t4proto.v1.orderrouting.OrderRevise order_revise = 301;
inline bool ClientMessage::has_order_revise() const {
  return payload_case() == kOrderRevise;
}
inline bool ClientMessage::_internal_has_order_revise() const {
  return payload_case() == kOrderRevise;
}
inline void ClientMessage::set_has_order_revise() {
  _impl_._oneof_case_[0] = kOrderRevise;
}
inline ::t4proto::v1::orderrouting::OrderRevise* ClientMessage::release_order_revise() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ClientMessage.order_revise)
  if (payload_case() == kOrderRevise) {
    clear_has_payload();
    ::t4proto::v1::orderrouting::OrderRevise* temp = _impl_.payload_.order_revise_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.order_revise_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::OrderRevise& ClientMessage::_internal_order_revise() const {
  return payload_case() == kOrderRevise
      ? *_impl_.payload_.order_revise_
      : reinterpret_cast< ::t4proto::v1::orderrouting::OrderRevise&>(::t4proto::v1::orderrouting::_OrderRevise_default_instance_);
}
inline const ::t4proto::v1::orderrouting::OrderRevise& ClientMessage::order_revise() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ClientMessage.order_revise)
  return _internal_order_revise();
}
inline ::t4proto::v1::orderrouting::OrderRevise* ClientMessage::unsafe_arena_release_order_revise() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ClientMessage.order_revise)
  if (payload_case() == kOrderRevise) {
    clear_has_payload();
    ::t4proto::v1::orderrouting::OrderRevise* temp = _impl_.payload_.order_revise_;
    _impl_.payload_.order_revise_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_order_revise(::t4proto::v1::orderrouting::OrderRevise* order_revise) {
  clear_payload();
  if (order_revise) {
    set_has_order_revise();
    _impl_.payload_.order_revise_ = order_revise;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ClientMessage.order_revise)
}
inline ::t4proto::v1::orderrouting::OrderRevise* ClientMessage::_internal_mutable_order_revise() {
  if (payload_case() != kOrderRevise) {
    clear_payload();
    set_has_order_revise();
    _impl_.payload_.order_revise_ = CreateMaybeMessage< ::t4proto::v1::orderrouting::OrderRevise >(GetArenaForAllocation());
  }
  return _impl_.payload_.order_revise_;
}
inline ::t4proto::v1::orderrouting::OrderRevise* ClientMessage::mutable_order_revise() {
  ::t4proto::v1::orderrouting::OrderRevise* _msg = _internal_mutable_order_revise();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ClientMessage.order_revise)
  return _msg;
}

// .t4proto.v1.orderrouting.OrderPull order_pull = 302;
inline bool ClientMessage::has_order_pull() const {
  return payload_case() == kOrderPull;
}
inline bool ClientMessage::_internal_has_order_pull() const {
  return payload_case() == kOrderPull;
}
inline void ClientMessage::set_has_order_pull() {
  _impl_._oneof_case_[0] = kOrderPull;
}
inline ::t4proto::v1::orderrouting::OrderPull* ClientMessage::release_order_pull() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ClientMessage.order_pull)
  if (payload_case() == kOrderPull) {
    clear_has_payload();
    ::t4proto::v1::orderrouting::OrderPull* temp = _impl_.payload_.order_pull_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.order_pull_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::OrderPull& ClientMessage::_internal_order_pull() const {
  return payload_case() == kOrderPull
      ? *_impl_.payload_.order_pull_
      : reinterpret_cast< ::t4proto::v1::orderrouting::OrderPull&>(::t4proto::v1::orderrouting::_OrderPull_default_instance_);
}
inline const ::t4proto::v1::orderrouting::OrderPull& ClientMessage::order_pull() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ClientMessage.order_pull)
  return _internal_order_pull();
}
inline ::t4proto::v1::orderrouting::OrderPull* ClientMessage::unsafe_arena_release_order_pull() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ClientMessage.order_pull)
  if (payload_case() == kOrderPull) {
    clear_has_payload();
    ::t4proto::v1::orderrouting::OrderPull* temp = _impl_.payload_.order_pull_;
    _impl_.payload_.order_pull_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_order_pull(::t4proto::v1::orderrouting::OrderPull* order_pull) {
  clear_payload();
  if (order_pull) {
    set_has_order_pull();
    _impl_.payload_.order_pull_ = order_pull;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ClientMessage.order_pull)
}
inline ::t4proto::v1::orderrouting::OrderPull* ClientMessage::_internal_mutable_order_pull() {
  if (payload_case() != kOrderPull) {
    clear_payload();
    set_has_order_pull();
    _impl_.payload_.order_pull_ = CreateMaybeMessage< ::t4proto::v1::orderrouting::OrderPull >(GetArenaForAllocation());
  }
  return _impl_.payload_.order_pull_;
}
inline ::t4proto::v1::orderrouting::OrderPull* ClientMessage::mutable_order_pull() {
  ::t4proto::v1::orderrouting::OrderPull* _msg = _internal_mutable_order_pull();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ClientMessage.order_pull)
  return _msg;
}

// .t4proto.v1.orderrouting.CreateUDS create_uds = 340;
inline bool ClientMessage::has_create_uds() const {
  return payload_case() == kCreateUds;
}
inline bool ClientMessage::_internal_has_create_uds() const {
  return payload_case() == kCreateUds;
}
inline void ClientMessage::set_has_create_uds() {
  _impl_._oneof_case_[0] = kCreateUds;
}
inline ::t4proto::v1::orderrouting::CreateUDS* ClientMessage::release_create_uds() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ClientMessage.create_uds)
  if (payload_case() == kCreateUds) {
    clear_has_payload();
    ::t4proto::v1::orderrouting::CreateUDS* temp = _impl_.payload_.create_uds_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.create_uds_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::CreateUDS& ClientMessage::_internal_create_uds() const {
  return payload_case() == kCreateUds
      ? *_impl_.payload_.create_uds_
      : reinterpret_cast< ::t4proto::v1::orderrouting::CreateUDS&>(::t4proto::v1::orderrouting::_CreateUDS_default_instance_);
}
inline const ::t4proto::v1::orderrouting::CreateUDS& ClientMessage::create_uds() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ClientMessage.create_uds)
  return _internal_create_uds();
}
inline ::t4proto::v1::orderrouting::CreateUDS* ClientMessage::unsafe_arena_release_create_uds() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ClientMessage.create_uds)
  if (payload_case() == kCreateUds) {
    clear_has_payload();
    ::t4proto::v1::orderrouting::CreateUDS* temp = _impl_.payload_.create_uds_;
    _impl_.payload_.create_uds_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientMessage::unsafe_arena_set_allocated_create_uds(::t4proto::v1::orderrouting::CreateUDS* create_uds) {
  clear_payload();
  if (create_uds) {
    set_has_create_uds();
    _impl_.payload_.create_uds_ = create_uds;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ClientMessage.create_uds)
}
inline ::t4proto::v1::orderrouting::CreateUDS* ClientMessage::_internal_mutable_create_uds() {
  if (payload_case() != kCreateUds) {
    clear_payload();
    set_has_create_uds();
    _impl_.payload_.create_uds_ = CreateMaybeMessage< ::t4proto::v1::orderrouting::CreateUDS >(GetArenaForAllocation());
  }
  return _impl_.payload_.create_uds_;
}
inline ::t4proto::v1::orderrouting::CreateUDS* ClientMessage::mutable_create_uds() {
  ::t4proto::v1::orderrouting::CreateUDS* _msg = _internal_mutable_create_uds();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ClientMessage.create_uds)
  return _msg;
}

inline bool ClientMessage::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void ClientMessage::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline ClientMessage::PayloadCase ClientMessage::payload_case() const {
  return ClientMessage::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ServerMessage

// .t4proto.v1.service.Heartbeat heartbeat = 1;
inline bool ServerMessage::has_heartbeat() const {
  return payload_case() == kHeartbeat;
}
inline bool ServerMessage::_internal_has_heartbeat() const {
  return payload_case() == kHeartbeat;
}
inline void ServerMessage::set_has_heartbeat() {
  _impl_._oneof_case_[0] = kHeartbeat;
}
inline void ServerMessage::clear_heartbeat() {
  if (payload_case() == kHeartbeat) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.heartbeat_;
    }
    clear_has_payload();
  }
}
inline ::t4proto::v1::service::Heartbeat* ServerMessage::release_heartbeat() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.heartbeat)
  if (payload_case() == kHeartbeat) {
    clear_has_payload();
    ::t4proto::v1::service::Heartbeat* temp = _impl_.payload_.heartbeat_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::service::Heartbeat& ServerMessage::_internal_heartbeat() const {
  return payload_case() == kHeartbeat
      ? *_impl_.payload_.heartbeat_
      : reinterpret_cast< ::t4proto::v1::service::Heartbeat&>(::t4proto::v1::service::_Heartbeat_default_instance_);
}
inline const ::t4proto::v1::service::Heartbeat& ServerMessage::heartbeat() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.heartbeat)
  return _internal_heartbeat();
}
inline ::t4proto::v1::service::Heartbeat* ServerMessage::unsafe_arena_release_heartbeat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.heartbeat)
  if (payload_case() == kHeartbeat) {
    clear_has_payload();
    ::t4proto::v1::service::Heartbeat* temp = _impl_.payload_.heartbeat_;
    _impl_.payload_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_heartbeat(::t4proto::v1::service::Heartbeat* heartbeat) {
  clear_payload();
  if (heartbeat) {
    set_has_heartbeat();
    _impl_.payload_.heartbeat_ = heartbeat;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.heartbeat)
}
inline ::t4proto::v1::service::Heartbeat* ServerMessage::_internal_mutable_heartbeat() {
  if (payload_case() != kHeartbeat) {
    clear_payload();
    set_has_heartbeat();
    _impl_.payload_.heartbeat_ = CreateMaybeMessage< ::t4proto::v1::service::Heartbeat >(GetArenaForAllocation());
  }
  return _impl_.payload_.heartbeat_;
}
inline ::t4proto::v1::service::Heartbeat* ServerMessage::mutable_heartbeat() {
  ::t4proto::v1::service::Heartbeat* _msg = _internal_mutable_heartbeat();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.heartbeat)
  return _msg;
}

// .t4proto.v1.auth.LoginResponse login_response = 2;
inline bool ServerMessage::has_login_response() const {
  return payload_case() == kLoginResponse;
}
inline bool ServerMessage::_internal_has_login_response() const {
  return payload_case() == kLoginResponse;
}
inline void ServerMessage::set_has_login_response() {
  _impl_._oneof_case_[0] = kLoginResponse;
}
inline ::t4proto::v1::auth::LoginResponse* ServerMessage::release_login_response() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.login_response)
  if (payload_case() == kLoginResponse) {
    clear_has_payload();
    ::t4proto::v1::auth::LoginResponse* temp = _impl_.payload_.login_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.login_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::auth::LoginResponse& ServerMessage::_internal_login_response() const {
  return payload_case() == kLoginResponse
      ? *_impl_.payload_.login_response_
      : reinterpret_cast< ::t4proto::v1::auth::LoginResponse&>(::t4proto::v1::auth::_LoginResponse_default_instance_);
}
inline const ::t4proto::v1::auth::LoginResponse& ServerMessage::login_response() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.login_response)
  return _internal_login_response();
}
inline ::t4proto::v1::auth::LoginResponse* ServerMessage::unsafe_arena_release_login_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.login_response)
  if (payload_case() == kLoginResponse) {
    clear_has_payload();
    ::t4proto::v1::auth::LoginResponse* temp = _impl_.payload_.login_response_;
    _impl_.payload_.login_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_login_response(::t4proto::v1::auth::LoginResponse* login_response) {
  clear_payload();
  if (login_response) {
    set_has_login_response();
    _impl_.payload_.login_response_ = login_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.login_response)
}
inline ::t4proto::v1::auth::LoginResponse* ServerMessage::_internal_mutable_login_response() {
  if (payload_case() != kLoginResponse) {
    clear_payload();
    set_has_login_response();
    _impl_.payload_.login_response_ = CreateMaybeMessage< ::t4proto::v1::auth::LoginResponse >(GetArenaForAllocation());
  }
  return _impl_.payload_.login_response_;
}
inline ::t4proto::v1::auth::LoginResponse* ServerMessage::mutable_login_response() {
  ::t4proto::v1::auth::LoginResponse* _msg = _internal_mutable_login_response();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.login_response)
  return _msg;
}

// .t4proto.v1.auth.AuthenticationToken authentication_token = 3;
inline bool ServerMessage::has_authentication_token() const {
  return payload_case() == kAuthenticationToken;
}
inline bool ServerMessage::_internal_has_authentication_token() const {
  return payload_case() == kAuthenticationToken;
}
inline void ServerMessage::set_has_authentication_token() {
  _impl_._oneof_case_[0] = kAuthenticationToken;
}
inline ::t4proto::v1::auth::AuthenticationToken* ServerMessage::release_authentication_token() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.authentication_token)
  if (payload_case() == kAuthenticationToken) {
    clear_has_payload();
    ::t4proto::v1::auth::AuthenticationToken* temp = _impl_.payload_.authentication_token_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.authentication_token_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::auth::AuthenticationToken& ServerMessage::_internal_authentication_token() const {
  return payload_case() == kAuthenticationToken
      ? *_impl_.payload_.authentication_token_
      : reinterpret_cast< ::t4proto::v1::auth::AuthenticationToken&>(::t4proto::v1::auth::_AuthenticationToken_default_instance_);
}
inline const ::t4proto::v1::auth::AuthenticationToken& ServerMessage::authentication_token() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.authentication_token)
  return _internal_authentication_token();
}
inline ::t4proto::v1::auth::AuthenticationToken* ServerMessage::unsafe_arena_release_authentication_token() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.authentication_token)
  if (payload_case() == kAuthenticationToken) {
    clear_has_payload();
    ::t4proto::v1::auth::AuthenticationToken* temp = _impl_.payload_.authentication_token_;
    _impl_.payload_.authentication_token_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_authentication_token(::t4proto::v1::auth::AuthenticationToken* authentication_token) {
  clear_payload();
  if (authentication_token) {
    set_has_authentication_token();
    _impl_.payload_.authentication_token_ = authentication_token;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.authentication_token)
}
inline ::t4proto::v1::auth::AuthenticationToken* ServerMessage::_internal_mutable_authentication_token() {
  if (payload_case() != kAuthenticationToken) {
    clear_payload();
    set_has_authentication_token();
    _impl_.payload_.authentication_token_ = CreateMaybeMessage< ::t4proto::v1::auth::AuthenticationToken >(GetArenaForAllocation());
  }
  return _impl_.payload_.authentication_token_;
}
inline ::t4proto::v1::auth::AuthenticationToken* ServerMessage::mutable_authentication_token() {
  ::t4proto::v1::auth::AuthenticationToken* _msg = _internal_mutable_authentication_token();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.authentication_token)
  return _msg;
}

// .t4proto.v1.market.MarketDepthSubscribeReject market_depth_subscribe_reject = 100;
inline bool ServerMessage::has_market_depth_subscribe_reject() const {
  return payload_case() == kMarketDepthSubscribeReject;
}
inline bool ServerMessage::_internal_has_market_depth_subscribe_reject() const {
  return payload_case() == kMarketDepthSubscribeReject;
}
inline void ServerMessage::set_has_market_depth_subscribe_reject() {
  _impl_._oneof_case_[0] = kMarketDepthSubscribeReject;
}
inline ::t4proto::v1::market::MarketDepthSubscribeReject* ServerMessage::release_market_depth_subscribe_reject() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_depth_subscribe_reject)
  if (payload_case() == kMarketDepthSubscribeReject) {
    clear_has_payload();
    ::t4proto::v1::market::MarketDepthSubscribeReject* temp = _impl_.payload_.market_depth_subscribe_reject_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_depth_subscribe_reject_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketDepthSubscribeReject& ServerMessage::_internal_market_depth_subscribe_reject() const {
  return payload_case() == kMarketDepthSubscribeReject
      ? *_impl_.payload_.market_depth_subscribe_reject_
      : reinterpret_cast< ::t4proto::v1::market::MarketDepthSubscribeReject&>(::t4proto::v1::market::_MarketDepthSubscribeReject_default_instance_);
}
inline const ::t4proto::v1::market::MarketDepthSubscribeReject& ServerMessage::market_depth_subscribe_reject() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_depth_subscribe_reject)
  return _internal_market_depth_subscribe_reject();
}
inline ::t4proto::v1::market::MarketDepthSubscribeReject* ServerMessage::unsafe_arena_release_market_depth_subscribe_reject() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_depth_subscribe_reject)
  if (payload_case() == kMarketDepthSubscribeReject) {
    clear_has_payload();
    ::t4proto::v1::market::MarketDepthSubscribeReject* temp = _impl_.payload_.market_depth_subscribe_reject_;
    _impl_.payload_.market_depth_subscribe_reject_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_depth_subscribe_reject(::t4proto::v1::market::MarketDepthSubscribeReject* market_depth_subscribe_reject) {
  clear_payload();
  if (market_depth_subscribe_reject) {
    set_has_market_depth_subscribe_reject();
    _impl_.payload_.market_depth_subscribe_reject_ = market_depth_subscribe_reject;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_depth_subscribe_reject)
}
inline ::t4proto::v1::market::MarketDepthSubscribeReject* ServerMessage::_internal_mutable_market_depth_subscribe_reject() {
  if (payload_case() != kMarketDepthSubscribeReject) {
    clear_payload();
    set_has_market_depth_subscribe_reject();
    _impl_.payload_.market_depth_subscribe_reject_ = CreateMaybeMessage< ::t4proto::v1::market::MarketDepthSubscribeReject >(GetArenaForAllocation());
  }
  return _impl_.payload_.market_depth_subscribe_reject_;
}
inline ::t4proto::v1::market::MarketDepthSubscribeReject* ServerMessage::mutable_market_depth_subscribe_reject() {
  ::t4proto::v1::market::MarketDepthSubscribeReject* _msg = _internal_mutable_market_depth_subscribe_reject();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_depth_subscribe_reject)
  return _msg;
}

// .t4proto.v1.market.MarketByOrderSubscribeReject market_by_order_subscribe_reject = 101;
inline bool ServerMessage::has_market_by_order_subscribe_reject() const {
  return payload_case() == kMarketByOrderSubscribeReject;
}
inline bool ServerMessage::_internal_has_market_by_order_subscribe_reject() const {
  return payload_case() == kMarketByOrderSubscribeReject;
}
inline void ServerMessage::set_has_market_by_order_subscribe_reject() {
  _impl_._oneof_case_[0] = kMarketByOrderSubscribeReject;
}
inline ::t4proto::v1::market::MarketByOrderSubscribeReject* ServerMessage::release_market_by_order_subscribe_reject() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_by_order_subscribe_reject)
  if (payload_case() == kMarketByOrderSubscribeReject) {
    clear_has_payload();
    ::t4proto::v1::market::MarketByOrderSubscribeReject* temp = _impl_.payload_.market_by_order_subscribe_reject_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_by_order_subscribe_reject_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketByOrderSubscribeReject& ServerMessage::_internal_market_by_order_subscribe_reject() const {
  return payload_case() == kMarketByOrderSubscribeReject
      ? *_impl_.payload_.market_by_order_subscribe_reject_
      : reinterpret_cast< ::t4proto::v1::market::MarketByOrderSubscribeReject&>(::t4proto::v1::market::_MarketByOrderSubscribeReject_default_instance_);
}
inline const ::t4proto::v1::market::MarketByOrderSubscribeReject& ServerMessage::market_by_order_subscribe_reject() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_by_order_subscribe_reject)
  return _internal_market_by_order_subscribe_reject();
}
inline ::t4proto::v1::market::MarketByOrderSubscribeReject* ServerMessage::unsafe_arena_release_market_by_order_subscribe_reject() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_by_order_subscribe_reject)
  if (payload_case() == kMarketByOrderSubscribeReject) {
    clear_has_payload();
    ::t4proto::v1::market::MarketByOrderSubscribeReject* temp = _impl_.payload_.market_by_order_subscribe_reject_;
    _impl_.payload_.market_by_order_subscribe_reject_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_by_order_subscribe_reject(::t4proto::v1::market::MarketByOrderSubscribeReject* market_by_order_subscribe_reject) {
  clear_payload();
  if (market_by_order_subscribe_reject) {
    set_has_market_by_order_subscribe_reject();
    _impl_.payload_.market_by_order_subscribe_reject_ = market_by_order_subscribe_reject;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_by_order_subscribe_reject)
}
inline ::t4proto::v1::market::MarketByOrderSubscribeReject* ServerMessage::_internal_mutable_market_by_order_subscribe_reject() {
  if (payload_case() != kMarketByOrderSubscribeReject) {
    clear_payload();
    set_has_market_by_order_subscribe_reject();
    _impl_.payload_.market_by_order_subscribe_reject_ = CreateMaybeMessage< ::t4proto::v1::market::MarketByOrderSubscribeReject >(GetArenaForAllocation());
  }
  return _impl_.payload_.market_by_order_subscribe_reject_;
}
inline ::t4proto::v1::market::MarketByOrderSubscribeReject* ServerMessage::mutable_market_by_order_subscribe_reject() {
  ::t4proto::v1::market::MarketByOrderSubscribeReject* _msg = _internal_mutable_market_by_order_subscribe_reject();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_by_order_subscribe_reject)
  return _msg;
}

// .t4proto.v1.market.MarketDetails market_details = 102;
inline bool ServerMessage::has_market_details() const {
  return payload_case() == kMarketDetails;
}
inline bool ServerMessage::_internal_has_market_details() const {
  return payload_case() == kMarketDetails;
}
inline void ServerMessage::set_has_market_details() {
  _impl_._oneof_case_[0] = kMarketDetails;
}
inline ::t4proto::v1::market::MarketDetails* ServerMessage::release_market_details() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_details)
  if (payload_case() == kMarketDetails) {
    clear_has_payload();
    ::t4proto::v1::market::MarketDetails* temp = _impl_.payload_.market_details_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_details_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketDetails& ServerMessage::_internal_market_details() const {
  return payload_case() == kMarketDetails
      ? *_impl_.payload_.market_details_
      : reinterpret_cast< ::t4proto::v1::market::MarketDetails&>(::t4proto::v1::market::_MarketDetails_default_instance_);
}
inline const ::t4proto::v1::market::MarketDetails& ServerMessage::market_details() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_details)
  return _internal_market_details();
}
inline ::t4proto::v1::market::MarketDetails* ServerMessage::unsafe_arena_release_market_details() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_details)
  if (payload_case() == kMarketDetails) {
    clear_has_payload();
    ::t4proto::v1::market::MarketDetails* temp = _impl_.payload_.market_details_;
    _impl_.payload_.market_details_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_details(::t4proto::v1::market::MarketDetails* market_details) {
  clear_payload();
  if (market_details) {
    set_has_market_details();
    _impl_.payload_.market_details_ = market_details;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_details)
}
inline ::t4proto::v1::market::MarketDetails* ServerMessage::_internal_mutable_market_details() {
  if (payload_case() != kMarketDetails) {
    clear_payload();
    set_has_market_details();
    _impl_.payload_.market_details_ = CreateMaybeMessage< ::t4proto::v1::market::MarketDetails >(GetArenaForAllocation());
  }
  return _impl_.payload_.market_details_;
}
inline ::t4proto::v1::market::MarketDetails* ServerMessage::mutable_market_details() {
  ::t4proto::v1::market::MarketDetails* _msg = _internal_mutable_market_details();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_details)
  return _msg;
}

// .t4proto.v1.market.MarketDepth market_depth = 103;
inline bool ServerMessage::has_market_depth() const {
  return payload_case() == kMarketDepth;
}
inline bool ServerMessage::_internal_has_market_depth() const {
  return payload_case() == kMarketDepth;
}
inline void ServerMessage::set_has_market_depth() {
  _impl_._oneof_case_[0] = kMarketDepth;
}
inline ::t4proto::v1::market::MarketDepth* ServerMessage::release_market_depth() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_depth)
  if (payload_case() == kMarketDepth) {
    clear_has_payload();
    ::t4proto::v1::market::MarketDepth* temp = _impl_.payload_.market_depth_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_depth_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketDepth& ServerMessage::_internal_market_depth() const {
  return payload_case() == kMarketDepth
      ? *_impl_.payload_.market_depth_
      : reinterpret_cast< ::t4proto::v1::market::MarketDepth&>(::t4proto::v1::market::_MarketDepth_default_instance_);
}
inline const ::t4proto::v1::market::MarketDepth& ServerMessage::market_depth() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_depth)
  return _internal_market_depth();
}
inline ::t4proto::v1::market::MarketDepth* ServerMessage::unsafe_arena_release_market_depth() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_depth)
  if (payload_case() == kMarketDepth) {
    clear_has_payload();
    ::t4proto::v1::market::MarketDepth* temp = _impl_.payload_.market_depth_;
    _impl_.payload_.market_depth_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_depth(::t4proto::v1::market::MarketDepth* market_depth) {
  clear_payload();
  if (market_depth) {
    set_has_market_depth();
    _impl_.payload_.market_depth_ = market_depth;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_depth)
}
inline ::t4proto::v1::market::MarketDepth* ServerMessage::_internal_mutable_market_depth() {
  if (payload_case() != kMarketDepth) {
    clear_payload();
    set_has_market_depth();
    _impl_.payload_.market_depth_ = CreateMaybeMessage< ::t4proto::v1::market::MarketDepth >(GetArenaForAllocation());
  }
  return _impl_.payload_.market_depth_;
}
inline ::t4proto::v1::market::MarketDepth* ServerMessage::mutable_market_depth() {
  ::t4proto::v1::market::MarketDepth* _msg = _internal_mutable_market_depth();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_depth)
  return _msg;
}

// .t4proto.v1.market.MarketDepthTrade market_depth_trade = 104;
inline bool ServerMessage::has_market_depth_trade() const {
  return payload_case() == kMarketDepthTrade;
}
inline bool ServerMessage::_internal_has_market_depth_trade() const {
  return payload_case() == kMarketDepthTrade;
}
inline void ServerMessage::set_has_market_depth_trade() {
  _impl_._oneof_case_[0] = kMarketDepthTrade;
}
inline ::t4proto::v1::market::MarketDepthTrade* ServerMessage::release_market_depth_trade() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_depth_trade)
  if (payload_case() == kMarketDepthTrade) {
    clear_has_payload();
    ::t4proto::v1::market::MarketDepthTrade* temp = _impl_.payload_.market_depth_trade_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_depth_trade_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketDepthTrade& ServerMessage::_internal_market_depth_trade() const {
  return payload_case() == kMarketDepthTrade
      ? *_impl_.payload_.market_depth_trade_
      : reinterpret_cast< ::t4proto::v1::market::MarketDepthTrade&>(::t4proto::v1::market::_MarketDepthTrade_default_instance_);
}
inline const ::t4proto::v1::market::MarketDepthTrade& ServerMessage::market_depth_trade() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_depth_trade)
  return _internal_market_depth_trade();
}
inline ::t4proto::v1::market::MarketDepthTrade* ServerMessage::unsafe_arena_release_market_depth_trade() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_depth_trade)
  if (payload_case() == kMarketDepthTrade) {
    clear_has_payload();
    ::t4proto::v1::market::MarketDepthTrade* temp = _impl_.payload_.market_depth_trade_;
    _impl_.payload_.market_depth_trade_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_depth_trade(::t4proto::v1::market::MarketDepthTrade* market_depth_trade) {
  clear_payload();
  if (market_depth_trade) {
    set_has_market_depth_trade();
    _impl_.payload_.market_depth_trade_ = market_depth_trade;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_depth_trade)
}
inline ::t4proto::v1::market::MarketDepthTrade* ServerMessage::_internal_mutable_market_depth_trade() {
  if (payload_case() != kMarketDepthTrade) {
    clear_payload();
    set_has_market_depth_trade();
    _impl_.payload_.market_depth_trade_ = CreateMaybeMessage< ::t4proto::v1::market::MarketDepthTrade >(GetArenaForAllocation());
  }
  return _impl_.payload_.market_depth_trade_;
}
inline ::t4proto::v1::market::MarketDepthTrade* ServerMessage::mutable_market_depth_trade() {
  ::t4proto::v1::market::MarketDepthTrade* _msg = _internal_mutable_market_depth_trade();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_depth_trade)
  return _msg;
}

// .t4proto.v1.market.MarketHighLow market_high_low = 105;
inline bool ServerMessage::has_market_high_low() const {
  return payload_case() == kMarketHighLow;
}
inline bool ServerMessage::_internal_has_market_high_low() const {
  return payload_case() == kMarketHighLow;
}
inline void ServerMessage::set_has_market_high_low() {
  _impl_._oneof_case_[0] = kMarketHighLow;
}
inline ::t4proto::v1::market::MarketHighLow* ServerMessage::release_market_high_low() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_high_low)
  if (payload_case() == kMarketHighLow) {
    clear_has_payload();
    ::t4proto::v1::market::MarketHighLow* temp = _impl_.payload_.market_high_low_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_high_low_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketHighLow& ServerMessage::_internal_market_high_low() const {
  return payload_case() == kMarketHighLow
      ? *_impl_.payload_.market_high_low_
      : reinterpret_cast< ::t4proto::v1::market::MarketHighLow&>(::t4proto::v1::market::_MarketHighLow_default_instance_);
}
inline const ::t4proto::v1::market::MarketHighLow& ServerMessage::market_high_low() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_high_low)
  return _internal_market_high_low();
}
inline ::t4proto::v1::market::MarketHighLow* ServerMessage::unsafe_arena_release_market_high_low() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_high_low)
  if (payload_case() == kMarketHighLow) {
    clear_has_payload();
    ::t4proto::v1::market::MarketHighLow* temp = _impl_.payload_.market_high_low_;
    _impl_.payload_.market_high_low_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_high_low(::t4proto::v1::market::MarketHighLow* market_high_low) {
  clear_payload();
  if (market_high_low) {
    set_has_market_high_low();
    _impl_.payload_.market_high_low_ = market_high_low;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_high_low)
}
inline ::t4proto::v1::market::MarketHighLow* ServerMessage::_internal_mutable_market_high_low() {
  if (payload_case() != kMarketHighLow) {
    clear_payload();
    set_has_market_high_low();
    _impl_.payload_.market_high_low_ = CreateMaybeMessage< ::t4proto::v1::market::MarketHighLow >(GetArenaForAllocation());
  }
  return _impl_.payload_.market_high_low_;
}
inline ::t4proto::v1::market::MarketHighLow* ServerMessage::mutable_market_high_low() {
  ::t4proto::v1::market::MarketHighLow* _msg = _internal_mutable_market_high_low();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_high_low)
  return _msg;
}

// .t4proto.v1.market.MarketPriceLimits market_price_limits = 106;
inline bool ServerMessage::has_market_price_limits() const {
  return payload_case() == kMarketPriceLimits;
}
inline bool ServerMessage::_internal_has_market_price_limits() const {
  return payload_case() == kMarketPriceLimits;
}
inline void ServerMessage::set_has_market_price_limits() {
  _impl_._oneof_case_[0] = kMarketPriceLimits;
}
inline ::t4proto::v1::market::MarketPriceLimits* ServerMessage::release_market_price_limits() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_price_limits)
  if (payload_case() == kMarketPriceLimits) {
    clear_has_payload();
    ::t4proto::v1::market::MarketPriceLimits* temp = _impl_.payload_.market_price_limits_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_price_limits_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketPriceLimits& ServerMessage::_internal_market_price_limits() const {
  return payload_case() == kMarketPriceLimits
      ? *_impl_.payload_.market_price_limits_
      : reinterpret_cast< ::t4proto::v1::market::MarketPriceLimits&>(::t4proto::v1::market::_MarketPriceLimits_default_instance_);
}
inline const ::t4proto::v1::market::MarketPriceLimits& ServerMessage::market_price_limits() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_price_limits)
  return _internal_market_price_limits();
}
inline ::t4proto::v1::market::MarketPriceLimits* ServerMessage::unsafe_arena_release_market_price_limits() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_price_limits)
  if (payload_case() == kMarketPriceLimits) {
    clear_has_payload();
    ::t4proto::v1::market::MarketPriceLimits* temp = _impl_.payload_.market_price_limits_;
    _impl_.payload_.market_price_limits_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_price_limits(::t4proto::v1::market::MarketPriceLimits* market_price_limits) {
  clear_payload();
  if (market_price_limits) {
    set_has_market_price_limits();
    _impl_.payload_.market_price_limits_ = market_price_limits;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_price_limits)
}
inline ::t4proto::v1::market::MarketPriceLimits* ServerMessage::_internal_mutable_market_price_limits() {
  if (payload_case() != kMarketPriceLimits) {
    clear_payload();
    set_has_market_price_limits();
    _impl_.payload_.market_price_limits_ = CreateMaybeMessage< ::t4proto::v1::market::MarketPriceLimits >(GetArenaForAllocation());
  }
  return _impl_.payload_.market_price_limits_;
}
inline ::t4proto::v1::market::MarketPriceLimits* ServerMessage::mutable_market_price_limits() {
  ::t4proto::v1::market::MarketPriceLimits* _msg = _internal_mutable_market_price_limits();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_price_limits)
  return _msg;
}

// .t4proto.v1.market.MarketSettlement market_settlement = 107;
inline bool ServerMessage::has_market_settlement() const {
  return payload_case() == kMarketSettlement;
}
inline bool ServerMessage::_internal_has_market_settlement() const {
  return payload_case() == kMarketSettlement;
}
inline void ServerMessage::set_has_market_settlement() {
  _impl_._oneof_case_[0] = kMarketSettlement;
}
inline ::t4proto::v1::market::MarketSettlement* ServerMessage::release_market_settlement() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_settlement)
  if (payload_case() == kMarketSettlement) {
    clear_has_payload();
    ::t4proto::v1::market::MarketSettlement* temp = _impl_.payload_.market_settlement_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_settlement_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketSettlement& ServerMessage::_internal_market_settlement() const {
  return payload_case() == kMarketSettlement
      ? *_impl_.payload_.market_settlement_
      : reinterpret_cast< ::t4proto::v1::market::MarketSettlement&>(::t4proto::v1::market::_MarketSettlement_default_instance_);
}
inline const ::t4proto::v1::market::MarketSettlement& ServerMessage::market_settlement() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_settlement)
  return _internal_market_settlement();
}
inline ::t4proto::v1::market::MarketSettlement* ServerMessage::unsafe_arena_release_market_settlement() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_settlement)
  if (payload_case() == kMarketSettlement) {
    clear_has_payload();
    ::t4proto::v1::market::MarketSettlement* temp = _impl_.payload_.market_settlement_;
    _impl_.payload_.market_settlement_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_settlement(::t4proto::v1::market::MarketSettlement* market_settlement) {
  clear_payload();
  if (market_settlement) {
    set_has_market_settlement();
    _impl_.payload_.market_settlement_ = market_settlement;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_settlement)
}
inline ::t4proto::v1::market::MarketSettlement* ServerMessage::_internal_mutable_market_settlement() {
  if (payload_case() != kMarketSettlement) {
    clear_payload();
    set_has_market_settlement();
    _impl_.payload_.market_settlement_ = CreateMaybeMessage< ::t4proto::v1::market::MarketSettlement >(GetArenaForAllocation());
  }
  return _impl_.payload_.market_settlement_;
}
inline ::t4proto::v1::market::MarketSettlement* ServerMessage::mutable_market_settlement() {
  ::t4proto::v1::market::MarketSettlement* _msg = _internal_mutable_market_settlement();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_settlement)
  return _msg;
}

// .t4proto.v1.market.MarketSnapshot market_snapshot = 108;
inline bool ServerMessage::has_market_snapshot() const {
  return payload_case() == kMarketSnapshot;
}
inline bool ServerMessage::_internal_has_market_snapshot() const {
  return payload_case() == kMarketSnapshot;
}
inline void ServerMessage::set_has_market_snapshot() {
  _impl_._oneof_case_[0] = kMarketSnapshot;
}
inline ::t4proto::v1::market::MarketSnapshot* ServerMessage::release_market_snapshot() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_snapshot)
  if (payload_case() == kMarketSnapshot) {
    clear_has_payload();
    ::t4proto::v1::market::MarketSnapshot* temp = _impl_.payload_.market_snapshot_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketSnapshot& ServerMessage::_internal_market_snapshot() const {
  return payload_case() == kMarketSnapshot
      ? *_impl_.payload_.market_snapshot_
      : reinterpret_cast< ::t4proto::v1::market::MarketSnapshot&>(::t4proto::v1::market::_MarketSnapshot_default_instance_);
}
inline const ::t4proto::v1::market::MarketSnapshot& ServerMessage::market_snapshot() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_snapshot)
  return _internal_market_snapshot();
}
inline ::t4proto::v1::market::MarketSnapshot* ServerMessage::unsafe_arena_release_market_snapshot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_snapshot)
  if (payload_case() == kMarketSnapshot) {
    clear_has_payload();
    ::t4proto::v1::market::MarketSnapshot* temp = _impl_.payload_.market_snapshot_;
    _impl_.payload_.market_snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_snapshot(::t4proto::v1::market::MarketSnapshot* market_snapshot) {
  clear_payload();
  if (market_snapshot) {
    set_has_market_snapshot();
    _impl_.payload_.market_snapshot_ = market_snapshot;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_snapshot)
}
inline ::t4proto::v1::market::MarketSnapshot* ServerMessage::_internal_mutable_market_snapshot() {
  if (payload_case() != kMarketSnapshot) {
    clear_payload();
    set_has_market_snapshot();
    _impl_.payload_.market_snapshot_ = CreateMaybeMessage< ::t4proto::v1::market::MarketSnapshot >(GetArenaForAllocation());
  }
  return _impl_.payload_.market_snapshot_;
}
inline ::t4proto::v1::market::MarketSnapshot* ServerMessage::mutable_market_snapshot() {
  ::t4proto::v1::market::MarketSnapshot* _msg = _internal_mutable_market_snapshot();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_snapshot)
  return _msg;
}

// .t4proto.v1.market.MarketByOrderSnapshot market_by_order_snapshot = 109;
inline bool ServerMessage::has_market_by_order_snapshot() const {
  return payload_case() == kMarketByOrderSnapshot;
}
inline bool ServerMessage::_internal_has_market_by_order_snapshot() const {
  return payload_case() == kMarketByOrderSnapshot;
}
inline void ServerMessage::set_has_market_by_order_snapshot() {
  _impl_._oneof_case_[0] = kMarketByOrderSnapshot;
}
inline ::t4proto::v1::market::MarketByOrderSnapshot* ServerMessage::release_market_by_order_snapshot() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_by_order_snapshot)
  if (payload_case() == kMarketByOrderSnapshot) {
    clear_has_payload();
    ::t4proto::v1::market::MarketByOrderSnapshot* temp = _impl_.payload_.market_by_order_snapshot_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_by_order_snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketByOrderSnapshot& ServerMessage::_internal_market_by_order_snapshot() const {
  return payload_case() == kMarketByOrderSnapshot
      ? *_impl_.payload_.market_by_order_snapshot_
      : reinterpret_cast< ::t4proto::v1::market::MarketByOrderSnapshot&>(::t4proto::v1::market::_MarketByOrderSnapshot_default_instance_);
}
inline const ::t4proto::v1::market::MarketByOrderSnapshot& ServerMessage::market_by_order_snapshot() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_by_order_snapshot)
  return _internal_market_by_order_snapshot();
}
inline ::t4proto::v1::market::MarketByOrderSnapshot* ServerMessage::unsafe_arena_release_market_by_order_snapshot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_by_order_snapshot)
  if (payload_case() == kMarketByOrderSnapshot) {
    clear_has_payload();
    ::t4proto::v1::market::MarketByOrderSnapshot* temp = _impl_.payload_.market_by_order_snapshot_;
    _impl_.payload_.market_by_order_snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_by_order_snapshot(::t4proto::v1::market::MarketByOrderSnapshot* market_by_order_snapshot) {
  clear_payload();
  if (market_by_order_snapshot) {
    set_has_market_by_order_snapshot();
    _impl_.payload_.market_by_order_snapshot_ = market_by_order_snapshot;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_by_order_snapshot)
}
inline ::t4proto::v1::market::MarketByOrderSnapshot* ServerMessage::_internal_mutable_market_by_order_snapshot() {
  if (payload_case() != kMarketByOrderSnapshot) {
    clear_payload();
    set_has_market_by_order_snapshot();
    _impl_.payload_.market_by_order_snapshot_ = CreateMaybeMessage< ::t4proto::v1::market::MarketByOrderSnapshot >(GetArenaForAllocation());
  }
  return _impl_.payload_.market_by_order_snapshot_;
}
inline ::t4proto::v1::market::MarketByOrderSnapshot* ServerMessage::mutable_market_by_order_snapshot() {
  ::t4proto::v1::market::MarketByOrderSnapshot* _msg = _internal_mutable_market_by_order_snapshot();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_by_order_snapshot)
  return _msg;
}

// .t4proto.v1.market.MarketByOrderUpdate market_by_order_update = 110;
inline bool ServerMessage::has_market_by_order_update() const {
  return payload_case() == kMarketByOrderUpdate;
}
inline bool ServerMessage::_internal_has_market_by_order_update() const {
  return payload_case() == kMarketByOrderUpdate;
}
inline void ServerMessage::set_has_market_by_order_update() {
  _impl_._oneof_case_[0] = kMarketByOrderUpdate;
}
inline ::t4proto::v1::market::MarketByOrderUpdate* ServerMessage::release_market_by_order_update() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.market_by_order_update)
  if (payload_case() == kMarketByOrderUpdate) {
    clear_has_payload();
    ::t4proto::v1::market::MarketByOrderUpdate* temp = _impl_.payload_.market_by_order_update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.market_by_order_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::market::MarketByOrderUpdate& ServerMessage::_internal_market_by_order_update() const {
  return payload_case() == kMarketByOrderUpdate
      ? *_impl_.payload_.market_by_order_update_
      : reinterpret_cast< ::t4proto::v1::market::MarketByOrderUpdate&>(::t4proto::v1::market::_MarketByOrderUpdate_default_instance_);
}
inline const ::t4proto::v1::market::MarketByOrderUpdate& ServerMessage::market_by_order_update() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.market_by_order_update)
  return _internal_market_by_order_update();
}
inline ::t4proto::v1::market::MarketByOrderUpdate* ServerMessage::unsafe_arena_release_market_by_order_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.market_by_order_update)
  if (payload_case() == kMarketByOrderUpdate) {
    clear_has_payload();
    ::t4proto::v1::market::MarketByOrderUpdate* temp = _impl_.payload_.market_by_order_update_;
    _impl_.payload_.market_by_order_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_market_by_order_update(::t4proto::v1::market::MarketByOrderUpdate* market_by_order_update) {
  clear_payload();
  if (market_by_order_update) {
    set_has_market_by_order_update();
    _impl_.payload_.market_by_order_update_ = market_by_order_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.market_by_order_update)
}
inline ::t4proto::v1::market::MarketByOrderUpdate* ServerMessage::_internal_mutable_market_by_order_update() {
  if (payload_case() != kMarketByOrderUpdate) {
    clear_payload();
    set_has_market_by_order_update();
    _impl_.payload_.market_by_order_update_ = CreateMaybeMessage< ::t4proto::v1::market::MarketByOrderUpdate >(GetArenaForAllocation());
  }
  return _impl_.payload_.market_by_order_update_;
}
inline ::t4proto::v1::market::MarketByOrderUpdate* ServerMessage::mutable_market_by_order_update() {
  ::t4proto::v1::market::MarketByOrderUpdate* _msg = _internal_mutable_market_by_order_update();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.market_by_order_update)
  return _msg;
}

// .t4proto.v1.account.AccountSubscribeResponse account_subscribe_response = 200;
inline bool ServerMessage::has_account_subscribe_response() const {
  return payload_case() == kAccountSubscribeResponse;
}
inline bool ServerMessage::_internal_has_account_subscribe_response() const {
  return payload_case() == kAccountSubscribeResponse;
}
inline void ServerMessage::set_has_account_subscribe_response() {
  _impl_._oneof_case_[0] = kAccountSubscribeResponse;
}
inline ::t4proto::v1::account::AccountSubscribeResponse* ServerMessage::release_account_subscribe_response() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.account_subscribe_response)
  if (payload_case() == kAccountSubscribeResponse) {
    clear_has_payload();
    ::t4proto::v1::account::AccountSubscribeResponse* temp = _impl_.payload_.account_subscribe_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.account_subscribe_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::account::AccountSubscribeResponse& ServerMessage::_internal_account_subscribe_response() const {
  return payload_case() == kAccountSubscribeResponse
      ? *_impl_.payload_.account_subscribe_response_
      : reinterpret_cast< ::t4proto::v1::account::AccountSubscribeResponse&>(::t4proto::v1::account::_AccountSubscribeResponse_default_instance_);
}
inline const ::t4proto::v1::account::AccountSubscribeResponse& ServerMessage::account_subscribe_response() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.account_subscribe_response)
  return _internal_account_subscribe_response();
}
inline ::t4proto::v1::account::AccountSubscribeResponse* ServerMessage::unsafe_arena_release_account_subscribe_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.account_subscribe_response)
  if (payload_case() == kAccountSubscribeResponse) {
    clear_has_payload();
    ::t4proto::v1::account::AccountSubscribeResponse* temp = _impl_.payload_.account_subscribe_response_;
    _impl_.payload_.account_subscribe_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_account_subscribe_response(::t4proto::v1::account::AccountSubscribeResponse* account_subscribe_response) {
  clear_payload();
  if (account_subscribe_response) {
    set_has_account_subscribe_response();
    _impl_.payload_.account_subscribe_response_ = account_subscribe_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.account_subscribe_response)
}
inline ::t4proto::v1::account::AccountSubscribeResponse* ServerMessage::_internal_mutable_account_subscribe_response() {
  if (payload_case() != kAccountSubscribeResponse) {
    clear_payload();
    set_has_account_subscribe_response();
    _impl_.payload_.account_subscribe_response_ = CreateMaybeMessage< ::t4proto::v1::account::AccountSubscribeResponse >(GetArenaForAllocation());
  }
  return _impl_.payload_.account_subscribe_response_;
}
inline ::t4proto::v1::account::AccountSubscribeResponse* ServerMessage::mutable_account_subscribe_response() {
  ::t4proto::v1::account::AccountSubscribeResponse* _msg = _internal_mutable_account_subscribe_response();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.account_subscribe_response)
  return _msg;
}

// .t4proto.v1.account.AccountCurrency account_currency = 201;
inline bool ServerMessage::has_account_currency() const {
  return payload_case() == kAccountCurrency;
}
inline bool ServerMessage::_internal_has_account_currency() const {
  return payload_case() == kAccountCurrency;
}
inline void ServerMessage::set_has_account_currency() {
  _impl_._oneof_case_[0] = kAccountCurrency;
}
inline ::t4proto::v1::account::AccountCurrency* ServerMessage::release_account_currency() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.account_currency)
  if (payload_case() == kAccountCurrency) {
    clear_has_payload();
    ::t4proto::v1::account::AccountCurrency* temp = _impl_.payload_.account_currency_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.account_currency_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::account::AccountCurrency& ServerMessage::_internal_account_currency() const {
  return payload_case() == kAccountCurrency
      ? *_impl_.payload_.account_currency_
      : reinterpret_cast< ::t4proto::v1::account::AccountCurrency&>(::t4proto::v1::account::_AccountCurrency_default_instance_);
}
inline const ::t4proto::v1::account::AccountCurrency& ServerMessage::account_currency() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.account_currency)
  return _internal_account_currency();
}
inline ::t4proto::v1::account::AccountCurrency* ServerMessage::unsafe_arena_release_account_currency() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.account_currency)
  if (payload_case() == kAccountCurrency) {
    clear_has_payload();
    ::t4proto::v1::account::AccountCurrency* temp = _impl_.payload_.account_currency_;
    _impl_.payload_.account_currency_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_account_currency(::t4proto::v1::account::AccountCurrency* account_currency) {
  clear_payload();
  if (account_currency) {
    set_has_account_currency();
    _impl_.payload_.account_currency_ = account_currency;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.account_currency)
}
inline ::t4proto::v1::account::AccountCurrency* ServerMessage::_internal_mutable_account_currency() {
  if (payload_case() != kAccountCurrency) {
    clear_payload();
    set_has_account_currency();
    _impl_.payload_.account_currency_ = CreateMaybeMessage< ::t4proto::v1::account::AccountCurrency >(GetArenaForAllocation());
  }
  return _impl_.payload_.account_currency_;
}
inline ::t4proto::v1::account::AccountCurrency* ServerMessage::mutable_account_currency() {
  ::t4proto::v1::account::AccountCurrency* _msg = _internal_mutable_account_currency();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.account_currency)
  return _msg;
}

// .t4proto.v1.account.AccountPosition account_position = 202;
inline bool ServerMessage::has_account_position() const {
  return payload_case() == kAccountPosition;
}
inline bool ServerMessage::_internal_has_account_position() const {
  return payload_case() == kAccountPosition;
}
inline void ServerMessage::set_has_account_position() {
  _impl_._oneof_case_[0] = kAccountPosition;
}
inline ::t4proto::v1::account::AccountPosition* ServerMessage::release_account_position() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.account_position)
  if (payload_case() == kAccountPosition) {
    clear_has_payload();
    ::t4proto::v1::account::AccountPosition* temp = _impl_.payload_.account_position_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.account_position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::account::AccountPosition& ServerMessage::_internal_account_position() const {
  return payload_case() == kAccountPosition
      ? *_impl_.payload_.account_position_
      : reinterpret_cast< ::t4proto::v1::account::AccountPosition&>(::t4proto::v1::account::_AccountPosition_default_instance_);
}
inline const ::t4proto::v1::account::AccountPosition& ServerMessage::account_position() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.account_position)
  return _internal_account_position();
}
inline ::t4proto::v1::account::AccountPosition* ServerMessage::unsafe_arena_release_account_position() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.account_position)
  if (payload_case() == kAccountPosition) {
    clear_has_payload();
    ::t4proto::v1::account::AccountPosition* temp = _impl_.payload_.account_position_;
    _impl_.payload_.account_position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_account_position(::t4proto::v1::account::AccountPosition* account_position) {
  clear_payload();
  if (account_position) {
    set_has_account_position();
    _impl_.payload_.account_position_ = account_position;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.account_position)
}
inline ::t4proto::v1::account::AccountPosition* ServerMessage::_internal_mutable_account_position() {
  if (payload_case() != kAccountPosition) {
    clear_payload();
    set_has_account_position();
    _impl_.payload_.account_position_ = CreateMaybeMessage< ::t4proto::v1::account::AccountPosition >(GetArenaForAllocation());
  }
  return _impl_.payload_.account_position_;
}
inline ::t4proto::v1::account::AccountPosition* ServerMessage::mutable_account_position() {
  ::t4proto::v1::account::AccountPosition* _msg = _internal_mutable_account_position();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.account_position)
  return _msg;
}

// .t4proto.v1.account.AccountUpdate account_update = 203;
inline bool ServerMessage::has_account_update() const {
  return payload_case() == kAccountUpdate;
}
inline bool ServerMessage::_internal_has_account_update() const {
  return payload_case() == kAccountUpdate;
}
inline void ServerMessage::set_has_account_update() {
  _impl_._oneof_case_[0] = kAccountUpdate;
}
inline ::t4proto::v1::account::AccountUpdate* ServerMessage::release_account_update() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.account_update)
  if (payload_case() == kAccountUpdate) {
    clear_has_payload();
    ::t4proto::v1::account::AccountUpdate* temp = _impl_.payload_.account_update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.account_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::account::AccountUpdate& ServerMessage::_internal_account_update() const {
  return payload_case() == kAccountUpdate
      ? *_impl_.payload_.account_update_
      : reinterpret_cast< ::t4proto::v1::account::AccountUpdate&>(::t4proto::v1::account::_AccountUpdate_default_instance_);
}
inline const ::t4proto::v1::account::AccountUpdate& ServerMessage::account_update() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.account_update)
  return _internal_account_update();
}
inline ::t4proto::v1::account::AccountUpdate* ServerMessage::unsafe_arena_release_account_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.account_update)
  if (payload_case() == kAccountUpdate) {
    clear_has_payload();
    ::t4proto::v1::account::AccountUpdate* temp = _impl_.payload_.account_update_;
    _impl_.payload_.account_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_account_update(::t4proto::v1::account::AccountUpdate* account_update) {
  clear_payload();
  if (account_update) {
    set_has_account_update();
    _impl_.payload_.account_update_ = account_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.account_update)
}
inline ::t4proto::v1::account::AccountUpdate* ServerMessage::_internal_mutable_account_update() {
  if (payload_case() != kAccountUpdate) {
    clear_payload();
    set_has_account_update();
    _impl_.payload_.account_update_ = CreateMaybeMessage< ::t4proto::v1::account::AccountUpdate >(GetArenaForAllocation());
  }
  return _impl_.payload_.account_update_;
}
inline ::t4proto::v1::account::AccountUpdate* ServerMessage::mutable_account_update() {
  ::t4proto::v1::account::AccountUpdate* _msg = _internal_mutable_account_update();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.account_update)
  return _msg;
}

// .t4proto.v1.account.AccountDetails account_details = 204;
inline bool ServerMessage::has_account_details() const {
  return payload_case() == kAccountDetails;
}
inline bool ServerMessage::_internal_has_account_details() const {
  return payload_case() == kAccountDetails;
}
inline void ServerMessage::set_has_account_details() {
  _impl_._oneof_case_[0] = kAccountDetails;
}
inline ::t4proto::v1::account::AccountDetails* ServerMessage::release_account_details() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.account_details)
  if (payload_case() == kAccountDetails) {
    clear_has_payload();
    ::t4proto::v1::account::AccountDetails* temp = _impl_.payload_.account_details_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.account_details_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::account::AccountDetails& ServerMessage::_internal_account_details() const {
  return payload_case() == kAccountDetails
      ? *_impl_.payload_.account_details_
      : reinterpret_cast< ::t4proto::v1::account::AccountDetails&>(::t4proto::v1::account::_AccountDetails_default_instance_);
}
inline const ::t4proto::v1::account::AccountDetails& ServerMessage::account_details() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.account_details)
  return _internal_account_details();
}
inline ::t4proto::v1::account::AccountDetails* ServerMessage::unsafe_arena_release_account_details() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.account_details)
  if (payload_case() == kAccountDetails) {
    clear_has_payload();
    ::t4proto::v1::account::AccountDetails* temp = _impl_.payload_.account_details_;
    _impl_.payload_.account_details_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_account_details(::t4proto::v1::account::AccountDetails* account_details) {
  clear_payload();
  if (account_details) {
    set_has_account_details();
    _impl_.payload_.account_details_ = account_details;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.account_details)
}
inline ::t4proto::v1::account::AccountDetails* ServerMessage::_internal_mutable_account_details() {
  if (payload_case() != kAccountDetails) {
    clear_payload();
    set_has_account_details();
    _impl_.payload_.account_details_ = CreateMaybeMessage< ::t4proto::v1::account::AccountDetails >(GetArenaForAllocation());
  }
  return _impl_.payload_.account_details_;
}
inline ::t4proto::v1::account::AccountDetails* ServerMessage::mutable_account_details() {
  ::t4proto::v1::account::AccountDetails* _msg = _internal_mutable_account_details();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.account_details)
  return _msg;
}

// .t4proto.v1.account.AccountSnapshot account_snapshot = 205;
inline bool ServerMessage::has_account_snapshot() const {
  return payload_case() == kAccountSnapshot;
}
inline bool ServerMessage::_internal_has_account_snapshot() const {
  return payload_case() == kAccountSnapshot;
}
inline void ServerMessage::set_has_account_snapshot() {
  _impl_._oneof_case_[0] = kAccountSnapshot;
}
inline ::t4proto::v1::account::AccountSnapshot* ServerMessage::release_account_snapshot() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.account_snapshot)
  if (payload_case() == kAccountSnapshot) {
    clear_has_payload();
    ::t4proto::v1::account::AccountSnapshot* temp = _impl_.payload_.account_snapshot_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.account_snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::account::AccountSnapshot& ServerMessage::_internal_account_snapshot() const {
  return payload_case() == kAccountSnapshot
      ? *_impl_.payload_.account_snapshot_
      : reinterpret_cast< ::t4proto::v1::account::AccountSnapshot&>(::t4proto::v1::account::_AccountSnapshot_default_instance_);
}
inline const ::t4proto::v1::account::AccountSnapshot& ServerMessage::account_snapshot() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.account_snapshot)
  return _internal_account_snapshot();
}
inline ::t4proto::v1::account::AccountSnapshot* ServerMessage::unsafe_arena_release_account_snapshot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.account_snapshot)
  if (payload_case() == kAccountSnapshot) {
    clear_has_payload();
    ::t4proto::v1::account::AccountSnapshot* temp = _impl_.payload_.account_snapshot_;
    _impl_.payload_.account_snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_account_snapshot(::t4proto::v1::account::AccountSnapshot* account_snapshot) {
  clear_payload();
  if (account_snapshot) {
    set_has_account_snapshot();
    _impl_.payload_.account_snapshot_ = account_snapshot;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.account_snapshot)
}
inline ::t4proto::v1::account::AccountSnapshot* ServerMessage::_internal_mutable_account_snapshot() {
  if (payload_case() != kAccountSnapshot) {
    clear_payload();
    set_has_account_snapshot();
    _impl_.payload_.account_snapshot_ = CreateMaybeMessage< ::t4proto::v1::account::AccountSnapshot >(GetArenaForAllocation());
  }
  return _impl_.payload_.account_snapshot_;
}
inline ::t4proto::v1::account::AccountSnapshot* ServerMessage::mutable_account_snapshot() {
  ::t4proto::v1::account::AccountSnapshot* _msg = _internal_mutable_account_snapshot();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.account_snapshot)
  return _msg;
}

// .t4proto.v1.account.AccountProfit account_profit = 206;
inline bool ServerMessage::has_account_profit() const {
  return payload_case() == kAccountProfit;
}
inline bool ServerMessage::_internal_has_account_profit() const {
  return payload_case() == kAccountProfit;
}
inline void ServerMessage::set_has_account_profit() {
  _impl_._oneof_case_[0] = kAccountProfit;
}
inline ::t4proto::v1::account::AccountProfit* ServerMessage::release_account_profit() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.account_profit)
  if (payload_case() == kAccountProfit) {
    clear_has_payload();
    ::t4proto::v1::account::AccountProfit* temp = _impl_.payload_.account_profit_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.account_profit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::account::AccountProfit& ServerMessage::_internal_account_profit() const {
  return payload_case() == kAccountProfit
      ? *_impl_.payload_.account_profit_
      : reinterpret_cast< ::t4proto::v1::account::AccountProfit&>(::t4proto::v1::account::_AccountProfit_default_instance_);
}
inline const ::t4proto::v1::account::AccountProfit& ServerMessage::account_profit() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.account_profit)
  return _internal_account_profit();
}
inline ::t4proto::v1::account::AccountProfit* ServerMessage::unsafe_arena_release_account_profit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.account_profit)
  if (payload_case() == kAccountProfit) {
    clear_has_payload();
    ::t4proto::v1::account::AccountProfit* temp = _impl_.payload_.account_profit_;
    _impl_.payload_.account_profit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_account_profit(::t4proto::v1::account::AccountProfit* account_profit) {
  clear_payload();
  if (account_profit) {
    set_has_account_profit();
    _impl_.payload_.account_profit_ = account_profit;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.account_profit)
}
inline ::t4proto::v1::account::AccountProfit* ServerMessage::_internal_mutable_account_profit() {
  if (payload_case() != kAccountProfit) {
    clear_payload();
    set_has_account_profit();
    _impl_.payload_.account_profit_ = CreateMaybeMessage< ::t4proto::v1::account::AccountProfit >(GetArenaForAllocation());
  }
  return _impl_.payload_.account_profit_;
}
inline ::t4proto::v1::account::AccountProfit* ServerMessage::mutable_account_profit() {
  ::t4proto::v1::account::AccountProfit* _msg = _internal_mutable_account_profit();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.account_profit)
  return _msg;
}

// .t4proto.v1.account.AccountPositionProfit account_position_profit = 207;
inline bool ServerMessage::has_account_position_profit() const {
  return payload_case() == kAccountPositionProfit;
}
inline bool ServerMessage::_internal_has_account_position_profit() const {
  return payload_case() == kAccountPositionProfit;
}
inline void ServerMessage::set_has_account_position_profit() {
  _impl_._oneof_case_[0] = kAccountPositionProfit;
}
inline ::t4proto::v1::account::AccountPositionProfit* ServerMessage::release_account_position_profit() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.account_position_profit)
  if (payload_case() == kAccountPositionProfit) {
    clear_has_payload();
    ::t4proto::v1::account::AccountPositionProfit* temp = _impl_.payload_.account_position_profit_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.account_position_profit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::account::AccountPositionProfit& ServerMessage::_internal_account_position_profit() const {
  return payload_case() == kAccountPositionProfit
      ? *_impl_.payload_.account_position_profit_
      : reinterpret_cast< ::t4proto::v1::account::AccountPositionProfit&>(::t4proto::v1::account::_AccountPositionProfit_default_instance_);
}
inline const ::t4proto::v1::account::AccountPositionProfit& ServerMessage::account_position_profit() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.account_position_profit)
  return _internal_account_position_profit();
}
inline ::t4proto::v1::account::AccountPositionProfit* ServerMessage::unsafe_arena_release_account_position_profit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.account_position_profit)
  if (payload_case() == kAccountPositionProfit) {
    clear_has_payload();
    ::t4proto::v1::account::AccountPositionProfit* temp = _impl_.payload_.account_position_profit_;
    _impl_.payload_.account_position_profit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_account_position_profit(::t4proto::v1::account::AccountPositionProfit* account_position_profit) {
  clear_payload();
  if (account_position_profit) {
    set_has_account_position_profit();
    _impl_.payload_.account_position_profit_ = account_position_profit;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.account_position_profit)
}
inline ::t4proto::v1::account::AccountPositionProfit* ServerMessage::_internal_mutable_account_position_profit() {
  if (payload_case() != kAccountPositionProfit) {
    clear_payload();
    set_has_account_position_profit();
    _impl_.payload_.account_position_profit_ = CreateMaybeMessage< ::t4proto::v1::account::AccountPositionProfit >(GetArenaForAllocation());
  }
  return _impl_.payload_.account_position_profit_;
}
inline ::t4proto::v1::account::AccountPositionProfit* ServerMessage::mutable_account_position_profit() {
  ::t4proto::v1::account::AccountPositionProfit* _msg = _internal_mutable_account_position_profit();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.account_position_profit)
  return _msg;
}

// .t4proto.v1.orderrouting.OrderUpdate order_update = 300;
inline bool ServerMessage::has_order_update() const {
  return payload_case() == kOrderUpdate;
}
inline bool ServerMessage::_internal_has_order_update() const {
  return payload_case() == kOrderUpdate;
}
inline void ServerMessage::set_has_order_update() {
  _impl_._oneof_case_[0] = kOrderUpdate;
}
inline ::t4proto::v1::orderrouting::OrderUpdate* ServerMessage::release_order_update() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.order_update)
  if (payload_case() == kOrderUpdate) {
    clear_has_payload();
    ::t4proto::v1::orderrouting::OrderUpdate* temp = _impl_.payload_.order_update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.order_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::OrderUpdate& ServerMessage::_internal_order_update() const {
  return payload_case() == kOrderUpdate
      ? *_impl_.payload_.order_update_
      : reinterpret_cast< ::t4proto::v1::orderrouting::OrderUpdate&>(::t4proto::v1::orderrouting::_OrderUpdate_default_instance_);
}
inline const ::t4proto::v1::orderrouting::OrderUpdate& ServerMessage::order_update() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.order_update)
  return _internal_order_update();
}
inline ::t4proto::v1::orderrouting::OrderUpdate* ServerMessage::unsafe_arena_release_order_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.order_update)
  if (payload_case() == kOrderUpdate) {
    clear_has_payload();
    ::t4proto::v1::orderrouting::OrderUpdate* temp = _impl_.payload_.order_update_;
    _impl_.payload_.order_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_order_update(::t4proto::v1::orderrouting::OrderUpdate* order_update) {
  clear_payload();
  if (order_update) {
    set_has_order_update();
    _impl_.payload_.order_update_ = order_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.order_update)
}
inline ::t4proto::v1::orderrouting::OrderUpdate* ServerMessage::_internal_mutable_order_update() {
  if (payload_case() != kOrderUpdate) {
    clear_payload();
    set_has_order_update();
    _impl_.payload_.order_update_ = CreateMaybeMessage< ::t4proto::v1::orderrouting::OrderUpdate >(GetArenaForAllocation());
  }
  return _impl_.payload_.order_update_;
}
inline ::t4proto::v1::orderrouting::OrderUpdate* ServerMessage::mutable_order_update() {
  ::t4proto::v1::orderrouting::OrderUpdate* _msg = _internal_mutable_order_update();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.order_update)
  return _msg;
}

// .t4proto.v1.orderrouting.OrderUpdateMulti order_update_multi = 301;
inline bool ServerMessage::has_order_update_multi() const {
  return payload_case() == kOrderUpdateMulti;
}
inline bool ServerMessage::_internal_has_order_update_multi() const {
  return payload_case() == kOrderUpdateMulti;
}
inline void ServerMessage::set_has_order_update_multi() {
  _impl_._oneof_case_[0] = kOrderUpdateMulti;
}
inline ::t4proto::v1::orderrouting::OrderUpdateMulti* ServerMessage::release_order_update_multi() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.order_update_multi)
  if (payload_case() == kOrderUpdateMulti) {
    clear_has_payload();
    ::t4proto::v1::orderrouting::OrderUpdateMulti* temp = _impl_.payload_.order_update_multi_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.order_update_multi_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::OrderUpdateMulti& ServerMessage::_internal_order_update_multi() const {
  return payload_case() == kOrderUpdateMulti
      ? *_impl_.payload_.order_update_multi_
      : reinterpret_cast< ::t4proto::v1::orderrouting::OrderUpdateMulti&>(::t4proto::v1::orderrouting::_OrderUpdateMulti_default_instance_);
}
inline const ::t4proto::v1::orderrouting::OrderUpdateMulti& ServerMessage::order_update_multi() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.order_update_multi)
  return _internal_order_update_multi();
}
inline ::t4proto::v1::orderrouting::OrderUpdateMulti* ServerMessage::unsafe_arena_release_order_update_multi() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.order_update_multi)
  if (payload_case() == kOrderUpdateMulti) {
    clear_has_payload();
    ::t4proto::v1::orderrouting::OrderUpdateMulti* temp = _impl_.payload_.order_update_multi_;
    _impl_.payload_.order_update_multi_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_order_update_multi(::t4proto::v1::orderrouting::OrderUpdateMulti* order_update_multi) {
  clear_payload();
  if (order_update_multi) {
    set_has_order_update_multi();
    _impl_.payload_.order_update_multi_ = order_update_multi;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.order_update_multi)
}
inline ::t4proto::v1::orderrouting::OrderUpdateMulti* ServerMessage::_internal_mutable_order_update_multi() {
  if (payload_case() != kOrderUpdateMulti) {
    clear_payload();
    set_has_order_update_multi();
    _impl_.payload_.order_update_multi_ = CreateMaybeMessage< ::t4proto::v1::orderrouting::OrderUpdateMulti >(GetArenaForAllocation());
  }
  return _impl_.payload_.order_update_multi_;
}
inline ::t4proto::v1::orderrouting::OrderUpdateMulti* ServerMessage::mutable_order_update_multi() {
  ::t4proto::v1::orderrouting::OrderUpdateMulti* _msg = _internal_mutable_order_update_multi();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.order_update_multi)
  return _msg;
}

// .t4proto.v1.orderrouting.OrderUpdateFailed order_update_failed = 302;
inline bool ServerMessage::has_order_update_failed() const {
  return payload_case() == kOrderUpdateFailed;
}
inline bool ServerMessage::_internal_has_order_update_failed() const {
  return payload_case() == kOrderUpdateFailed;
}
inline void ServerMessage::set_has_order_update_failed() {
  _impl_._oneof_case_[0] = kOrderUpdateFailed;
}
inline ::t4proto::v1::orderrouting::OrderUpdateFailed* ServerMessage::release_order_update_failed() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.order_update_failed)
  if (payload_case() == kOrderUpdateFailed) {
    clear_has_payload();
    ::t4proto::v1::orderrouting::OrderUpdateFailed* temp = _impl_.payload_.order_update_failed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.order_update_failed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::OrderUpdateFailed& ServerMessage::_internal_order_update_failed() const {
  return payload_case() == kOrderUpdateFailed
      ? *_impl_.payload_.order_update_failed_
      : reinterpret_cast< ::t4proto::v1::orderrouting::OrderUpdateFailed&>(::t4proto::v1::orderrouting::_OrderUpdateFailed_default_instance_);
}
inline const ::t4proto::v1::orderrouting::OrderUpdateFailed& ServerMessage::order_update_failed() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.order_update_failed)
  return _internal_order_update_failed();
}
inline ::t4proto::v1::orderrouting::OrderUpdateFailed* ServerMessage::unsafe_arena_release_order_update_failed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.order_update_failed)
  if (payload_case() == kOrderUpdateFailed) {
    clear_has_payload();
    ::t4proto::v1::orderrouting::OrderUpdateFailed* temp = _impl_.payload_.order_update_failed_;
    _impl_.payload_.order_update_failed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_order_update_failed(::t4proto::v1::orderrouting::OrderUpdateFailed* order_update_failed) {
  clear_payload();
  if (order_update_failed) {
    set_has_order_update_failed();
    _impl_.payload_.order_update_failed_ = order_update_failed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.order_update_failed)
}
inline ::t4proto::v1::orderrouting::OrderUpdateFailed* ServerMessage::_internal_mutable_order_update_failed() {
  if (payload_case() != kOrderUpdateFailed) {
    clear_payload();
    set_has_order_update_failed();
    _impl_.payload_.order_update_failed_ = CreateMaybeMessage< ::t4proto::v1::orderrouting::OrderUpdateFailed >(GetArenaForAllocation());
  }
  return _impl_.payload_.order_update_failed_;
}
inline ::t4proto::v1::orderrouting::OrderUpdateFailed* ServerMessage::mutable_order_update_failed() {
  ::t4proto::v1::orderrouting::OrderUpdateFailed* _msg = _internal_mutable_order_update_failed();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.order_update_failed)
  return _msg;
}

// .t4proto.v1.orderrouting.OrderUpdateStatus order_update_status = 303;
inline bool ServerMessage::has_order_update_status() const {
  return payload_case() == kOrderUpdateStatus;
}
inline bool ServerMessage::_internal_has_order_update_status() const {
  return payload_case() == kOrderUpdateStatus;
}
inline void ServerMessage::set_has_order_update_status() {
  _impl_._oneof_case_[0] = kOrderUpdateStatus;
}
inline ::t4proto::v1::orderrouting::OrderUpdateStatus* ServerMessage::release_order_update_status() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.order_update_status)
  if (payload_case() == kOrderUpdateStatus) {
    clear_has_payload();
    ::t4proto::v1::orderrouting::OrderUpdateStatus* temp = _impl_.payload_.order_update_status_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.order_update_status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::OrderUpdateStatus& ServerMessage::_internal_order_update_status() const {
  return payload_case() == kOrderUpdateStatus
      ? *_impl_.payload_.order_update_status_
      : reinterpret_cast< ::t4proto::v1::orderrouting::OrderUpdateStatus&>(::t4proto::v1::orderrouting::_OrderUpdateStatus_default_instance_);
}
inline const ::t4proto::v1::orderrouting::OrderUpdateStatus& ServerMessage::order_update_status() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.order_update_status)
  return _internal_order_update_status();
}
inline ::t4proto::v1::orderrouting::OrderUpdateStatus* ServerMessage::unsafe_arena_release_order_update_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.order_update_status)
  if (payload_case() == kOrderUpdateStatus) {
    clear_has_payload();
    ::t4proto::v1::orderrouting::OrderUpdateStatus* temp = _impl_.payload_.order_update_status_;
    _impl_.payload_.order_update_status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_order_update_status(::t4proto::v1::orderrouting::OrderUpdateStatus* order_update_status) {
  clear_payload();
  if (order_update_status) {
    set_has_order_update_status();
    _impl_.payload_.order_update_status_ = order_update_status;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.order_update_status)
}
inline ::t4proto::v1::orderrouting::OrderUpdateStatus* ServerMessage::_internal_mutable_order_update_status() {
  if (payload_case() != kOrderUpdateStatus) {
    clear_payload();
    set_has_order_update_status();
    _impl_.payload_.order_update_status_ = CreateMaybeMessage< ::t4proto::v1::orderrouting::OrderUpdateStatus >(GetArenaForAllocation());
  }
  return _impl_.payload_.order_update_status_;
}
inline ::t4proto::v1::orderrouting::OrderUpdateStatus* ServerMessage::mutable_order_update_status() {
  ::t4proto::v1::orderrouting::OrderUpdateStatus* _msg = _internal_mutable_order_update_status();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.order_update_status)
  return _msg;
}

// .t4proto.v1.orderrouting.OrderUpdateTrade order_update_trade = 304;
inline bool ServerMessage::has_order_update_trade() const {
  return payload_case() == kOrderUpdateTrade;
}
inline bool ServerMessage::_internal_has_order_update_trade() const {
  return payload_case() == kOrderUpdateTrade;
}
inline void ServerMessage::set_has_order_update_trade() {
  _impl_._oneof_case_[0] = kOrderUpdateTrade;
}
inline ::t4proto::v1::orderrouting::OrderUpdateTrade* ServerMessage::release_order_update_trade() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.order_update_trade)
  if (payload_case() == kOrderUpdateTrade) {
    clear_has_payload();
    ::t4proto::v1::orderrouting::OrderUpdateTrade* temp = _impl_.payload_.order_update_trade_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.order_update_trade_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::OrderUpdateTrade& ServerMessage::_internal_order_update_trade() const {
  return payload_case() == kOrderUpdateTrade
      ? *_impl_.payload_.order_update_trade_
      : reinterpret_cast< ::t4proto::v1::orderrouting::OrderUpdateTrade&>(::t4proto::v1::orderrouting::_OrderUpdateTrade_default_instance_);
}
inline const ::t4proto::v1::orderrouting::OrderUpdateTrade& ServerMessage::order_update_trade() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.order_update_trade)
  return _internal_order_update_trade();
}
inline ::t4proto::v1::orderrouting::OrderUpdateTrade* ServerMessage::unsafe_arena_release_order_update_trade() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.order_update_trade)
  if (payload_case() == kOrderUpdateTrade) {
    clear_has_payload();
    ::t4proto::v1::orderrouting::OrderUpdateTrade* temp = _impl_.payload_.order_update_trade_;
    _impl_.payload_.order_update_trade_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_order_update_trade(::t4proto::v1::orderrouting::OrderUpdateTrade* order_update_trade) {
  clear_payload();
  if (order_update_trade) {
    set_has_order_update_trade();
    _impl_.payload_.order_update_trade_ = order_update_trade;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.order_update_trade)
}
inline ::t4proto::v1::orderrouting::OrderUpdateTrade* ServerMessage::_internal_mutable_order_update_trade() {
  if (payload_case() != kOrderUpdateTrade) {
    clear_payload();
    set_has_order_update_trade();
    _impl_.payload_.order_update_trade_ = CreateMaybeMessage< ::t4proto::v1::orderrouting::OrderUpdateTrade >(GetArenaForAllocation());
  }
  return _impl_.payload_.order_update_trade_;
}
inline ::t4proto::v1::orderrouting::OrderUpdateTrade* ServerMessage::mutable_order_update_trade() {
  ::t4proto::v1::orderrouting::OrderUpdateTrade* _msg = _internal_mutable_order_update_trade();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.order_update_trade)
  return _msg;
}

// .t4proto.v1.orderrouting.OrderUpdateTradeLeg order_update_trade_leg = 305;
inline bool ServerMessage::has_order_update_trade_leg() const {
  return payload_case() == kOrderUpdateTradeLeg;
}
inline bool ServerMessage::_internal_has_order_update_trade_leg() const {
  return payload_case() == kOrderUpdateTradeLeg;
}
inline void ServerMessage::set_has_order_update_trade_leg() {
  _impl_._oneof_case_[0] = kOrderUpdateTradeLeg;
}
inline ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* ServerMessage::release_order_update_trade_leg() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.order_update_trade_leg)
  if (payload_case() == kOrderUpdateTradeLeg) {
    clear_has_payload();
    ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* temp = _impl_.payload_.order_update_trade_leg_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.order_update_trade_leg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::OrderUpdateTradeLeg& ServerMessage::_internal_order_update_trade_leg() const {
  return payload_case() == kOrderUpdateTradeLeg
      ? *_impl_.payload_.order_update_trade_leg_
      : reinterpret_cast< ::t4proto::v1::orderrouting::OrderUpdateTradeLeg&>(::t4proto::v1::orderrouting::_OrderUpdateTradeLeg_default_instance_);
}
inline const ::t4proto::v1::orderrouting::OrderUpdateTradeLeg& ServerMessage::order_update_trade_leg() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.order_update_trade_leg)
  return _internal_order_update_trade_leg();
}
inline ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* ServerMessage::unsafe_arena_release_order_update_trade_leg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.order_update_trade_leg)
  if (payload_case() == kOrderUpdateTradeLeg) {
    clear_has_payload();
    ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* temp = _impl_.payload_.order_update_trade_leg_;
    _impl_.payload_.order_update_trade_leg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_order_update_trade_leg(::t4proto::v1::orderrouting::OrderUpdateTradeLeg* order_update_trade_leg) {
  clear_payload();
  if (order_update_trade_leg) {
    set_has_order_update_trade_leg();
    _impl_.payload_.order_update_trade_leg_ = order_update_trade_leg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.order_update_trade_leg)
}
inline ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* ServerMessage::_internal_mutable_order_update_trade_leg() {
  if (payload_case() != kOrderUpdateTradeLeg) {
    clear_payload();
    set_has_order_update_trade_leg();
    _impl_.payload_.order_update_trade_leg_ = CreateMaybeMessage< ::t4proto::v1::orderrouting::OrderUpdateTradeLeg >(GetArenaForAllocation());
  }
  return _impl_.payload_.order_update_trade_leg_;
}
inline ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* ServerMessage::mutable_order_update_trade_leg() {
  ::t4proto::v1::orderrouting::OrderUpdateTradeLeg* _msg = _internal_mutable_order_update_trade_leg();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.order_update_trade_leg)
  return _msg;
}

// .t4proto.v1.orderrouting.CreateUDSResponse create_uds_response = 340;
inline bool ServerMessage::has_create_uds_response() const {
  return payload_case() == kCreateUdsResponse;
}
inline bool ServerMessage::_internal_has_create_uds_response() const {
  return payload_case() == kCreateUdsResponse;
}
inline void ServerMessage::set_has_create_uds_response() {
  _impl_._oneof_case_[0] = kCreateUdsResponse;
}
inline ::t4proto::v1::orderrouting::CreateUDSResponse* ServerMessage::release_create_uds_response() {
  // @@protoc_insertion_point(field_release:t4proto.v1.service.ServerMessage.create_uds_response)
  if (payload_case() == kCreateUdsResponse) {
    clear_has_payload();
    ::t4proto::v1::orderrouting::CreateUDSResponse* temp = _impl_.payload_.create_uds_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.create_uds_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::t4proto::v1::orderrouting::CreateUDSResponse& ServerMessage::_internal_create_uds_response() const {
  return payload_case() == kCreateUdsResponse
      ? *_impl_.payload_.create_uds_response_
      : reinterpret_cast< ::t4proto::v1::orderrouting::CreateUDSResponse&>(::t4proto::v1::orderrouting::_CreateUDSResponse_default_instance_);
}
inline const ::t4proto::v1::orderrouting::CreateUDSResponse& ServerMessage::create_uds_response() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.ServerMessage.create_uds_response)
  return _internal_create_uds_response();
}
inline ::t4proto::v1::orderrouting::CreateUDSResponse* ServerMessage::unsafe_arena_release_create_uds_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:t4proto.v1.service.ServerMessage.create_uds_response)
  if (payload_case() == kCreateUdsResponse) {
    clear_has_payload();
    ::t4proto::v1::orderrouting::CreateUDSResponse* temp = _impl_.payload_.create_uds_response_;
    _impl_.payload_.create_uds_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_create_uds_response(::t4proto::v1::orderrouting::CreateUDSResponse* create_uds_response) {
  clear_payload();
  if (create_uds_response) {
    set_has_create_uds_response();
    _impl_.payload_.create_uds_response_ = create_uds_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:t4proto.v1.service.ServerMessage.create_uds_response)
}
inline ::t4proto::v1::orderrouting::CreateUDSResponse* ServerMessage::_internal_mutable_create_uds_response() {
  if (payload_case() != kCreateUdsResponse) {
    clear_payload();
    set_has_create_uds_response();
    _impl_.payload_.create_uds_response_ = CreateMaybeMessage< ::t4proto::v1::orderrouting::CreateUDSResponse >(GetArenaForAllocation());
  }
  return _impl_.payload_.create_uds_response_;
}
inline ::t4proto::v1::orderrouting::CreateUDSResponse* ServerMessage::mutable_create_uds_response() {
  ::t4proto::v1::orderrouting::CreateUDSResponse* _msg = _internal_mutable_create_uds_response();
  // @@protoc_insertion_point(field_mutable:t4proto.v1.service.ServerMessage.create_uds_response)
  return _msg;
}

inline bool ServerMessage::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void ServerMessage::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline ServerMessage::PayloadCase ServerMessage::payload_case() const {
  return ServerMessage::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Heartbeat

// int64 timestamp = 1;
inline void Heartbeat::clear_timestamp() {
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t Heartbeat::timestamp() const {
  // @@protoc_insertion_point(field_get:t4proto.v1.service.Heartbeat.timestamp)
  return _internal_timestamp();
}
inline void Heartbeat::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:t4proto.v1.service.Heartbeat.timestamp)
}
inline ::int64_t Heartbeat::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void Heartbeat::_internal_set_timestamp(::int64_t value) {
  ;
  _impl_.timestamp_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace service
}  // namespace v1
}  // namespace t4proto


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_t4_2fv1_2fservice_2eproto_2epb_2eh
